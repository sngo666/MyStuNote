# 第七章 按值传递还是按引用传递？

## 按值传递

并不是所有的情况都会调用拷贝构造函数，考虑一种情况：

```cpp
template<typename T>
void printV (T arg) {
...
}

std::string returnString();
std::string s = "hi";
printV(s);                  //copy constructor
printV(std::string("hi"));  //copying usually optimized away (if not, move constructor)
printV(returnString());     // copying usually optimized away (if not, move constructor)
printV(std::move(s));       // move constructor
```

在第一次调用中，被传递的参数是左值（lvalue），因此拷贝构造函数会被调用。
在第二和第三次调用中，被传递的参数是纯右值, 此时编译器会优化参数传递，使得拷贝构造函数不会被调用.
在C++17之前，如果编译器没有优化掉这一类拷贝，它至少应该先尝试使用移动语义，这通常也会使拷贝成本变得比较低廉。
在最后一次调用中，被传递参数是xvalue,这会通过告知编译器我们不在需要s的值来强制调用移动构造函数（move constructor）。

当按值传递参数时，参数类型会退化(decay)。也就是说，裸数组会退化成指针，const和volatile等限制符会被删除。

### 按值传递会导致类型退化

当按值传递参数时，参数类型会退化(decay)
也就是说，裸数组会退化成指针，const和volatile等限制符会被删除。

## 按引用传递

在底层实现上，按引用传递还是通过**传递参数的地址**实现的。地址会被简单编码，这样可以提高从调用者向被调用者传递地址的效率。

理论上被调用者可以随意更改该地址指向的内容。
这样编译器就要假设在这次调用之后，所有缓存在寄存器中的值可能都会变为无效。而重新载入这些变量的值可能会很耗时（可能比拷贝对象的成本高很多）。你或许会问在按const引用传递参数时：为什么编译器不能推断出被调用者不会改变参数的值？
不幸的是，确实不能，因为调用者可能会通过它自己的非const引用修改被引用对象的值（这个解释太好，另一种情况是被调用者可以通过const_cast移除参数中的const）。

如果编译器可以展开inline函数，那么它就可以基于调用者和被调用者的信息，推断出被传递地址中的值是否会被更改。

### 按引用传递不会做类型退化

按引用传递参数时，其类型不会退化（decay）。也就是说不会把裸数组转换为指针，也不会移除const和volatile等限制符。
