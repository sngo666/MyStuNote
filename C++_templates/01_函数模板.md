# 第一章 函数模板

· 如果在程序中引入了命名空间`using namespace XXX`，在后文中调用`max`,那么引入的命名空间也在检索的范围内，如果使用了作用域限制符`::`，如`::max`，那么程序会在全局作用域中查找模板函数。否则的话，某些情况可能会调用标准库中的同名函数。

· 模板在具体用于某个类型的时候，才会被针对这个类型实例化。
· 模板是被分两步编译的：

1. 模板定义阶段，模板的检查并不包含类型参数的检查。
2. 再次被检查并编译

## 类型转换

· 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T定义的两个参数，它们实参的类型必须完全一样。
· 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：`const`和`volatile`限制符会被忽略，引用被转换成被引用的类型，`raw array`和函数被转换为相应的指针类型。

· 类型推断并不适用于默认调用参数，需要给模板类型也声明一个默认类型。
· 编译器在编译阶段会根据运算符`?:`的返回结果来决定实际的返回类型。不过具体的实现可以有所不同，事实上用true作为运算符`?:`的条件就足够了。、

· `std::common_type`返回一个结构体，结构体的type成员被用作目标类型，例如`std::common_type_t<T1, T2>`

## 默认模板参数

·

```cpp
template<typename T1, typename T2, typename RT = std::decay_t<decltype(true ? T1() : T2())>>
```

对于这种写法，我们要求们能够调用两个模板参数的默认构造参数。

· `std::common_type<>`也是会做类型退化的，因此返回类型不会是引用。
· 在所有其它因素都相同的情况下，模板解析过程将优先选择非模板函数，而不是从模板实例化出来的函数。
· 可以显式指定一个空的模板列表。这表明它会被解析成一个模板调用。
· 模板参数推断时不允许自动类型转换(这一点很重要)，而常规函数是允许的。

· 需要确保函数模板在被调用时，其已经在前方某处定义。

