# 第二章 类模板

· 不同于非模板类，不可以在函数内部或者块作用域内（{...}）声明和定义模板，通常模板只能定义在global/namespace作用域，或者是其它类的声明里面。

· 直到C++17，在使用类模板的时候都需要显式的指明模板参数。
· 模板函数和模板成员函数只有在被调用的时候才会实例化。
· 如果一个类模板有static成员，对每一个用到这个类模板的类型，相应的静态成员也只会被实例化一次。

· 在C++11 之前，在两个相邻的模板尖括号之间必须要有空格：`Stack<Stack< int> > intStackStack;`，从C++11开始，通过”anglebrackethack”技术（参考13.3.1节），在两个相邻的模板尖括号之间不再要求必须使用空格。

· 模板参数只需要提供那些(程序中实际)会被用到的操作（而不是可能会被用到的操作）

· 类模板中的友元函数并不是函数模板，而是在需要的时候，随类模板实例化出来的一个常规函数。详细见12章。

## 类模板特化

· 如果对类模板进行了特化，那么也需要去特化所有的成员函数。虽然允许只特例化模板类的一个成员函数，不过一旦你这样做，你就无法再去特化那些未被特化的部分了。

## 部分特例化

· 类模板可以只被部分的特例化。这样就可以为某些特殊情况提供特殊的实现，不过使用者还是要定义一部分模板参数。这个部分特例化所使用的类型不能是指定类型，而是区别于原来模板参数类型，如:

```cpp
template<typename T>
class Stack<T*>{...}
```

## 多模板参数的部分特例化

· 多模板参数的特例化可以变更类的参数类型，但是不能改变类的参数数量。
· 从C++17 开始，这一要求不在那么严格了。如果构造函数能够推断出所有模板参数的类型（对那些没有默认值的模板参数），就不再需要显式的指明模板参数的类型。

· 当参数是按照T的引用传递的时候：

```cpp
template<typename T>
 class Stack {
 private:
  std::vector<T> elems; // elements
 public:
  Stack () = default;
  Stack (T const& elem) // initialize stack with one element
    : elems({elem}) {
  }
 …
 };
```

参数类型不会被decay，也就是说一个裸的数组类型不会被转换成裸指针。这样我们就等于初始化了一个这样的Stack: `Stack< char const[7]>`
不过如果参数是按值传递的，参数类型就会被decay，也就是说会将裸数组退化成裸指针。
这样构造函数的参数类型T会被推断为`char const *`

· 可以通过提供“推断指引”来提供额外的模板参数推断规则，或者修正已有的模板参数推断规则。

## 推断指引

```cpp
template<typename T> S(T)-> S<T>; 
```

## 聚合类的模板化

聚合类,这样一类class或者struct：

1. 没有用户定义的显式的，或者继承而来的构造函数
2. 没有`private`或者`protected`的非静态成员
3. 没有虚函数
4. 没有`virtual`，`private`或者`protected`的基类

也可以是模板.
