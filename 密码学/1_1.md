# 第一章 密码学和数据安全导论

密码学分为密码使用学和密码分析学，密码使用学主要分为三个方向：对称算法，非对称算法和密码协议。

1. 对称算法：该算法基于以下假设，双方共享一个密钥，并使用相同的加密方法和解密方法。
2. 非对称算法：在公钥密码学中用户也拥有一个密钥，但是他还同时拥有一个公钥。
3. 密码协议： 密码协议主要是针对密码学算法的应用。

## 对称密码学

假设在用户A和B之间存在一个中间攻击人，当A向B发送他的消息，先使用公钥加密，发送加密的数据给B，B再使用同样的公钥对密文进行解密，而A和B之间的公钥传递要确保使用可靠的信道传递。

* 简单堆成加密：替换密码

替换密码的思路非常简单：使用字母表中的一个字母用另一个字符替换。

攻击方法：
蛮力攻击：理论上来说，蛮力攻击总是可以破解对称密码，但是需要非常强大的算力。  
字母频率分析： 替换密码的最大缺点在于，每个字母映射到固定的字母上，导致每个字母的出现频率并没有改变，而一个语言中字母的频率分布总是有特定的规律，单个字母的出现频率也可以推广到相邻几个字母的组合，研究它们的出现频率，能够大大增加猜测的准确性。

* Kerckhoffs原理

即使除密钥之外的整个系统的一切都是公开的，这个密码体制也必须是安全的。尤其是即便攻击者知道系统的加密算法和解密算法，此系统也必须是安全的，

* 合适的密钥长度

1. 只有在蛮力攻击是已知的最好的攻击方法时，我们才会考虑讨论对称加密算法中密钥长度的问题
2. 对称算法和非对称算法所要求的的密钥长度完全不同。

在对称算法中，当密钥长度超过百位时，便需要上百年的时间供计算机去破解。

## 模运算和古典密码

定义: 假设a,r,m都是整数，并且m > 0, 如果m 除 a-r，可记作:  
`a = r mod m`  
其中m称为模数，r称为余数。

总可以找到一个整数a，使得a=q*m+r 其中0<= r< m，对于这样一个系统，除数和余数都不是唯一的。
一般我们选择余数满足0<= r<= m-1

* 整数环

考虑这样一个整数集合，由0~m-1组成，还有这些整数的加法和乘法得到的数组成，该整数集合对应的数学结构可以表示为：
第一部分：集合{0,1,2...,m-1}
第二部分：两种操作+与*，使得所有第一部分中的集合a和b，有：
a + b = c mod m
a * b = d mod m
那么c和d属于该集合。

> 如果环内任何两个数相加或相乘得到的结果时钟在环内，那么这个环就是封闭的。  
> 加法和乘法都是可结合的。  
> 加法中存在中性元素0  
> 环中任何元素a都存在一个负元素-a，加法逆元始终存在。  
> 乘法中存在中性元素1  
> 不是所有元素都存在乘法逆元  
> 找出某个元素的逆元通常比较困难，需要使用欧几里得算法，可以通过一种简单的方法判定给定元素的逆元是否存在。

判定方法：
当且仅当gcd(a, m) = 1(即互质)，一个元素a存在乘法逆元a^(-1),gcd表示最大公约数，另一个环特性是，对于集合内任意三个元素，都满足乘法分配律。

* 凯撒密码

移位密码本身非常简单，例如：设定位移长度为3时，将A替换为d，B替换为e，以此类推，并对字母表使用环绕的方式，最后几个字母位移溢出时移位到靠前的几个字母。
我们对于移位密码的定义是:
假设x,y,k属于字母环中，则：
加密: e(x) = (x+k) mod 26
解密：d(y) = (y-k) mod 26

因为密钥只有26种可能，很难应付蛮力攻击，以及难以防备字母频率分析法。

* 仿射密码

通过以下推广来改善移位密码，放射密码的思路为：首先将明文乘以密钥的一部分，然后再加上密钥的剩余部分。
定义为:

> 假设x,y,a,b在字母环（0~25）中
> 加密： e(x) = y = (a*x+b) mod 26
> 解密： e(y) = x = [a^(-1)*(y-b)] mod 26
> 密钥为k=(a, b), 且满足限制条件gcd(a, 26)=1

对于给定的a，我们可以得到a* a^(-1) = 1 mod 26.

仿射密码的密钥空间也仅仅只有312位。