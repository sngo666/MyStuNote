# 因子分解算法

RSA的安全性被认为完全取决于分解大整数的难度。更准确地说，给定N，其中N=pq，p和q为素数，如果能确定p或q，那么就能破坏RSA。因此，人们投入了大量精力来开发高效的因子分解算法。
下面会简单介绍几种整数分解算法，首先是最简单的穷举法，即尝试根号N一下的数字直到找到满足条件的素数对。
之后，会介绍Dixon算法，以及在其基础上进行改进的二次筛选法。这种算法成功适用于对于130位左右的数字进行因子分解。

## 穷举法

给定一个整数N，尝试使用每个在可能范围内的整数进行尝试，首先参与尝试的数都是奇整数，因此所需要的工作量约为$\sqrt{N}/2$。
进一步情况下，筛掉所有的非质数，工作量被降低到 $π(\sqrt{N})$ ,其中的`π(x)`是计算小于或者等于x的素数数量函数，当N是一个大数，可以认为π(n) ≈ $N/\ln(N)$ (这个公式暂时无从考究)
因此可以得出结论，理想情况下对于大数N的因子分解成本在 $N/\ln(N)$

## Dixon算法

同样地，我们假设需要对于大数N进行因子分解，并保证其存在一个指数对因子。我们假设存在整数x和y，满足 $N = x^2 - y^2$，即 $ N = (x - y)(x + y)$ ，那么就可以说找到了N的因子，更进一步说，如果能够找到x和y满足 $x^2 - y^2$ 数倍于N：
$x^2 = y^2 (mod N)$
我们可以将这个倍数定义为k，即 $(x-y)(x+y) = kN$。如果我们运气不好，存在 $(x-y) = k$ 和 $(x+y) = N$， 况且现将这种情况排出在外，在剩下的可能性中，通过 $\gcd(N, x-y)$ 和 $\gcd(N, x+y)$ 以获得两个因子。

举个简单的例子：
$100 = 9 (mod 91)$, 显而易见可以得到：
x = 10
y = 3
因而得到91的两个因子 $\gcd(91, 7) = 13$ 和 $\gcd(91, 13) = 7$
这样的x和y还有数对，例如 $34^2 = 8^2 (mod 91)$，这就是为什么要使用gcd的原因。由于基于欧几里得算法，gcd的计算难度极低，因此这个想法的难处就在于如何找寻到合适的x和y。
在此基础上，稍微放宽条件，比如一个 $x^2$ 和一个不可开方的整数，如:
$41^2 = 32 (mod 1649)$
$43^2 = 200 (mod 1649)$
将这两个式子的左右两边相乘，得到:
$41^2 *43^2 = 32*200(mod 1649) = 80^2(mod 1649)$
接下来的一切也就顺理成章，可以得出1649的质数因子 17*97。

在上述第二个例子中，将两个非平方组合成一个平方对。原因也很简单将32和200完全结构成质数相乘的组合后会发现:
$32 = 2^5 *5^0$
$200 = 2^3* 5^2$
$32 *200 = 2^8* 5^2$
要找到"完美平方"，只需要关注这些数的质数因子的幂，只要这些幂是偶数，其就是可以被开方的，因此作出如下定义：

$$
32→
\begin{bmatrix}
5\\
0
\end{bmatrix} = \begin{bmatrix}
1\\
0
\end{bmatrix} (mod 2)
$$
$$
200→
\begin{bmatrix}
3\\
2
\end{bmatrix} = \begin{bmatrix}
1\\
0
\end{bmatrix} (mod 2)
$$
$$
200 * 32→
\begin{bmatrix}
8\\
2
\end{bmatrix} = \begin{bmatrix}
0\\
0
\end{bmatrix} (mod 2)
$$

如上式所示，为了确定我们是否具有平方同余，我们只需要幂的(mod 2)向量。
