# 第四章 高级加密标准

尽管3DES能够抵抗利用当前技术发起的蛮力攻击，但它仍然存在一些问题，一方面其软件实现并不高效，DES本就不适合软件实现，3DES更是需要三倍的时间之多。第二个缺点就是分组相对较小，一般分组都是64位，因此我们引入AES。

## AES算法概述

AES密码与分组密码Rijndael基本上完全一致，分组大小和密码大小都可以是128位，192位和256位。然而AES标准只要求分组大小为128位，因此只有分组长度为128位的Rijndael才称为AES算法。

AES密钥长度和轮数的关系如下：
| 密钥长度 | 轮数  |
| :------: | :---: |
|  128位   |  10   |
|  192位   |  12   |
|  256位   |  14   |

与DES相比，单轮的AES就在议论中加密了所有位，这也是AES为什么比DES轮数少的原因。除了第一轮外，每一轮都由三层组成，即字节代换层->扩散层->密钥加法层，第一层只有密钥加法层。在扩散层中分为shiftRows层和MixColumn层，但是最后一轮没有MixColumn层。下面简单介绍每一层。

1. 密钥加法层：128位轮密钥来源于密钥编排中的主密钥，它将与状态进行异或操作。
2. 字节代换层：即S-盒，状态中的每个元素都使用具有特殊数学属性的查找表进行非线性变换。这种方法将混淆引入数据中，即它可以保证对单个状态位的修改可以迅速传播到整个数据路径中。
3. 扩散层： 为所有状态位提供扩散，由两个子层组成，每个子层都在执行线性操作。

* ShiftRows(行移位变化)层在位级别进行数据置换。
* MixColumn(列混淆变换)是一个混淆操作，它合并(混合)了长度为四个字节的分组。

## 伽罗瓦域

有限域有时候也被成为伽罗瓦域，他指的是拥有有限个元素的集合，在了解域之前先简要了解域的概念。
定义:

> 群指的是元素集合G及G内任意两个元素的联合操作@的结合。具有以下特性。  
> 群操作是封闭的，即对于任意两个群内元素进行该操作得出的结果依然属于该群。  
> 群操作是满足结合律的。  
> 存在一个元素1在群内，对于所有的群内元素a满足a@1 = 1@a。此元素1称为中性元(或单位元)。  
> 对每个群内元素a都存在一个元素a^(-1)处于群内，使得a@a^(-1) = a^(-1)@a = 1,那么a^(-1)就称为a的逆元。  
> 在以上所有特性的基础上，如果对所有的群内元素a和b都有a@b = b@a，则称此群为阿贝尔群。

概括来说，群就是一个操作以及对应逆操作的集合。如果该操作为加法，那么对应的逆操作就是减法，如果该操作是乘法，那么其逆操作是除法。

* 域

为了使一种结构同时支持四种基本算术运算(加减乘除),我们需要一个同时包含加法与乘法的集合，也就是我们常说的域(field).
定义：

> 域是拥有以下特性的元素的集合。  
> F中所有元素形成一个加法群，对应的群操作为+，中性元为0。  
> F中除0外的所有元素构成一个乘法群，对应的群操作为*，中性元为1。  
> 当混合使用这两种群操作时，分配定理始终成立，即对于所有a,b,c都在群内，有a(b+c) = ab + ac

在密码编码学中，我们基本上只对拥有有限个元素的域感兴趣，而这样的域也被称为有限域或者伽罗瓦域。域所包含的元素的个数被称为域的阶或基。
_定理_：只有当m是一个素数幂时，即m = p^n (p为素数, n为正整数。)，阶为m的域才存在，p称为这个域的特征。

* 素域

有限域最直观的例子就是阶为素数的域，即n=1的域。域GF(p)的元素可以用整数0，1...p-1来表示。域的两种操作就是模整数加法和整数乘法模p。
_定理_：假设p是一个素数，整数环Zp表示为GF(p),也称为是拥有素数个元素域或伽罗瓦域。GF(p)中所有非零元素都存在逆元，GF(p)中所有的非零元素都存在逆元，GF(p)内的算术运算都是模p实现的。

整数环不仅是一个环，也是一个有限域。为了在素域中进行算术运算，我们必须遵循整数环的以下规则：加法和乘法都必须通过模p实现，任何一个元素a的加法逆元由`a+(-a) = 0 mod p`给出；任何一个非零元素a的乘法逆元定义为`a * a^(-1) = 1 mod p`。
(0的乘法逆元不存在)

GF(2)是重要的素域，也是最小的有限域。

* 扩展域GF(2^m)

在AES中包含256个元素的有限域可以表示为GF(2^8)，选择这个有限域的原因是该有限域中的每个元素都可以用一个字节表示。在S-盒和MixColumn变换中，AES将内部数据路径的每个字节均表示为域中的一个元素，并利用此有限域中的算术运算符操作数据。

m>1的域称为扩展域，为了处理扩展域，我们需要:

1. 使用不同的符号表示此域内的元素。
2. 使用不同的规则执行此域内的元素的运算。

我们使用多项式表示扩展域的元素，并且扩展域内的计算也是通过某种多项式运算得到的。在AES使用的域中，每个元素都可以表示为：
A(x) = a7x^7 + ... + a1x + a0

使用系数为域GF(2)中元素的多项式，并生成相应的系数向量。

* GF(2^m)的加法与减法

AES的密钥加法层使用了加法，扩展域中的加法与减法都十分简单，通过标准的多项式加法与减法即可得到，实际上，仅需要将幂次相同的系数进行加减即可。完成加减法之后要模2。

* GF(2^m)内的乘法

首先使用标准多项式乘法准则将有限域GF(2^m)的两个元素相乘,下面简述扩展域乘法的定义:
> 扩展域乘法  
> 假设A(x),B(x)同属于扩展域内，且有P(x) = pmX^m + ... + p1x + p0  
> 是一个不可约多项式，两个元素的乘法运算为C(x) = [A(x)*B(x)] mod P(x)  
> 因此每个域都需要一个度为m且系数来源于GF(2)的不可约多项式P(x),但是请注意，不是所有的多项式都是不可约多项式。  
> AES所使用的的多项式为P(x) = x^8 + x^4 + x^3 + x + 1 ，它是AES规范的一部分。  

* GF(2^m)内的逆操作

GF(2^8)中的逆操作是字节代换变换的核心操作，字节代换变换包含了AES的S-盒，给定一个有限域GF(2^m)与其对应的不可约简化多项式P(x),任何一个GF(2^m)内非零元素的逆元定义为：`A(x)^(-1) * A(x) = 1 mod P(x)`
表中包含了不可约多项式的的所有逆元，其中一个特例就是域元素0的项，因为它的逆元并不存在，设计者将S-盒定义为输入值为0对应的输出值也为0。
如何查询表：通过将系数矢量化为十六进制，第一位为X，第二位为Y，在表上找到对应的逆元系数向量。

## AES的内部结构

AES是一个面向字节的密码，16字节的输入A0,...A15,按字节输入到S-盒中，16字节的输出B0....B15现在ShiftRows层按字节进行置换，然后由MixColumn变换c(x)进行混淆，最后将128位子密钥ki与中间结果进行异或运算。
DES使用了大量位置换，可以看做是拥有面向位的结构，而AES与其完全相反。假设状态A(128位的数据路径)是由16个字节A0~A15按照4字节成4字节的矩阵方式组成的。同样，密钥字节也是以矩阵方式排列，其行数为4，列数可以为4(128位),6(192位),8(256位)。下面简要讨论每层的作用：

* 字节代换层

每轮的第一层都是字节代换层，字节代换层可以看作是16个并行的S-盒，每个S-盒的输入和输出都是8位，值得注意是，AES使用的S-盒是完全相同的，而DES使用了8个不同的S-盒，在这一层，每个状态字节Ai都被替换或者代换为另一个字节Bi：S(Ai) = Bi。
S-盒是AES唯一的非线性元素，即对两个状态A和B，ByteSub(A) + ByteSub(B) ≠  ByteSub(A + B), S-盒代换是一个双向映射，这也是我们解密时所需要的，在软件实现中，S-盒通常使用一个拥有固定项，256位乘8位的查找表实现。尽管S-盒是双向映射的，但是不存在S(Ai) = Ai
DES的S-盒本质上是拥有某种特性的随机表，而AES的S-盒具有非常强的代数结构。
构建S-盒分成两步，第一步是伽罗瓦域逆操作，第二部分中每个字节与一个常量位矩阵相乘，再与一个8位的常量位的矩阵相加。具体情况不展开说。

* 扩散层

AES的扩散层由两个子层组成，ShiftRow和mixColumn,扩散层对状态矩阵A和B执行的是线性操作DIFF(A) + DIFF(B) = DIFF(A+B)

a. ShiftRow子层

ShiftRow变换循环往复地将状态矩阵的第二行向右移动三个字节，将第三行向右移动两个字节，将第四行向右移动一个字节，行移位变换中状态矩阵的第一行保持不变，行移位变换的目的就是增加AES的扩散属性。

b. MixColumn子层

MixColumn步骤是一个线性变换，它混淆了状态矩阵的每一列，由于每个输入字节都影响了四个输出字节，MixColumn操作是AES中主要扩散元素，ShiftRow子层和MixColumn子层的组合使得三轮以后，状态矩阵的每个字节都依赖于所有16个明文字节都成为可能。

现在，长度为4的每列都可以看做是一个向量，并与一个固定的4*4矩阵相乘，矩阵中的常数用十六进制表示，01代表系数为0000 0001，即伽罗瓦域中的1，以此类推，02代表x，03代表x+1。

* 密钥加法层

密钥加法层的两个输入分别是16字节的当前状态矩阵和长度为16字节的子密钥，这两个输入是通过按位XOR操作组合在一起的。

* 密钥编排

密钥编排将原始输入密钥(长度128、192或256)作为输入，得到AES使用的子密钥，在AES的输入和输出中都使用了子密钥的XOR加法，这个过程有时被称为密钥漂白，子密钥的个数等于轮数加一，这是因为第一个密钥加法层进行密钥漂白时也需要密钥，AES的密钥编排是面向单词的，一个单词为32位。

a. 128位密钥AES的密钥编排
11个子密钥存储在扩展密钥数组W(0~43)中，K0...K15表示原始AES对应的字节。
可知W[4i] = W[4(i-1)] + g(W[4i-1])
这里的g()表示的是一个输入和输出均为4个字节的非线性函数，子密钥的其余三个单词是通过递归计算得到的:
W[4i+j] = W[4i+j-1] + W[4(i-1)+j]
函数g()首先将四个输入字节翻转，并执行一个按字节的S-盒代换，最后与轮系数RC相加，轮系数是伽罗瓦域GF(2^8)中的一个元素，即为8位的值，轮系数只与函数g()右边的值相加，且每轮都会改变，g()的目的有两个，第一是增加密钥编排的非线性，第二是消除密钥编排的非线性，第二，消除AES中的对称性。

关于192和256位的编排不多赘述。

## 解密

由于AES并非基于Feistel网络，所有的层必须颠倒过来，字节代换层变成逆向字节代换层，ShiftRow层变成逆ShiftRow层等等，由于在加密的最后一轮并没有执行MixColumn操作，所以第一层解密也不包含对应逆层，其他所有解密都包含所有的AES层。

* 逆向MixColumn子层

在子密钥加法后，再对状态使用逆向MixColumn操作（解密的第一层除外）,逆转MixColumn操作必须使用该矩阵的逆，输入是状态C的一个4字节长的列，与一个4*4矩阵的逆相乘，系数的加法和乘法都是在GF(2^8)中完成的。输出字节的第二列是四个输入字节与相同的常量矩阵相乘得到的，以此类推。

* 逆向ShiftRow层

为了逆转加密算法中的ShiftRow层，我们必须反向移动状态矩阵中的行，逆向ShiftRow变换并没有改变第一行。

* 逆向字节代换层

由于AES是双向映射，满足: A = S^(-1)(Bi) = S^(-1)(S(A))

* 解密密钥编排

由于解密的第一轮需要最后一个子密钥，解密的第二轮需要倒数第二个子密钥，以此类推，我们需要逆序的子密钥，这个过程一般比加密要稍长一些。

## 软硬件实现

与DES不同，AES是专门为了高效的软件实现而设计的，非常适合8位的处理器，在现代32位或64位处理器中，每个指令处理一个字节的方式是非常低效的。