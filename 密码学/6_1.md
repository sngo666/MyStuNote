# 第六章 公钥密码学

绝大多数公钥算法都基于数论函数，这一点与对称密码完全不同，对称密码通常让输出和输出之间不存在紧凑的数学关系。

* 非对称密码学的基本原理

每个人可以使用公钥加密自己的信息并向系统发送，而只有持有私钥的人才能解密信息。
尽管可以在不使用安全信道建立密钥的情况下加密信息，但如果想要使用类似AES的算法加密，我们仍然不能交换密钥。我们要做的就是一个使用公钥算法加密一个对称密钥。

非对称方案都来自于一个原理，就是单向函数：
> 函数f()是一个单向函数，仅当:  
>
> 1. y=f(x)在计算上是容易的，且有  
> 2. x=f(y)^(-1)在计算上是不可行的。

实际公钥中使用两种主流的单向函数，第一个就是整数分解问题，它是RSA的基础，给定两个素数，计算他们的乘积非常容易，但是将乘积分解因式却是非常困难的。实际上，如果每个素数对应的十进制数字都超过150位，即使数千台PC同时运转多年也不能完成因式分解工作。

## 公钥密码学的主要安全机制

密钥建立： 在不安全信道上建立密钥的协议有若干种，包括Diffle-Hellman密钥交换，或者RSA密钥传输协议。
不可否认性： 可以通过数字签名算法(比如RSA，DSA或者ECDSA)实现不可否认性和消息完整性。
身份标识： 使用质询-响应协议与数字签名相结合的方法识别实体。
加密： 可以使用类似RSA或者Elgamal的算法对消息进行加密。

实际中公钥算法的计算量非常大，这也是公钥方案的主要缺点。因此实际的数据加密过程基本都不使用公钥加密算法，更实用的一般是混合协议。

## 重要的公钥算法

整数分解方案： RSA
离散对数方案： 数字签名算法(DSA)，Elgamal和Diffle-Hellman密钥交换
椭圆曲线方案： 椭圆曲线Diffle-Hellman密钥交换(ECDH)，椭圆曲线数字签名算法(ECDSA)

前两种在相同的安全级别下推荐使用的密钥长度远长于椭圆曲线和对称密钥算法，椭圆曲线虽然很短，但是也是两倍长于对称算法。
而且公钥计算复杂度的增长大致是位增长的三次方。

## 公钥算法的基本数论知识

* 欧几里得算法

我们通常使用一种更简单的算法计算gcd，即`gcd(r0, r1) = gcd(r0-r1, r1)`，在这里我们通常假设r0>r1,也可以写成`gcd(r0, r1) = gcd(r0 mod r1, r1)`以省略中间步骤。

* 扩展的欧几里得算法

扩展的欧几里得算法可以用来计算模逆元，还能够计算以下的线性形式：
`gcd(ro, r1) = s*r0 + t*r1` s和t均表示整形系数，这个等式通常也被称为丢番图方程。
执行标准欧几里得算法，将每轮迭代中的余数表示为以下形式的线性组合：`ri = si*r0 + tir1`

计算过程简述:
根据r0，r1计算出r2 = r0 - k*r1，所以有s1 = 1， s2 = -k;
然后根据r1和r2计算出r3...以此类推。

那么我们如何计算一个域中的乘法逆元呢，其实乘法逆元就是最终得出的系数t，一般我们不使用s，系数t也可以是一个负数，对于阶为m的伽罗瓦域中的一个元A计算gcd(m, A)使用扩展欧几里得算法计算出s和t，得出A^(-1) = t mod m。

* 欧拉函数

Zm内与m互素的整数个数可以表示为φ(m)

如Z(6) 中只有1和5与6互素，那么φ(6) = 2

定理: 假设m可以因式分解成以下数的连乘，m = p1^(e1) * p2^(e2) * ... * pn^(en)，则有φ(m) = ∏(pi^(ei) - pi^(ei-1)) (i: 1~n)
即使对于很大的整数n而言，n的值也总是很小，所以在计算上非常简单。

* 费马小定理与欧拉函数

定理: 假设a为一个整数，p为一个素数，则: a^p = a (mod p)
也可以表现为a^(p-1) = 1 (mod p),计算a的逆元也就是`a^(p-2) mod p`

欧拉函数：假设a和m都是整数，且gcd(a, m) = 1,则有:`a^(φ(m)) = 1 (mod m)`(最终推导式)


