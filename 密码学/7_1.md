# 第七章 RSA密码体制

RSA应用广泛，在实际中常用于数据小片段的加密，例如密钥传输，以及数字签名，比如数字证书。

## 加密与解密

RSA加密和解密都是在整数环Zm内完成的，模计算在其中发挥了核心作用，假设使用RSA加密明文x，表示x的位字符则是Zn={0,1...n-1}内的元素，所以明文x表示的二进制值必然小于n，使用公钥进行加密和使用密钥进行解密可以表示为：
> RSA加密  
> 给定公钥(n, e)=kpub和明文x，则加密函数为：  
> y= e(kpub)(x) = x^e mod n  
> 其中x与y都为整数

> RSA解密  
> 给定私钥d=kpr及密文y，则解密函数为：  
> x=d(kr)(y) = y^d mod n  
> 其中x与y都为整数  

实际中x,y,d都是非常长的数字，通常为1024位或更长，值e有时称为加密函数或公开指数；私钥d有时称为解密指数或保密函数。下面是RSA密码体制的一些需求：

1. 由于攻击者可以得到公钥，所以给定的公钥值e和n，确定私钥d在计算上必须是不可行的。
2. 由于x只是唯一地取决于模数的大小，所以一次RSA加密的位数不能超过n的位长度。
3. 计算加密和解密相对简单，我们需要的只是一种能够快速计算长整数的指数的方法。
4. 给定一个n应该对应很多个密钥/公钥对，否则攻击者可以发起蛮力攻击。

## 密钥生成与正确性验证

RSA密钥生成:
> 输出：公钥：kpub=(n, e) 和私钥： kpr = (d)  
>
> 1. 选择两个大素数p和q  
> 2. 计算n = p*q  
> 3. 计算φ(n) = (p-1)(q-1)  
> 4. 选择满足以下条件的公开指数e(1~φ(n)-1): gcd(e, φ(n)) = 1  
> 5. 计算满足以下条件的私钥d: d*e = 1 mod φ(n)  

条件5保证e的逆元存在模φ(n),因而保证私钥d始终存在。

下面是证明RSA可行性的过程
懒得看懒得想。

## 加密与解密:快速指数运算

通过两种最基本的操作，即平方和乘法，合理规划计算过程中何时平方和乘法，便可以得到想要的结果。我们遵循以下规则:
此算法从左(MSB)至右(LSB)依次扫描指数对应的位，在每轮迭代中(对每个指数而言)计算当前结果的平方，当且仅当被扫描位的值为1时，才会将平方操作得到的结果与x相乘。
就是1的时候，就x乘以自个儿的平方，0的时候自个儿平方。

## RSA的加速技术

* 使用短公开指数的快速加密

当我们使用短公开指数，RSA仍然是安全的，且消息的加密和RSA签名的认证都非常快。

* 使用中国余数定理的快速加密

在不损失RSA安全性的情况下选择一个私钥是不可能的，容易遭受到蛮力攻击的破解。事实证明，私钥的长度必须至少是0.3倍模数n的长度，人们常用的一种替代方法就是基于中国余数定理(CRT)的方法。主要分为三个步骤：

1. 将输入变换到CRT域，约简基元素x，将其分解为模上模数n的两个因子p和q，得到:
`xp = x mod p`
`xq = x mod q`

2. CRT域内的指数运算

使用约简后的x可以执行以下两个指数运算:
`yp = xp^dp mod p`
`yq = xq^dq mod q`

其中两个新的指数为：
dp = d mod (p-1)
dq = d mod (q-1)

变换域内dp和dq这两个指数分别由p和q限定，两个指数以及yp和yq的长度都是n的位长度的一半。
3. 逆变换到问题域

y = [q*cp]yp + [p*cq] yq mod n
Cp = q^(-1) mod p
Cq = p^(-1) mod q

* 寻找大素数

不想看了，具体查阅费马素性测试，Miller-Rabin素性测试。

## 针对RSA的攻击

* 协议攻击

最著名的协议攻击就是利用RSA的延展性，对于大多数协议攻击，都可以利用填充技术来加以避免。RSA有一种不可取的属性叫做延展性，如果攻击者可以将密文转换为另一种密文，而这种密文会导致对明文进行的变换而变的可知，说明此密码方案具有延展性。