# 序列密码

对称密码分为分组密码和序列密码两部分，下面描述这两种类型对称密码的基本差异。
序列密码：序列密码单独加密每个位，他是通过将密钥序列中的每个位与明文位相加实现的，在同步序列密码中的密码序列仅仅取决于密钥，而异步序列密码的密钥序列则取决于密钥和密文。
分组密码：分组密码每次使用相同的密钥加密整个明文位分组，这意味着对给定分组内任何明文位的加密都依赖于与它在同一个分组内的其他所有的明文位。绝大多数分组密码的长度要么是128位(AES),要么是64位，比如DES或者3DES。

序列密码小而快，非常适合计算资源有限的应用，不过一些分组密码在硬件上实现也非常的高效。

## 序列密码的加密与解密

> 明文、密文和密钥都是由单独的位0和1组成  
> 加密: yi = e(x) = (xi+si) mod 2  
> 解密：xi = d(y) = (yi+si) mod 2  

为什么加密和解密都使用相同的函数？
> 因为是二进制运算啊，如果密钥是0或者1，连续加两次结果都不会发生变化。

为什么摸2加法会是一个很好的加密函数？
> 模2运算与XOR运算是等价的，异或运算在现代密码学中具有非常重要的作用。

实际上序列密码的安全性完全取决于密钥序列，生成密钥序列本身就是序列密码的关键所在。

## 随机数生成器

* 真随机数生成器(TRNG)

真随机数生成器的突出特点在于其的输出是完全不可复制的。

* 伪随机数生成器(PRNG)

伪随机数生成器从一个种子值开始通过各种计算得到序列，通常我们提供如下的递归执行以下序列
> s0 = seed  
> si+1 = f(si)   i=0,1,2...  

推广形式如线性同余生成器：
> s0 = seed  
> si+1 = asi +_b mod m   i=0,1...  

其中a,b,m都是整数，PRNG并不是真正意义上的随机，因为是可计算的，c语言中的rand()函数提供如下的参数:
> s0 = 12345  
> si+1 = 1103515245si + 12345 mod (2^31) , i =0,1,2...

* 加密安全的伪随机数生成器

加密安全的伪随机生成器(CSPRNG)是PRNG的一个特例，是一种不可预测的PRNG，通俗的说给定一个密钥序列s(i),s(i+1),...,s(i+n-1)的n个输出位，得到后续位在计算上是不可行的，准确定义为，不存在一个时间复杂度为多项式的算法使得成功预测下一个s(n+1)的概率超过50%。
只有密码学才要求CSPRNG具有不可预知性，几乎所有不是专门为序列密码而设计的PRNG都不是CSPRNG。

* 一次一密

无条件安全：如果一个密码体制在无限计算资源的情况下也不能被破译，则说明它是无条件安全的或信息理论上安全的。
这一点很难做到，计算安全更容易实现。

下面描述如何构建一个无条件安全的密码，这个密码就是一次一密(OTP)：
> 一个序列密码称为一次一密，必须满足下列条件：  
>
> 1. 通过真随机数生成器得到密钥序列si  
> 2. 只有合法的同新方才知道密码序列  
> 3. 每个密钥序列位si仅使用一次  
> 一次一密是无条件安全的  

一次一密的密钥长度必须要和明文一样长，所以在实际中很少使用。

* 实际序列密码

计算安全:如果破解一个密码体制，最好的已知算法需要至少t个操作，说明此密码体制是计算安全的。
虽然看上去十分合理，但是人们通常不知道对于给定的攻击而言最好的算法是哪一个。

1. 利用PRNG构建密码流

许多PRNG都拥有良好的统计属性，对于强壮的序列密码而言非常有必要。自然而然假设PRNG可以用来生成密钥流，但是如果对手获得了足够长的明文(一部分)，那么他可以仅仅靠着一部分明文与密文(必定已知)，推测出线性同余器的未知数A和B(上文中的a和b)。

2. 利用CSPRNG构建密钥序列

相当一部分在密码学之外的伪随机数生成器都不是密码安全的，实际中我们需要专门设计的伪随机数生成器来生成序列密码。设计思路主要分两种：要么是针对软件优化的密码。要么是针对硬件优化的密码。


## 基于移位寄存器的序列密码

一种得到长伪随机序列的简单方法就是使用线性反馈移位寄存器(LFSR)，很容易用硬件实现。一个简单LFSR可以产生拥有良好统计属性的序列，但是该序列在密码体制中非常脆弱。一个LFSR由若干个时钟存储元件(触发器)和一个反馈路径组成，m个触发器的LFSR成为度为m。

最简单的LFSR反馈线路，一眼就看懂，不用多说。

* 数学描述:
在度为m的反馈线路中，每一个触发器存在一个可能的反馈位置，某条反馈路径是否活跃取决于反馈系数p0,...p(m-1)。
pi=1时，此反馈是活跃的，反之则对应触发器的输出将不会被反馈。
假设某LFSR的初试序列为s0...s(m-1),那么LFSR的下一个输出位Sm为:
sm = [s(m-1)p(m-1) + ... + s1p1 + s0p0] mod 2
那么同样以此类推:
s(m+1) = [smp(m-1) + s(m-1)p(m-2) + ... + s1p0] mod 2

很明显可以看出，输出值都是一些前面输出值的线性组合形式，因此LFSR有时也被称作线性递归。同时需要注意的是，只有特定的序列(p0,p1...p(m-1))才能够得到最大长度的LFSR，即对于度m，可以得到最长序列长度2^m-1。

> LFSR通常使用以下多项式来指定:  
> P(x) = x^m + p(m-1)x^(m-1) + ... + p1x + p0

* 针对单个LFSR的已知明文攻击

如果一个密码体制中的密钥位只呈现线性关系，那么该密钥会变得相当不安全。如果将LFSR作为序列密码使用，密钥k就是反馈系数向量P，如果攻击者知道部分明文和密文，他就可能发起攻击，进一步假设如果攻击者知道度m，那么攻击将会变得非常高效

从结论上来说只要攻击者知道度为m的LFSR的2m个输出位，他就可以通过仅求解一个线性等式系统来精确地构建系数pi，一旦知道反馈系数向量，就可以精确构建LFSR，并加载已知的任意m个连续的输出位。那么理论上LFSR本身就是及其不安全的，但是它并没有丧失全部密码属性，许多序列密码都是使用多个LFSR的组合构建强壮的密码体制。

## Trivium

Trivium是一个较新的序列密码，其密钥长度为80位，Trivium是基于三个移位寄存器的组合，尽管它使用的移位寄存器都是反馈移位寄存器，但是与传统LFSR不同的是，Trivium使用了非线性组件。

* 描述
核心是三个移位寄存器A,B和C,长度分别为93,84和111位，所有三个寄存器输出的XOR和构成了密钥序列s，此密码的一个特征是，每个寄存器的输出都与另一个寄存器的输入相连接，因此，寄存器是以一种类似环的形式排列的，这个密码可以看作为一个总长度为93+84+111=288的环形寄存器。

每个寄存器的输入都是由两个位的XOR和计算得到的：
特定位置的寄存器被反馈给输入，如寄存器A的第69位被反馈给它的输入。
每个寄存器的输出是三个位的XOR和计算到的。

* 讨论安全性
