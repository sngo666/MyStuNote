# 64位软件逆向技术

* 栈平衡

在64位操作系统中，使用RSP来保存当前栈顶的指针，使用每八个字节存储一个数据。在x64环境下，某些汇编指令会对栈顶的对齐值有要求，因此VS在申请空间时，尽量保证栈顶地址对齐值为16(可以被16整除)

* 启动函数

当Main函数执行完成时，通常会调用exit退出进程，根据此特征，在入口代码找到第一处`call cs:exit`，该处上面的第一个call通常就是main函数。

* 调用约定

x64应用程序只有一种寄存器快速调用约定，前四个参数使用寄存器传递，超过的参数存入栈内，从右向左，寄存器顺序为RCX、RDX、R8、R9。XMM0、XMM1、XMM2、XMM3用于存放浮点类型。虽然函数的前4个参数使用寄存器传递，但是栈仍然为这4个参数预留了空间(32字节)，而因为使用了寄存器，故这些寄存器在函数内部无法使用，所以可以把寄存器的值放进申请的栈空间中进行使用。
在实际运用中，如果参数个数大于四个，在申请32个预留空间的基础上还要为剩下的参数分配空间，并从[rsp+20h]处开始分配第五个参数。

当参数为结构体时，所需要的内存空间就可能会大于8个字节。当参数是结构体且大小大于八个字节时，在传递参数时，会先把结构体内容复制到栈空间，然后在把地址传递给函数，即引用传递，在函数体内部通过引用+偏移地址的形式访问。

关于thiscall传递
thiscall调用约定是C++类的成员函数调用约定，类的成员函数和参数传递方式与普通函数没有很大区别，唯一的区别就是在成员函数调用会隐含地传递一个this指针参数。

* 数据结构

局部变量生命周期是从进入函数体内开辟内存空间直到函数结束为止，剩下的不用我多说了。
全局变量在编译期就会固定下来，因此一般会用固定的地址去访问全局变量，全局变量的地址也是先定义的地址后定义的在高地址。一般根据此特征还原全局变量在源代码中的定义顺序。
此外，在示例程序中给出一段对于已分配栈空间的初始化的源代码：

```asm
push rdi
sub rsp, 20h
mov rdi, rsp
mov ecx, 8
mov eax, 0CCCCCCCh
rep stosd
```

在这里为栈分配了32字节的内存空间，对每四个字节进行初始化，所以这个过程要进行8次，`rep stosd`的作用是持续将eax的值赋给rdi所指向的内存空间，stosd中的d指的是DWORD，也就是说该操作每次修改四个字节的值。除此之外还有stosb(byte)和stosw(word)，就不多赘述了。

数组中的数据存储在内存中是从低位向高位顺序排列的，且是线性连续的。
数组元素的地址 = 数组首地址 + 下标*元素字节长度

* 控制语句

对于流程控制语句的识别是逆向分析的基础，书中主要介绍了两种方法，即特征识别法和图形识别法。

特征识别法：在汇编程序段中，当进行比较之后执行JCC指令跳转到数行之后，且跳转的if_end语句中没有jmp指令，根据cmp语句可还原if语句。

图形识别法：在IDA中会有虚线箭头表示结构跳转。

相较于if语句，if...else最大的区别就是在cmp判定未成功不跳转的语句块内，加入了跳过cmp判定成功所要跳转的语句块的指令。在IDA图形界面中的呈现为，虚线中间是if else，实现中间为if成功语句块。
其他的就不多赘述了。

对于switch-case语句，当分支数小于6时会直接使用if...else语句来实现，大于等于6时编译器会专门进行优化。
当case>=6且值间隔较小时，编译器会采用case表的形式实现switch语句，编译器的实现思路是先把所有需要跳转的case位置偏移放在一个一维数组的表中，然后把case的值当成数组下标的值进行跳转。当case较多时，编译器直接使用if语句来实现switch，采用了判定树的优化方案。从节点中找到一个中间值作为根节点，形成一棵二叉平衡树。

* 转移机器指令码的计算

a. call/jmp direct
JMP的使用x64依然与x86类似。
`JMP dest`中的位移量 = dest - local - 跳转指令的长度(5h)
转移指令机器码 = 转移类别机器码(E9) + 位移量

b. call/jmp memory direct
在64位系统中，指令地址由原来的4字节变为8字节，若x64也和x86采取相同的方式，指令的长度就会增长，为了解决这个问题，x64系统中，指令后面仍然跟着是4节指令，只不过该地址为相对地址。
相对地址 = dest - local - 跳转指令长度(6)
机器码 = FF15h + 相对地址

* 循环语句

对于do...while结构来说，在程序循环内的语句块后面，往往跟着一个判定语句，并在满足判定时向上跳跃，特征十分明显。

while语句中相较于do...while只是在开头多了一条跳转到判定语句的命令。

* 数学运算

除了使用LEA提高程序执行效率之外，编译器还会使用常量折叠。在编译阶段针对有固定结果的常量表达式，使用计算结果代替常量表达式。

