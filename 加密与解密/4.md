# 64位软件逆向技术

* 栈平衡

在64位操作系统中，使用RSP来保存当前栈顶的指针，使用每八个字节存储一个数据。在x64环境下，某些汇编指令会对栈顶的对齐值有要求，因此VS在申请空间时，尽量保证栈顶地址对齐值为16(可以被16整除)

* 启动函数

当Main函数执行完成时，通常会调用exit退出进程，根据此特征，在入口代码找到第一处`call cs:exit`，该处上面的第一个call通常就是main函数。

* 调用约定

x64应用程序只有一种寄存器快速调用约定，前四个参数使用寄存器传递，超过的参数存入栈内，从右向左，寄存器顺序为RCX、RDX、R8、R9。XMM0、XMM1、XMM2、XMM3用于存放浮点类型。虽然函数的前4个参数使用寄存器传递，但是栈仍然为这4个参数预留了空间(32字节)，而因为使用了寄存器，故这些寄存器在函数内部无法使用，所以可以把寄存器的值放进申请的栈空间中进行使用。
在实际运用中，如果参数个数大于四个，在申请32个预留空间的基础上还要为剩下的参数分配空间，并从[rsp+20h]处开始分配第五个参数。

当参数为结构体时，所需要的内存空间就可能会大于8个字节。当参数是结构体且大小大于八个字节时，在传递参数时，会先把结构体内容复制到栈空间，然后在把地址传递给函数，即引用传递，在函数体内部通过引用+偏移地址的形式访问。

关于thiscall传递
thiscall调用约定是C++类的成员函数调用约定，类的成员函数和参数传递方式与普通函数没有很大区别，唯一的区别就是在成员函数调用会隐含地传递一个this指针参数。

* 数据结构

局部变量生命周期是从进入函数体内开辟内存空间直到函数结束为止，剩下的不用我多说了。
全局变量在编译期就会固定下来，因此一般会用固定的地址去访问全局变量，全局变量的地址也是先定义的地址后定义的在高地址。一般根据此特征还原全局变量在源代码中的定义顺序。
此外，在示例程序中给出一段对于已分配栈空间的初始化的源代码：

```asm
push rdi
sub rsp, 20h
mov rdi, rsp
mov ecx, 8
mov eax, 0CCCCCCCh
rep stosd
```

在这里为栈分配了32字节的内存空间，对每四个字节进行初始化，所以这个过程要进行8次，`rep stosd`的作用是持续将eax的值赋给rdi所指向的内存空间，stosd中的d指的是DWORD，也就是说该操作每次修改四个字节的值。除此之外还有stosb(byte)和stosw(word)，就不多赘述了。

数组中的数据存储在内存中是从低位向高位顺序排列的，且是线性连续的。
数组元素的地址 = 数组首地址 + 下标*元素字节长度

* 控制语句

对于流程控制语句的识别是逆向分析的基础，书中主要介绍了两种方法，即特征识别法和图形识别法。

特征识别法：在汇编程序段中，当进行比较之后执行JCC指令跳转到数行之后，且跳转的if_end语句中没有jmp指令，根据cmp语句可还原if语句。

图形识别法：在IDA中会有虚线箭头表示结构跳转。

相较于if语句，if...else最大的区别就是在cmp判定未成功不跳转的语句块内，加入了跳过cmp判定成功所要跳转的语句块的指令。在IDA图形界面中的呈现为，虚线中间是if else，实现中间为if成功语句块。
其他的就不多赘述了。

对于switch-case语句，当分支数小于6时会直接使用if...else语句来实现，大于等于6时编译器会专门进行优化。
当case>=6且值间隔较小时，编译器会采用case表的形式实现switch语句，编译器的实现思路是先把所有需要跳转的case位置偏移放在一个一维数组的表中，然后把case的值当成数组下标的值进行跳转。当case较多时，编译器直接使用if语句来实现switch，采用了判定树的优化方案。从节点中找到一个中间值作为根节点，形成一棵二叉平衡树。

* 转移机器指令码的计算

a. call/jmp direct
JMP的使用x64依然与x86类似。
`JMP dest`中的位移量 = dest - local - 跳转指令的长度(5h)
转移指令机器码 = 转移类别机器码(E9) + 位移量

b. call/jmp memory direct
在64位系统中，指令地址由原来的4字节变为8字节，若x64也和x86采取相同的方式，指令的长度就会增长，为了解决这个问题，x64系统中，指令后面仍然跟着是4节指令，只不过该地址为相对地址。
相对地址 = dest - local - 跳转指令长度(6)
机器码 = FF15h + 相对地址

* 循环语句

对于do...while结构来说，在程序循环内的语句块后面，往往跟着一个判定语句，并在满足判定时向上跳跃，特征十分明显。

while语句中相较于do...while只是在开头多了一条跳转到判定语句的命令。

* 数学运算

除了使用LEA提高程序执行效率之外，编译器还会使用常量折叠。在编译阶段针对有固定结果的常量表达式，使用计算结果代替常量表达式。

a. 有符号的除法，除法2^n

当除数为2^n时，编译器一般会进行位移优化，示例如下：
> 如果x>=0，则x/(2^n) = x>>n；当x<0时，x/(2^n) = (x+(2^n-1)) >> n

b. 有符号数的除法，除数为-(2^n)

当除数为负时，与上述情况相比需要再对结果求一次补码。

* 虚函数

虚函数是多态的一种体现，相同的类的对象共享一张虚表，如果一个类至少有一个虚函数，那么编译器就会为这个类产生一张虚表。
成员函数调用下的第一个参数都是this指针，c++语法规定，在实例化对象时会自动调用构造函数，对象作用域会自动调用析构函数。对于虚表特征的总结如下：
> 如果一个类至少有一个虚函数，这个类就有一个指向虚表的指针。  
> 不同的类虚表不同，相同的类对象共享一个虚表。  
> 虚表指针存放在对象首地址处。  
> 虚表地址在全局数据区。  
> 虚表的每一个元素都指向一个类成员函数指针(8个字节)。  
> 虚表不一定以零结尾。  
> 虚表的成员函数顺序按照类的声明顺序排列。  
> 虚表在构造函数中被初始化。  
> 虚表在析构函数中会被赋值。  

当虚表在构造函数中被初始化时，会首先选择该对象的首地址指针，将虚表的首地址拷贝进去。类实例对象的内存结构为，this+0的位置存放指向虚函数表的指针，后面的成员依次按顺序(声明的顺序)排列。

main函数使用new申请对象空间，除去成员的空间之外，还需要给虚表分配八个字节的空间，并在最后考虑内存对齐，且派生类和基类共享一个虚表指针。如果申请对象成功，就调用构造函数，并且保存构造函数的返回值this指针。

构造函数的调用顺序如下：

1. 调用虚基类构造函数->调用普通基类构造函数->调用对象成员的构造函数->调用派生类构造函数
2. 以上如果同一类有多个构造函数，就按继承(或定义)顺序调用构造函数。
3. 析构函数的调用顺序与调用构造函数的顺序相反。

派生类的虚表填充规则如下：

1. 复制基类的虚表.
2. 如果派生类虚函数中有覆盖基类的虚函数，使用派生类的虚函数地址覆盖对应表项。
3. 如果派生类由新增的虚函数，将其放在虚表后面。

在多继承流程中，由于两个基类都有各自的虚表，在这种情况下，编译器会为两个派生类，生成两个虚表并在构造函数时初始化，虚表项的顺序按规则来。唯一区别就是新增的虚函数挂在第一个虚表后面。

最后是关于菱形继承的案例分析，这里需要特别注意的一点是，菱形继承的结构是当一个类同时继承一个基类的两个派生类时，按照上述传统思路进行虚表构建流程时，会因为同时对于两个派生类的构建重复调用基类的构造函数，C++虚函数继承规则给出的解决方法是编译器给构造函数多传递一个参数，用来表示是否调用基类的构造。
在内存中的继承顺序是:
本类的虚表指针->虚基类偏移表->基类成员->内存对齐(如果需要的话)
类继承的顺序是，派生类(按继承顺序)->基类，即自下向上。
在逆向分析中，如果发现一个类的虚表中有_purecell虚表项，就可以怀疑这个类是抽象类。
