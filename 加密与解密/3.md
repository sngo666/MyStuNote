# 32位软件逆向技术

* 启动函数

在编写Win32应用程序时，都必须在源码里实现一个WinMain函数，但是Windows的执行并不是从WinMain开始执行的，首先被执行的是启动函数的相关代码，由编译器生成，启动代码初始化进程完成后，才会调用WinMain函数。
所有C/C++程序运行时，启动函数的作用基本相同，包括检索指向新进程的命令行指针，检索指向新进程的环境变量指针，全局变量初始化和内存栈初始化。完成初始化操作后，启动函数就会调用应用程序的进入点函数(main和WinMain)。当进入点返回时，启动函数调用C运行库的exit函数，将返回值(nMainRetval)传给它,进行一些必要的处理，最后调用系统函数ExitProcess退出。
在程序启动的部分汇编代码中，完成以下工作：

```asm
call KERNEL32.GetVersion        ;确定Windows版本
...
push eax
call KERNEL32.GetCommandLineA   ;指向进程的完整命令行的指针
...
push esi
call KERNEL32.GetStartupInfoA   ;获取一个进程的启动信息
push eax
call 00401000                   ;调用用户编写的程序进入点函数WinMain
                                ;分析程序时，直接进入00401000h处即可
...
```

开发人员可以修改启动源代码，但这样做会导致即使在同一个编译器，生成的启动代码也不同。

* 函数

程序通过调用程序来调用函数，在函数执行后又返回调用程序继续执行，调用函数的代码中保存了一个返回地址，绝大多数情况下，编译器都使用call和ret指令来调用函数及返回调用位置。
函数的参数传递共有三种形式，分别是通过栈方式、寄存器方式以及通过全局变量进行隐含参数的传递方式。

a. 利用栈传递函数
我们需要制定标准以确定一些细节问题：如按什么顺序将参数压入栈，函数结束后由谁平衡栈。这种约定称为调用约定(Calling convention):

| 约定类型       | __cdecl(C规范) | pascal | stdcall | Fastcall |
|:----------:|:------------:|:------:|:-------:|:--------:|
| 参数传递方式     | 自右向左         | 自左向右   | 自右向左    | 使用寄存器和栈  |
| 平衡栈者       | 调用者          | 子程序    | 子程序     | 子程序      |
| 允许使用VARARG | 是            | 否      | 是       |          |

VAvRARG表示参数的个数可以是不确定的，stdcall如果使用VARARG类型就是调用程序平衡栈，否则就是被调用程序平衡栈。
stdcall调用约定是Win32API采用的约定方式。
从右向左意思是从最后一个参数开始向左依次压入栈。平衡栈的方式是修改指向栈顶的指针ESP，增大指针以内缩栈的空间。
如果函数体内部需要局部变量，也需要在栈内部预留位置(在函数内也可以执行)

一般使用EBP寄存器保存调用前的ESP，方便调用结束后恢复。有时候编译器为了节省速度或EBP寄存器，会直接通过ESP对参数进行寻址。

b. 利用寄存器传递参数

靠寄存器传递参数的调用方式，特点就是快。VC在使用ECX和EAX寄存器用完之后就是栈，仍然服从从右向左的顺序。另一个调用规范thiscall也用到了寄存器传递参数，thiscall是C++中非静态成员函数的默认调用约定，采用此约定时，函数的参照按照从右向左的顺序入栈，被调用的函数在返回前清理传送参数的栈，仅通过ECX寄存器传送的额外参数——this指针。

c. 名称修饰约定

为了允许使用操作符和函数重载，c++往往会按照某种规则改写每一个入口号的负号名，从而允许同一个名字有多个用法且不会破坏现有的基于C的链接器，这项技术通常被称为改编或名称修饰。
C编译时函数名修饰约定如下：

> stdcall调用约定在函数名前加一个下划线前缀，并在后面加上一个`@`以及参数所需的字节数。  
> __cdecl调用约定仅在输出函数名前加一个下划线前缀。  
> Fastcall约定和stdcall类似，不过开头的下划线变成`@`。  
> pascal约定输出的函数名不能有修饰且全部为大写。  

C++编译时函数名修饰约定如下：

> stdcall规定以问号标识函数名的开始，在函数名后以`@@YG`标明参数表的开始，参数表第一项为该函数的返回值类型，后面依次为参数的数据类型，指针标识在其所指数据类型前，参数表以一个`@`结束，如果没有参数则不需要，最后以`Z`结束。  
> __cdecl约定和stdcall类似，这是参数表的标识变成了`@@YG`。  
> Fastcall约定和stdcall类似，这是参数表的标识变成了`@@YI`。  

* 函数的返回值

a. 使用return操作符返回值

一般情况下，函数的返回值会放在EAX寄存器中返回，如果返回值的长度大于超过EAX寄存器容量，其高就会放到EDX寄存器中。
在反编译程序中的呈现只是手动将结果赋值给EAX。

b. 通过参数按引用方式返回值

在汇编中通过引用方式返回值，其本质是通过对于变量的指针完成传递。

* 数据结构

a. 局部变量

局部变量分配空间时通常会使用栈和寄存器。我们一般使用`add`一个负值或`sub`一个正值为栈开辟空间，反之则消除该变量，也可以直接将寄存器或值压入栈。

b. 全局变量

全局变量通常位于数据区块(.data)的一个固定地址处，程序需要访问全局变量时，一般用一个固定的编码地址直接对内存进行访问。

c. 数组

数组是相同类型元素的集合，在内存按顺序连续排列。寻址一般使用基址+偏移量实现。这个偏移量还是按内存尺度来的，不是按元素个数尺度来的。

* 虚函数

所有对于虚函数的引用通常放在虚函数表(VTBL)中，这是一个专用数组。调用虚函数时，程序首先取出虚函数表指针(VPTR)，得到虚函数表的地址，并检索对应函数的地址，再根据地址调用该函数。
从C++编程角度来说，非虚函数和被重载的虚函数不会被写入虚函数表内，也就是说所谓被继承的，也只是该虚函数的使用权罢了(但是每个类是有个虚表的)。
进一步扩展地说在一个类中有一个指针叫做`__vptr`,对象调用对象的虚函数，实质上是调用类的虚函数。我们把经过虚表调用虚函数的过程称为动态绑定，表现出的现象称为运行时动态，传统的函数调用称为静态绑定。

* 控制语句

将语句IF-THEN-ELSE编译成汇编代码后，整数使用CMP进行比较。CMP不会修改操作数，也有使用test进行jcc指令的。

SWITCH语句本质上就是多个IF-ELSE语句的组合，本质上还是CMP和JCC指令的组合。

* 转移指令

在软件分析过程中，经常需要计算转移指令机器码或修改指定的代码，根据转移距离的不同，有如下类型：
短转移：无条件转移和条件转移的机器码均为2字节，转移范围是-128~127字节
长转移：无条件转移的机器码为5字节，条件转移的机器码为6字节。条件转移需要2字节表示转移类型，4字节表示转移量，而无条件转移也需要1字节表示其转移类型。
子程序调用转移(call)：一类调用是我们常用的类似于长转移，另一类调用参数涉及寄存器、栈等值。
有两个类型可以制约指令机器码，一个是转移类型，一个是转移的位移量。

a. 短转移指令机器码
无条件短转移的机器码形式为"EBxx"，xx中00~7Fh为向后转移，80~FFh为向前转移，位移量= 目的地址-起始地址-跳转指令本身的长度，转移指令机器码 = 转移类别机器码+位移量。其本质是操作修改EIP寄存器。

b. 长转移指令机器码
长转移指令的位移量存储在一个双字中，存储时，低位存入低字节，高位存入高字节。也就是说会导致以相反的次序存储。

* 条件设置指令

条件设置指令的形式是"SETcc r/m8"。条件设置指令通过根据处理器定义的条件测试一些标志位，条件满足时，目标操作数置1，否则置0。

* 循环语句

循环语句是高级语言中一种可以反向引用的一种语言形式，对于循环代码的分析首先应当是对于循环次数的判断。

* 数学运算符

下面简要介绍经过编译器优化的运算符。
对于加法而言，一般会被编译成add和sub指令，进行编译优化时，很多人喜欢用lea指令来代替add指令和sub指令，lea可以在一个时钟周期内快速计算加法指令。
乘法一般被编译为MUL或IMUL，但是编译器更倾向于使用效率更高的指令代替，比如乘数为2时可以用SHL，配合加法可以对于3，5，9等倍数的乘法性能有很好的提升。
整数的除法性能低于乘法十倍以上，被除数是未知数时通常使用div指令，是一个常量的情况下有限考虑使用位移指令。此外，除法指令需要使用符号扩展指令CDQ，作用是将EAX寄存器中的数视为有符号的数，并把符号位扩展到EDX寄存器中，即若 符号位为1，则EDX的每一位都是1。

* 文本字符串

在c字符串中，以'\0'作为结束符，该结束符是不可见的。
在DOS字符串中，以'$'作为结束符。
在Pascal字符串中，没有结束符，而是在头部定义一个字节作为字符串长度，所以通常来说字符串长度不能超过255。
Delphi字符串在Pascal字符串基础上扩展了长度，有双字节和四字节的字符串，这里字节数均表示开头长度所占的位数。

* 字符寻址指令

这里需要补充的一点是，LEA指令的速度远高于普通的加法，`LEA EAX, [EAX+8]`等价于`ADD, EAX 8`,这种技巧可以使多个变量的求和在一个机器周期内完成。

* 最后关于strlen

对于strlen编译出的汇编程序段，非常巧妙。

```asm
mov ecx, FFFFFFFFh
sub eax, eax
repnz
scasb
not ecx
dec ecx
je xxxxxxx
```

repnz指令负责重复执行，每循环一次cx自动减1，cx或ecx为0或ZF=1时结束，使用DI或EDI存放目标的指针，ZF=1说明“比较的结果为0”，说明匹配成功。
scasb将al中的内容和di中的值相匹配，其中di遍历的方向由DF决定，DF为0时，di逐次增长，反之则反。匹配成功时则将ZF置1，这里al中值为0，即匹配字符串结束符。
(妙啊)
`repnz scasb`的执行顺序是先判断，然后减1，然后进行匹配操作。

* 指令修改技巧

很多指令都针对EAX寄存器作了优化，所以要尽量使用EAX寄存器。也可以使用NOP替换一个字节的空间，使用入栈和出栈共占用两个字节空间，自增自减也能达到相同的效果。
