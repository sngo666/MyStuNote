# 逆向分析技术

## 32位软件逆向技术

* 启动函数

在编写Win32应用程序时，都必须在源码里实现一个WinMain函数，但是Windows的执行并不是从WinMain开始执行的，首先被执行的是启动函数的相关代码，由编译器生成，启动代码初始化进程完成后，才会调用WinMain函数。
所有C/C++程序运行时，启动函数的作用基本相同，包括检索指向新进程的命令行指针，检索指向新进程的环境变量指针，全局变量初始化和内存栈初始化。完成初始化操作后，启动函数就会调用应用程序的进入点函数(main和WinMain)。当进入点返回时，启动函数调用C运行库的exit函数，将返回值(nMainRetval)传给它,进行一些必要的处理，最后调用系统函数ExitProcess退出。
在程序启动的部分汇编代码中，完成以下工作：

```asm
call KERNEL32.GetVersion        ;确定Windows版本
...
push eax
call KERNEL32.GetCommandLineA   ;指向进程的完整命令行的指针
...
push esi
call KERNEL32.GetStartupInfoA   ;获取一个进程的启动信息
push eax
call 00401000                   ;调用用户编写的程序进入点函数WinMain
                                ;分析程序时，直接进入00401000h处即可
...
```

开发人员可以修改启动源代码，但这样做会导致即使在同一个编译器，生成的启动代码也不同。

* 函数

程序通过调用程序来调用函数，在函数执行后又返回调用程序继续执行，调用函数的代码中保存了一个返回地址，绝大多数情况下，编译器都使用call和ret指令来调用函数及返回调用位置。
函数的参数传递共有三种形式，分别是通过栈方式、寄存器方式以及通过全局变量进行隐含参数的传递方式。

a. 利用栈传递函数
我们需要制定标准以确定一些细节问题：如按什么顺序将参数压入栈，函数结束后由谁平衡栈。这种约定称为调用约定(Calling convention):
|    约定类型    | __cdecl(C规范) |  pascal  | stdcall  |    Fastcall    |
| :------------: | :------------: | :------: | :------: | :------------: |
|  参数传递方式  |    自右向左    | 自左向右 | 自右向左 | 使用寄存器和栈 |
|    平衡栈者    |     调用者     |  子程序  |  子程序  |     子程序     |
| 允许使用VARARG |       是       |    否    |    是    |                |
VAvRARG表示参数的个数可以是不确定的，stdcall如果使用VARARG类型就是调用程序平衡栈，否则就是被调用程序平衡栈。
stdcall调用约定是Win32API采用的约定方式。
从右向左意思是从最后一个参数开始向左依次压入栈。平衡栈的方式是修改指向栈顶的指针ESP，增大指针以内缩栈的空间。
如果函数体内部需要局部变量，也需要在栈内部预留位置(在函数内也可以执行)

一般使用EBP寄存器保存调用前的ESP，方便调用结束后恢复。有时候编译器为了节省速度或EBP寄存器，会直接通过ESP对参数进行寻址。

b. 利用寄存器传递参数

靠寄存器传递参数的调用方式，特点就是快。VC在使用ECX和EAX寄存器用完之后就是栈，仍然服从从右向左的顺序。另一个调用规范thiscall也用到了寄存器传递参数，thiscall是C++中非静态成员函数的默认调用约定，采用此约定时，函数的参照按照从右向左的顺序入栈，被调用的函数在返回前清理传送参数的栈，仅通过ECX寄存器传送的额外参数——this指针。

c. 名称修饰约定

为了允许使用操作符和函数重载，c++往往会按照某种规则改写每一个入口号的负号名，从而允许同一个名字有多个用法且不会破坏现有的基于C的链接器，这项技术通常被称为改编或名称修饰。
C编译时函数名修饰约定如下：
> stdcall调用约定在函数名前加一个下划线前缀，并在后面加上一个`@`以及参数所需的字节数。  
> __cdecl调用约定仅在输出函数名前加一个下划线前缀。  
> Fastcall约定和stdcall类似，不过开头的下划线变成`@`。  
> pascal约定输出的函数名不能有修饰且全部为大写。  

C++编译时函数名修饰约定如下：
> stdcall规定以问号标识函数名的开始，在函数名后以`@@YG`标明参数表的开始，参数表第一项为该函数的返回值类型，后面依次为参数的数据类型，指针标识在其所指数据类型前，参数表以一个`@`结束，如果没有参数则不需要，最后以`Z`结束。  
> __cdecl约定和stdcall类似，这是参数表的标识变成了`@@YG`。  
> Fastcall约定和stdcall类似，这是参数表的标识变成了`@@YI`。  

* 函数的返回值

a. 使用return操作符返回值

一般情况下，函数的返回值会放在EAX寄存器中返回，如果返回值的长度大于超过EAX寄存器容量，其高就会放到EDX寄存器中。
在反编译程序中的呈现只是手动将结果赋值给EAX。

b. 通过参数按引用方式返回值

在汇编中通过引用方式返回值，其本质是通过对于变量的指针完成传递。

* 数据结构

a. 局部变量

局部变量分配空间时通常会使用栈和寄存器。我们一般使用`add`一个负值或`sub`一个正值为栈开辟空间，反之则消除该变量，也可以直接将寄存器或值压入栈。

b. 全局变量

全局变量通常位于数据区块(.data)的一个固定地址处，程序需要访问全局变量时，一般用一个固定的编码地址直接对内存进行访问。

c. 数组

数组是相同类型元素的集合，在内存按顺序连续排列。寻址一般使用基址+偏移量实现。这个偏移量还是按内存尺度来的，不是按元素个数尺度来的。

* 虚函数

所有对于虚函数的引用通常放在虚函数表(VTBL)中，这是一个专用数组。调用虚函数时，程序首先取出虚函数表指针(VPTR)，得到虚函数表的地址，并检索对应函数的地址，再根据地址调用该函数。
从C++编程角度来说，非虚函数和被重载的虚函数不会被写入虚函数表内，也就是说所谓被继承的，也只是该虚函数的使用权罢了(但是每个类是有个虚表的)。
进一步扩展地说在一个类中有一个指针叫做`__vptr`,对象调用对象的虚函数，实质上是调用类的虚函数。我们把经过虚表调用虚函数的过程称为动态绑定，表现出的现象称为运行时动态，传统的函数调用称为静态绑定。

* 控制语句



