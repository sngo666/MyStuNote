# 条款13 以对象管理资源

当我们使用一个工厂函数用于创建一个类的对象时，往往是以返回该对象的指针形式进行，同时也意味着对于该对象的使用要保证回收该对象的资源，因此在使用delete之前，一定要使得函数不会因为设计过早结束而导致未能执行。尽管谨慎编写代码会避免这一问题，然而对于后续的维护也是一个挑战，因此并不是一个明智的做法。

标准库提供了只能指针类型`auto_ptr`，其为类指针，也是所谓的类指针。

```cpp
std::auto_ptr<Investment> pInv(createInvestment());
```

该指针保证两点原则：
RAII: 获得资源后立刻放进管理对象，也就是资源取得时机便是初始化时机
管理对象运行析构函数确保资源被释放: 这一点的重要性在前几个条款已经说明相当清楚了。

auto_ptr被销毁时会自动删除其所指向的对象，所以多个auto_ptr指向同一个对象会很容易引发未定义行为，因此该指针有一个不寻常的特性，当通过copy构造函数或者copy运算符复制它们，就会变成null，而复制所得的指针将会取得资源的唯一所有权。

然而，auto_ptr也存在替代方案，即RCSP(引用计数型智慧指针)，TR1的`tr1::shared_ptr`就是个RCSP，它提供了类似垃圾回收机制，并没有类似于auto_ptr的独占所有权的机制，在提供多指针的复制上正常了许多，因为其会持续追踪共有多少对象指向某笔资源。

上述两种指针都在其析构函数内做delete而并非delete[]，意味着动态分配的array并不能适用于上述二者，而可悲的是，执意使用也能够通过编译。但是相应的也有bosst提供的`boost::scoped_array`和`boost::shared_array`