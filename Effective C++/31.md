# 条款31 将文件间的编译依存关系降至最低

有时候对于某个class实现的部分进行了轻微的修改，重新build可能意味着要重新将整个项目完整build一遍。

问题出在C++并没有把"将接口从实现中分离"这件事情做得很好。

当我们在类中使用需要依存于其他头文件中中定义的类时，这意味着在当前文件和其含入文件中形成了一种编译依存关系，如果这些头文件中有任何一个被改变，或者这些头文件所依赖的其他头文件有任何改变，那么每一个含入当前类的文件都需要被重新编译，反方向地，使用此类的所有文件也会被重新编译。
这样的连串编译依存关系会对许多项目造成难以形容的灾难。

在我们定义一个类的对象时，必须要保证类在声明阶段编译器能够知道其需要使用多大的空间。
一个合法的做法是将对象部分数据进行分割，装载进指针对象中。具体的处理做法例如将数据部分装入智能指针，指向其实现类。这种设计被称为`pimpl idiom`,即“pointer to implement”。
这种分离的思想关键在于"声明的依存性"替换"定义的依存性",其他的每一件事依赖于这样的策略：

* 如果使用object references或者object pointers可以完成任务，就不要使用objects
* 如果能够，尽量以class声明式替换class定义式。
* 为声明式和定义式提供不同的头文件。

使用pimpl idiom的class往往也被称为Handle class。

另一种制作Handle class的办法是，令该类成为一种特殊的abstract base class，这种类的目的是详细描述derived class的接口，因此其通常不带成员变量。Interface class筒仓调用一个特殊函数，此函数扮演“真正将被具现化”的那个derived class的构造函数角色，这样的函数被称为factory函数，或者virtual 构造函数。用于返回一个指针或者智能指针指向动态分配所得的对象，这样的对象支持interface class接口，这样的工厂函数又往往在interface class内部被声明为static。

Handle class和interface class解除了接口和实现之间的扣合关系，从而降低文件之间的编译依存性。这样做的代价是带来一定量的空间和运行时间成本。