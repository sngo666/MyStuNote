# 条款27 尽量少做转型动作

首先我们回顾转型语法，通常由三种不同的形式

```cpp
(T)expression  //C风格的转型动作

T(expression) //旧式转型风格，与上并无差异
```

C++在此基础上提供了四种不同的新式转型：

`const_cast` : 通常用来将对象常量性转除，也是唯一有此能力的C++-style转型操作符。
`dynamic_cast` : 主要用来执行安全向下转型，用来决定某对象是否归属继承体系中的某个类型，不仅仅是唯一无法用旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。
`reinterpret_cast` : 意图执行低级转型，实际动作可能取决于编译器，也就表示了其不可移植
`static_const` : 用来强迫隐式转换，例如将non-const转型为const对象，将int转型为double，也可以执行多种转换的反向转换，例如将void*转换为typed指针。但是无法将const转型为non-const，这个只有`const_cast`能做得到。

新式转型的优点在于，代码辨识度高，可阅读性强，转型动作目标愈窄化，编译器能更快诊断出错误类型。
有时候，在允许的情况下，当我们将一个内置类型转换成一个类时，看上去更像是使用了对象生成，往往也确实是这样。许多程序员认为，转型其实并没有做什么，只是告诉了计算机将某种类型视为了另一种类型，这是错误的观念，任何一个类型转换往往是真的零编译器编译出运行期间执行的代码。
例如执行`static_const<double>(x)`其中x为整型变量，在大部分计算机体系中，int的底层表述不同于double的底层表述。

使用一个基类指针指向派生类对象，在该对象身上可能其实际指针与基类指针值并不相同，这说明一个对象可能拥有一个以上的地址。这在其他语言不可能见到这样的情况。这种情况在多重继承中相当常见，然而对象的布局方式和其地址计算方式随编译器的不同而不同。

这样的需求可能会导致一些似是而非的代码，在一些应用框架中，我们要求在derived class的函数中执行basic class中的对应函数，一些人选择的方式是将`(*this)`执行`static_cast<basic_class>`,这样的处理方式看似符合预期，将*this转型为basic_class并执行其中的函数，但是这条语句调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个"\*this对象之basic_class成分"的暂时副本上的函数。这会导致其操作的对象是"\*this对象之basic_class成分"，而并非当前对象，对于basic_函数中的实现并没有落实到当前的对象，并会导致后面的操作一错再错。
解决之道很简单，直接调用basic_class的对应函数`basic_class::function()`，避免不必要的转型。

dynamic_cast在现版本执行速度相当慢，当我们在复合多层结构上实现此函数，可能会导致指数级的性能损耗，之所以需要dynamic_cast，通常是因为当镶在认为是derived class上执行derived class函数，而手上只有一个指向base的pointer或reference时，通常有两种解决办法。
第一：使用容器并在其中直接存储指向derived class对象的指针，比如智能指针。
这种做法可能无法在同一个容器中鵆指向所有可能派生类的指针。
第二：在basic class内提供virtual函数，将一些可能只有部分派生类会实现的代码留在basic class中，哪怕只是留白。

经常使用dynamic_cast的问题在于生产出的代码笨重，而且需要长期维护，优良的C++代码很少使用转型。