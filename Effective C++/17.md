# 条款17 以独立语句将newed对象置入智能指针

当我们定义一个函数，接受一个shared_ptr类对象作为参数，此时我们是否能够直接new一个相同类型的指针传递？
答案是否定的，tr1::shared_ptr的构造函数是一个explicit函数，无法进行隐式转换，那么调用形式可以直接改为`shared_ptr<T>(new testClass)`。

然而，这么做虽然合法，但是可能会造成资源泄漏。

现在假设该函数还需要接收第二个参数，我们向其传递另一个构造函数testClass2()，那么可能会发生什么问题?C++以什么样的顺序执行new testClass, shared_ptr和testClass2()并没有严格的固定，可以知道的是new一定在share_ptr的构造函数执行之前，倘若二者之间执行一个testClass2()并会造成异常中断程序的执行，带来的问题就会很明显了，new安排的空间将再也没有机会被delete掉。
问题在于智能指针的创建途中会有几率执行其他语句，那么解决问题的关键就在于整合这一个过程，再传递该智能指针，杜绝发生泄漏的风险。
