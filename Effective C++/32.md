# 条款32 确定你的public继承塑膜出is-a关系

一个派生类对象是其本身的同时，也一定是一个其基类对象，然而反之则不成立。这也是is-a(是一种)的思想，派生类的对象是一种基类的对象。

这种继承关系表面上看上去颇为简单，但是有时候可能会被直觉误导，比如：企鹅是一只鸟，但是倘若你想要定义鸟作为基类的特性：会飞，那么就与企鹅本身的特性相冲突。
对此我们必须承认，有数种鸟会飞，但并不是全部，因此不能作为基类设计的特性，也许可以单独定义一个派生类FlyingBird，这就是设计上的缺陷。

进一步地说，企鹅会飞这件事本身就应当作为一个错误被报告，倘若真的存在这样的设计，作为最原始的基类就不应该定义Fly()成员函数，这样作为派生类调用就会失败。

还有许多其他反直觉的例子，例如你可能会选择将正方形作为矩形的派生类来使用，但是如果矩形支持修改长款，这是否又会与作为正方向的特性相冲突呢？

is-a并非是唯一存在于classes之间的关系，此外还有has-a(有一个)以及is-implemented-in-terms-of(根据某物实现出)，将在后面讨论。
