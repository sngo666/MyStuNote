# 条款30 透彻了解inlining的里里外外

inline函数背后的整体观念是，将"对此函数的每一个调用"都以函数本体替换之，这么做带来的缺点是会增加目标代码的大小，过度热衷inlining会造成程序体积太大。
即使拥有虚内存，inline造成的代码膨胀可能会导致额外的换页行为，降低指令高速缓存装置的击中率。

换个角度说，如果inline函数的内容确实很小，针对函数本体所产生的代码可能比函数调用所产生的的代码更小，因而确实也可能会导致较小的目标码和较高的指令高速缓存装置击中率。

inline其实只是对于编译器的一个申请，而不是强制命令。大部分编译器拒绝将过于复杂的函数inline化。隐喻的申请方式是将函数定义在class定义式内部。

inline函数通常一定被置于头文件内，大部分inline在编译期间完成，小部分如基于.NET CLI可以在运行期间完成inlining。一个表面上看似inline 的函数是否真的inline，要取决于环境和编译器，如果无法inline化，编译器会给出一个警告信息。

实际上构造函数和析构函数往往是inlining的糟糕候选人，尽管有时候手动定义的构造函数没有做任何事情，但实际上C++对于对象被创建和销毁时会发生什么事情做出了各种各样的保证。
首先会在被继承的类构造函数内调用基类构造函数，并在构造其他成员时尝试捕获诸多异常等，真正的编译器会以更加精致复杂的方式来处理异常。相同的理由也适用于其基类构造函数。一个构造函数内部会针对其所有成员变量进行构造，因而可能出现的情况是，如果尝试将构造函数声明为inline，最后的构造函数代码量可能会指数性膨胀！

所以要慎重使用inline！
