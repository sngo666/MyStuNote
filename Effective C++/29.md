# 条款29 为“异常安全”而努力是值得的

为异常安全而努力是值得的，在一个函数中可能会出现各种各样的问题，当你完成异常的捕获和处理后，是否保证程序能够继续正常运行？当异常被抛出时，带有异常安全性的函数会：

1. 不泄露任何资源，上文中的new必须要有对应的delete。
2. 不允许数据损坏，对于数据的处理要将异常发生的情况考虑在内。

设计一个异常安全函数是严格而困难的，其必须遵循以下三点保证之一：

1. 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态中。然而程序的现实状态不可预料，具体会导致什么后果需要针对性调试才可知道。
2. 强烈保证：如果异常被抛出，程序状态不改变，调用这样的函数会有这样的认知：如果函数成功，就是完全成功；如果函数失败，程序会回到调用前的状态。这样的保证会比第一条看起来靠谱多了。
3. 不抛掷(nothrow)保证：承诺绝不抛出异常，这并不是说绝不抛出任何异常，而是如果抛出异常，将会是非常严重的错误，会有意想不到的函数被调用，如set_unexpected指定的函数。实际上这样的函数可能也完全没有提供任何的异常保证。

异常安全的代码必须提供上述三种保证之一，如果不这样做，就不具备异常安全性。

从异常安全角度来说，不抛掷可能是最棒的，可能的话开发者想要尽可能提供nothrow安全。但是对于大部分函数而言，抉择往往落在基本保证和强烈保证之间。

一般来说我们有几种基本的手段，如修改语句的次序，使其逻辑上应对各种可能的异常，使用智能指针包含对象便于资源管理。

这里介绍一个著名的策略叫做`copy and swap`：
当我们针对某一个对象想要进行数值修改时，可以先创造其副本并对其进行修改，这样能够保证在防止出现任何异常的时候能够不影响到对象的完整性。实现上通常是将所有隶属于该对象的数据，然后赋予原对象一个指针，指向那个副本。
不仅仅是在空间和时间上带来的影响，有时候强烈保证很难实现，其效率和复杂度成本有些时候往往过高。

强烈保证可能易于实现在只针对操作局部性状态，例如只操作参数对象，当函数还会造成其他连带作用时，几乎难以实现强烈保证。

当一个函数不具有异常安全性，我们便认为包含并使用该代码的系统不具有异常安全性，因此许多系统仍然不能够说是具有系统安全性的。