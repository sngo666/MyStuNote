# 条款4 确定对象在被使用之前已经先被初始化

无论对于初学者还是稍微掌握熟练的开发者而言，都能明白的是读取未被初始化的值会导致不可控的行为，甚至会污染进行读取的对象，导致程序中止，以及一系列难以忍受的调试过程。一般来说使用C part of C++初始化可能招致运行期成本，所以就不保证发生初始化。但是进入non-C parts of C++部分规则就会发生变化。例如array(来自于C part)不保证其内容被初始化，但是vector则相反。

* 请不要混淆赋值和初始化

在一个类的构造函数中，通过构造函数传递参数为成员变量初始化时常见的行为，但是在函数体内部为成员变量进行初始化(抽象上)本质上并不是初始化，类实例的成员变量初始化动作发生在进入构造函数体之前，也就是说，在成员变量被初始化的时候，尚未进行赋值操作。更好的写法是使用member initialization list替换赋值动作，更加安全且效率更高。
基于赋值版本的构造函数，从程序上来说首先调用default构造函数为成员变量进行default初始化，进入函数体后在赋值，这么做没有意义且影响效率，使用成员初始化列表避免了这一问题，可以直接对成员变量进行copy初始化，高效的多。

* 进一步讨论成员初始化列表

编译器会为用户自定义类型自动调用default构造函数(如果没有在成员初始化列表中的话)，但是最好的编程方式是在初值列中列出所有的成员变量，遗漏的成员变量可能会导致没有初值从而引发"未定义行为"。
C++有着非常严格的成员初始化顺序，这一点在"64位软件逆向技术"这一节的虚函数部分已经详细介绍过了，这里只提一点，base class的构造总是优先于derived class，而成员变量的初始化顺序总是按照声明顺序而并非构造函数成员初始化列表的排列顺序。尽管在需要重载各种各样的构造函数中，定义一个统一初始化成员的私有函数的开发效率高于反复使用成员初始化列表，但是使用成员初始化列表依然是更可取的行为。

* 关于non-local static对象

首先需要温习关于栈和堆的概念，除去静态区(全局数据区)和代码区，栈区通常用以存放函数的返回地址，形参，局部变量和返回类型；堆区则存放剩余的内存。栈和堆的区别如下：

1. 申请方式不同：栈是系统自动分配，而堆是程序员申请。
2. 系统响应不同：栈的剩余空间只要一直大于申请的空间，就会为程序提供内存，反之则报告栈溢出。而系统受到申请堆空间的请求后会遍历一个操作系统用于记录内存空闲空间的链表，找到适合存放的空间后进行响应的处理，所以当我们使用new来申请变量内存时，只有使用delete才能正确识别并且删除对应内存区域的所有变量。此外在分配内存空间时还会回收多余的剩余内存块。
3. 最后从大小上来说栈一块连续的内存空间，大小一般是1~2M，堆是不连续的空间，有大有小，上限取决于有效的虚拟内存。此外堆是向上生长的，由于堆的内存分配是C++函数库提供的，效率相对较低，且不支持静态分配。

_什么，你不知道什么是静态分配和动态分配？_
静态分配是指在申请对应空间后，由编译器和程序决定在什么时候释放内存，动态分配则反之，顾名思义，由程序员决定分配释放对应内存空间，在平时开发中也必须要注意使用delete语句对应相应的new。

当我们复习完上述操作系统基础知识，现在我们继续讨论non-local satic对象，这种对象包括global对象、定义于namespace内的对象以及在其他地方声明为static的对象。而在函数内声明的static对象被称为是local staric对象，程序结束时static对象会被自动销毁。
一个项目中必然会包含不同的多个编译单元，当我们在多个文件中使用外部实例对象中，不得不需要考虑初始化次序的事情，当我们调用一个外部对象时，如果执行步骤中其未被初始化，那么随之而来的是极其严重的问题。对此的解决方案是，将non-local static对象的定义放置于对应的函数内，并返回该对象的引用，因此保证使用过程中一定能出现被初始化的对象。
