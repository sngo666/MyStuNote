# 条款四 确定对象在被使用之前已经先被初始化

无论对于初学者还是稍微掌握熟练的开发者而言，都能明白的是读取未被初始化的值会导致不可控的行为，甚至会污染进行读取的对象，导致程序中止，以及一系列难以忍受的调试过程。一般来说使用C part of C++初始化可能招致运行期成本，所以就不保证发生初始化。但是进入non-C parts of C++部分规则就会发生变化。例如array(来自于C part)不保证其内容被初始化，但是vector则相反。

* 请不要混淆赋值和初始化

在一个类的构造函数中，通过构造函数传递参数为成员变量初始化时常见的行为，但是在函数体内部为成员变量进行初始化(抽象上)本质上并不是初始化，类实例的成员变量初始化动作发生在进入构造函数体之前，也就是说，在成员变量被初始化的时候，尚未进行赋值操作。更好的写法是使用member initialization list替换赋值动作，更加安全且效率更高。
基于赋值版本的构造函数，从程序上来说首先调用default构造函数为成员变量进行default初始化，进入函数体后在赋值，这么做没有意义且影响效率，使用成员初始化列表避免了这一问题，可以直接对成员变量进行copy初始化，高效的多。

* 进一步讨论成员初始化列表

编译器会为用户自定义类型自动调用default构造函数(如果没有在成员初始化列表中的话)，但是最好的编程方式是在初值列中列出所有的成员变量，遗漏的成员变量可能会导致没有初值从而引发"未定义行为"。
C++有着非常严格的成员初始化顺序，这一点在"64位软件逆向技术"这一节的虚函数部分已经详细介绍过了，这里只提一点，base class的构造总是优先于derived class，而成员变量的初始化顺序总是按照声明顺序而并非构造函数成员初始化列表的排列顺序。尽管在需要重载各种各样的构造函数中，定义一个统一初始化成员的私有函数的开发效率高于反复使用成员初始化列表，但是使用成员初始化列表依然是更可取的行为。

* 关于non-local static对象

