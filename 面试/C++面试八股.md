# C++面试八股

## 基本语法

### C++ 三大特性

继承： 让某种类型对象获得另一个类型对象的属性和方法。
封装： 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
多态： 重载实现编译时多态，虚函数实现运行时多态

### C++内存区域

1.代码区--------主要存储程序代码指令，define定义的常量。

2.数据区------主要存储全局变量(**已初始化全局变量和静态变量段.data**)，未初始化变量(**未初始化变量段.bss**)，常量字符串(**常量段.rodata**)。

3.栈区--------主要存储局部非静态变量，栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但内存大小有限。

4.堆区--------由`malloc`,`calloc`分配的内存区域，其生命周期由free决定。堆的内存大小是由程序员分配的，理论上可以占据系统中的所有内存。

### C++从代码到exe(或其他)

1. **预处理**: 处理相当于根据预处理指令组装新的C/C++程序，经过预处理，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件；这个文件的含义与原本的文件无异，只是内容上有所不同。也叫做将源文件转换为翻译单元的过程。
2. **编译**: 将预处理完的文件，进行语法语义分析，以及优化（Debug、Release）后，产生相应的汇编语言表示。
3. **汇编**：编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。这些目标文件包含可执行程序所需的机器指令、数据和符号信息。
4. **链接**：链接器将一个个编译好的.o文件、系统库的.o文件和库文件链接在一起生成一个完整的可执行程序。由汇编程序生成的目标文件并不能立即就被执行。链接过程允许将程序分割成多个独立的源代码文件和库文件，便于模块化开发、代码重用和程序维护。链接器还会处理动态库和静态库的依赖关系，确保程序在运行时能够正确地加载和使用这些库文件。
链接就是进行符号解析和重定位的过程。

### 谁调用了main()




### 程序如何中止

**正常终止**包括：

1. main()函数中通过`return`语句返回来终止进程；
2. 应用程序中调用`exit()`函数终止进程；
3. 应用程序中调用`_exit()`或`_Exit()`终止进程；

**异常终止**包括：

1. 应用程序中调用abort()函数终止进程；
2. 进程接收到一个信号，譬如SIGKILL信号。

### 中止处理函数

```cpp
#include <stdlib.h>
int atexit(void (*function)(void));
```

### static

用来控制变量的存储方式和作用范围。用于声明变量或函数的存储期为整个程序的执行期间，即使它们的作用域是局部的。static还可以用来定义类的静态成员。
静态成员变量在C++中是一个类级别的变量，它与类的所有对象实例共享同一个存储空间。这意味着，无论创建了多少个类的对象，静态成员变量都只有一个实例。

静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在。

存储
静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。

生命周期
静态对象是在程序启动时创建的，其生命周期贯穿整个程序的执行期间。

初始化顺序
静态对象的初始化顺序在不同编译单元中是不确定的，这可能导致依赖关系问题。

### atomic & mutex

mutex是C++11提供的新特性，互斥锁使用lock可以锁住互斥量，然后此时如果互斥量mtx被其它线程锁住那么将阻塞直到该互斥量被unlock。将互斥量上锁之后一定要使用unlock()，否则会造成资源被锁住，进而有可能产生死锁。

atomic原子操作指的是在多线程环境中不可分割、不会被线程调度机制中断的操作。这类操作在执行完毕之前，不会被其他线程观察到中间状态，从而保证了数据的完整性和一致性。

实际使用过程中，我们可能会因为忘记解锁的操作，就会造成死锁。所以在创建互斥量（mute）后，推荐使用`std::lock_guard()`与`std::unique_lock()`

### STL 六大组件

STL（Standard Template Library）的六大组件包括：

1. 容器（Container）：提供各种基本数据结构，如向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）等。
2. 迭代器（Iterator）：用于遍历容器中的元素，常使用在遍历容器，又可以用在连接容器和算法。
3. 算法（Algorithm）：提供了各种基本算法，如sort、search等。
4. 适配器（Adapter）：可改变容器(containers)、迭代器(iterators)或函数对象(function object)接口的一种组件。
5. 函数对象（Function Object）：也被成为仿函数，用类型包装函数，将函数类型化。
6. 分配器（Allocator）：内部调用malloc分配空间。

### new 和 malloc

**使用方式**：
malloc是一个函数，而new是C++一个操作符
malloc需要手动计算开辟的空间大小，new后面只需跟上空间的类型，如果有多个对象，加上[]给个数即可
malloc申请的空间不能初始化，而new可以
malloc返回void*，需要强制类型转换，而new返回对应类型的指针
malloc失败会返回空指针，需要手动检查；new失败抛出异常，要用catch捕获

**原理**
申请自定义类型对象时，malloc只会开辟空间，而new会先开辟空间，再去调用对象的构造函数完成初始化；delete会先调用对象的析构函数，再释放空间。

对于自定义类型
new完成了两件事: *开辟空间* *调用构造函数*
delete也同样：*调用析构函数* *释放空间*

### new重载

1. 重载new可以对于特定的自定义类型实现更好的资源管理，更好地追踪和管理内存分配，或者是日志追踪。
2. 为了实现最优性能，数据需要按照某种特定的边界对齐。如果没有对齐，可能会导致性能下降，甚至运行错误。通过重载new和delete，我们可以为特定的类实现定制的内存对齐方式。
3. 多个进程可能需要访问同一块内存区域。在这种情况下，可以通过重载new和delete操作符，实现在共享内存区域中分配和释放对象。

new重载会影响全局，所以尽量在特定的类内实现重载。

### 类的默认函数

构造函数
析构函数
拷贝构造函数
赋值运算符
const成员函数
取地址及const取地址操作符重载

### 多态是如何实现的

**实现**：
C++的多态是通过虚函数（virtual function）和指向基类的指针或引用来实现的。在基类中声明虚函数，派生类中重写该函数，通过基类指针或引用调用该函数，就可以实现运行时多态。
**原理**：
多态的实现原理主要涉及到两个概念：虚函数表（vtable）和虚函数指针（vptr）。每个含有虚函数的类，以及从这样的类派生的类，都有一个虚函数表。这个表中存储了虚函数的地址。类的对象中包含一个虚函数指针，指向这个虚函数表。
当通过基类的指针或引用调用虚函数时，实际上是通过这个虚函数指针找到虚函数表，然后在表中查找并调用相应的函数。这个过程是在运行时完成的，所以可以实现运行时多态。

### 如果派生类自身拥有虚函数，那么会生成一个新的虚函数表吗？

答案是不会的。如果派生类自身拥有虚函数的话，那么这个函数地址会被添加到复制基类的虚函数表最后一个位置中，如果是多继承的情况下，会被 添加到继承顺序最先继承的基类虚函数表中。

### 纯虚函数

定义一个基类时，基类中虚函数的具体实现由于必须依赖派生类的具体情况从而无法在基类中确切定义，此时可以把这个虚函数定义为纯虚函数。
`virtual void func()=0;`

1. 含有纯虚函数的基类是不能用来定义对象的。纯虚函数没有实现部分，不能产生对象，所以含有纯虚函数的类是抽象类
2. 定义纯虚函数时，不需要定义函数的实现部分
3. =0” 表明程序员将不定义该函数，函数声明是为派生类保留一个位置。“=0” 的本质是将指向函数体的指针定位NULL
4. 派生类必须重定义基类中的所有纯虚函数，少一个都不行，否则派生类中由于仍包含纯虚函数（从基类中继承而来），系统会仍将该派生类当成一个抽象类而不允许其实例。

### 如何在main函数之前执行一段代码

1. 在头文件中定义宏，将要在main()函数前执行的代码放在宏中，然后在main()函数前使用宏调用代码。
2. 全局变量的初始化和构造函数的调用发生在执行main函数之前。
3. 使用GCC编译器的构造函数特性，在程序中定义一个函数，将要在main()函数前执行的代码放在函数中，并使用GCC编译器的构造函数特性将该函数设置为在main()函数前执行。
4. 可以使用预处理指令`#pragma startup`和`#pragma exit`来在程序main()函数之前和之后执行代码。

```cpp
// c
#include <stdio.h>
 
void __attribute__((constructor)) before_main()
{
    printf("This code runs before main()\n");
}
```

### extern

对于分离式编译，使用extern在文件之间共享变量数据。
extern 用于指示变量或函数的定义在另一个源文件中，并在当前源文件中声明。说明该符号具有外部链接（external linkage）属性。

在编译期，extern 用于告诉编译器某个变量或函数的定义在其他源文件，编译器会为生成一个符号表项，并在当前源文件中建立一个对该符号的引用。这个引用时一个未定义的符号，编译器在后续的链接过程中会在其他源文件中查找这个符号的定义。
在链接期，链接器将多个目标文件合并成一个可执行文件，并且在当前源文件中声明的符号，会在其它源文件中找到对应的定义，并将它们链接起来。

### 无效引用

引用一个未初始化的指针。
引用一个局部变量并在其生命周期结束后使用。

## 容器

### vector的优化方法

C++引入的移动语义，让vector的拷贝得以优化，已有对象可以重复使用，而无需频繁拷贝构造。
vector中添加一个元素有三种途径：
直接在内存中通过拷贝构造函数构造对象
直接在内存中通过构造函数构造对象
直接在内存中通过移动构造函数构造对象

* 推荐使用`emplace_back`代替`push_back`省略一次原地构造。
* 使用reserve()方法预分配的空间，避免频繁的内存分配和拷贝操作。
* 使用shrink_to_fit()：使用`shrink_to_fit()`方法释放多余的空间，减少内存占用。
* 使用迭代器遍历元素：使用迭代器遍历元素，可以避免使用下标访问时的边界检查和拷贝操作，提高遍历效率。
* 使用移动语义

### map和unordered_map

**map**内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。

**unordered_map**内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。

区别：

**map的优点**
有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作，内部实现一个红黑书使得map的很多操作在**lgn**的时间复杂度下就可以实现，因此效率非常的高
缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间

搜索、移除和插入操作拥有**对数**复杂度。

**unordered_map的优点**
因为内部实现了哈希表，因此其查找速度非常的快

缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map

搜索、插入和元素移除拥有**平均常数**时间复杂度。

### stl空间分配器

在SGI版本的STL中，空间的配置释放都由< stl_alloc.h > 负责。它的设计思想如下：

1. 向system heap要求空间
2. 考虑多线程
3. 考虑内存不足的应变措施
4. 考虑内存碎片的问题

SGI设计了两层的配置器，也就是第一级配置器和第二级配置器。同时为了自由选择，STL又规定了`__USE_MALLOC`宏，如果它存在则直接调用第一级配置器，不然则直接调用第二级配置器。SGI未定义该宏，也就是说默认使用第二级配置器。
SGI版STL提供了一层更高级的封装，定义了一个`simple_alloc`类，无论是用哪一级都以模板参数alloc传给`simple_alloc`，这样对外体现都是只是`simple_alloc`.

### 虚函数依赖

1、  实例化对象的时候，需要虚函数能产生地址，存储在vftable中。
2、  对象必须存在。
所以构造函数不能作为虚函数，因为构造函数调用之后才能产生对象。

**静态绑定**：编译器根据函数调用的静态类型来决定调用哪个函数实现。静态类型是指在编译时已知的对象类型或指针类型。
**动态绑定**：动态绑定是指在运行时确定调用哪个函数，而不是在编译时确定。它允许通过基类指针或引用调用派生类中重写的虚函数。

### 虚函数与动静态绑定

不是调用虚函数就一定是动态绑定。

静态绑定：用对象本身调用虚函数是静态绑定。

动态绑定：1、必须指针或引用调用，2、调用的是虚函数。指针（可以是基类指针，也可以是派生类指针）或对象有可能指向自身类的对象，也有可能指向派生类对象，最终都是程序运行的时候才会确定调用哪个虚函数表里的虚函数，这就是动态绑定。

### 为什么析构函数定义为虚函数

子类在继承时构造函数是不能被继承的。但是，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。因此必定会调用父类的构造函数。

### 有什么要必须列表初始化的情况

1. 类成员为const类型
2. 类成员为引用类型
3. 类成员为没有默认构造函数的类类型
4. 如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数

### hash_map

hash_map是一个聚合类，它继承自_Hash类，包含一个vector，一个list和一个pair。
当中vector用于保存桶。
list用于进行冲突处理。
pair用于保存key->value结构。

**原理**：
使用一个下标范围比较大的数组来存储元素。
并同时提供一个哈希函数，使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素，这就是桶。

## 设计模式

### 如何实现单例模式

**局部静态变量方式**：函数的局部静态变量生命周期随着进程结束而结束。
**静态成员变量指针方式**：可以通过饿汉式的方式避免线程安全问题
**静态智能指针方式**：会在进程结束时被回收。智能指针被回收时会调用内置指针类型的析构函数，从而完成内存的回收。
**通用的单例模板类**：禁止外部构造，禁止外部析构，禁止外部拷贝构造，禁止外部赋值操作。

进一步得，使用加锁保证线程安全。
使用 C++11`std::call_once`实现的懒汉单例。

```cpp
static std::shared_ptr<Singleton> singleton = nullptr;
static std::once_flag singletonFlag;

std::shared_ptr<Singleton> Singleton::getSingleton() {
    std::call_once(singletonFlag, [&] {
        singleton = std::shared_ptr<Singleton>(new Singleton());
    });
    return singleton;
}
```

## 算法

### AVL和红黑树

二叉搜索树具有一些缺陷，比如在大多数节点的子节点都只有一个时，那搜索二叉树就会近似成一条线，搜索的时间复杂度就会从O(logN)退化成O(N)。针对这个问题，一些人对二叉搜索树进行了升级改造，也就是AVL树与红黑树。

#### AVL树

**优化**：当向一棵搜索二叉树中插入新节点时，要通过调整，使每个节点的左右子树高度差的绝对值不超过1，这样就能使二叉树接近满二叉树，进而提高搜素效率。
AVL树就是在二叉搜索树的基础上引入了平衡因子，因为AVL树也可以看作是二叉搜索树。**AVL树的插入**分为两步：

1. 按照二叉搜索树的方式去插入
2. 调整平衡因子并根据平衡因子的值旋转二叉树

按照二叉搜索树的方法插入后，需要调整平衡因子。
**平衡因子的计算方法**为右子树的高度减左子树的高度。插入节点后一定会影响该节点父节点的平衡因子，可能会影响祖先节点的平衡因子，如果该节点在父节点的左侧插入，则父节点的平衡因子减1，如果在右侧，父节点的平衡因子加1
· 如果新插入节点后父节点的平衡因子为0，则说明之前父节点之前某侧有一个节点，在另一侧新插入了一个节点。父节点外这棵树的高度并未改变，所以调整到此处即可。
· 如果新插入节点后父节点的平衡因子为1或-1，则说明父节点之前没有节点，此时在下方插入了一个节点，父节点的这棵树高度发生变化，影响了祖父的平衡因子，所以要继续向上调整。把父节点看成子节点，把祖父节点看成父节点，重复该过程即可。
· 如果新插入节点后父节点的平衡因子为2或-2，则说明父节点的平衡因子已经违反了AVL树的性质，需要通过旋转来调整。

**旋转定律**
新节点插在较高左子树的左侧时要使用右旋转。
新节点插在较高右子树的右侧时要使用左旋转。
新节点插在了较高右子树的左侧，使用左右双旋
新节点插在了较高右子树的左侧，使用右左双旋

AVL树的删除可以参考二叉搜素树的删除，删除完毕后更新平衡因子

#### 红黑树

红黑树也是一种二叉搜索树，在二叉搜索树的基础上，给每个节点分配了一个颜色：红色或黑色。根据颜色的不同，对红黑树的排列进行限制，保证红黑树任何一条由根到叶子节点的路径不会比其它路径长出两倍，进而达到近似平衡。

性质： ​​​​​​​ 一棵红黑树需要具备以下性质，换句话说只有满足了以下性质，才能保证最长路径不超过最短路径的两倍。
（1）每个节点不是红色就是黑色
（2）根节点一定是黑色的
（3）红色节点的两个叶子节点必须是黑色，换句话说，在一条路径下红色节点不可以相邻。
（4）任意节点到叶节点的几条路径中黑色节点的个数必须相等。
（5）空节点（空指针）看成是黑色的。

1、红黑树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)
2、一棵含有n个节点的红黑树的高度至多为2log(n+1).

### top K

针对top K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆，即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树或者Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K.

### 排序算法性质

![Alt](./res/sort.png#pic_center)

### 解决哈希冲突的方法

1. 链表式解决
2. 线性探测法
3. 平方探测法
4. 双哈希法

### 牛顿法求开方

切线是曲线的线性逼近。通过不断地做切线来逼近真实的根，直到误差小于精度。

首先给出牛顿迭代法的
迭代公式:

$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$

通过不断地做切线，直到$|x_n - x_*|$小于给定的精度，那么就是在误差范围内可以接受的了。
至于使用牛顿法求平方根，就是构建一个方程$f(x) = x^2 - n$并求解其等于0时的解法。
