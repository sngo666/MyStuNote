# 第六章 高级进程管理

## 进程调度

进程调度器是一个内核子系统，功能是把有限的处理器资源分配给系统的中的各个进程。换句话说进程调度器是一个内核组件，决定选择哪个进程来运行。决定过程中，调度器既要最大化处理器资源利用率，同时要支持从用户角度看多个进程并发、无缝运行的。

就绪进程(runnable process) : 非阻塞进程
阻塞继承(blocked process)  : 正在睡眠的进程，等待I/O，需要内核唤醒。

就绪进程数量高过处理器数量时，调度器的存在就非常有必要了，决定哪个进程可以运行、何时运行、运行多久是调度器的基本功能。

多任务操作系统相对应的是单任务操作系统，比如DOS。多任务操作系统可以分为两大类：协同式(cooperative)和抢占式(preemptive)，Linux实现了后一种形式的多任务，调度器决定某个进程何时停止运行，而由另外一个进程运行。这种中止正在运行的进程的行为称作抢占。进程在被抢占前所能够运行的时间称为该进程的时间片(timeslice)

相反地，在协同式多任务系统中，进程会一直运行直到它自己结束。这种自发结束的行为称为“让出(yielding)。理想情况下，会经常有进程让出，但操作系统绝不可强制要求其让出。因此，一个拙劣或破坏性的程序可能会运行很长时间，破坏了多任务机制，甚至导致整个系统崩溃。由于这个原因，现代操作系统几乎都采用抢占式多任务机制，Linux也不例外。

这些年，Linux进程调度器不断发生变化。当前进程调度器是在Linux内核版本2.6.23发布的，称为“完全公平调度器(Completely Fair Scheduler,CFS)”。这个名称源于该调度器采用了“公平入队(fair queuing)”策略，公平入队是个调度算法，对竞争进程采取公平访问资源的策略。CFS和其他UNIX进程调度器存在天壤之别，包括其前身O(1)进程调度器。

### 时间片

进程调度器分配给进程的时间片对于系统的全局行为和性能而言，是至关重要的。如果时间片太长，进程在执行前必须等待很长时间，降低了并发运行，用户会因感觉到明显的延迟而失望;相反，如果时间片太短，大量时间会花费在进程调度上而且如时间局部性这种性能提升也得不到保证。
因而，确定合适的时间片绝非易事。有些操作系统会给进程分配很长的时间片，期望最大化系统吞吐率和全局性能。其他系统则分配很短的时间片，期望得到最佳交互性能。而Linux的完全公平调度器，正如我们很快将看到的，则以一种怪异的方式解决“时间片大小”这一难题:不用时间片。

### IO约束型进程和处理器约束型进程

所谓约束型也就是其受前缀的什么所约束，受制于处理器性能还是其他关键条件。

直消耗完所有可用时间片的进程称为处理器约束型进程 (process-bound process)。这类进程需要获取大量 CPU 资源，会消耗掉调度器分配的全部CPU。最简单的例子就是如下所示的一个无限循环:

```c
while(1)
  ;
```

多数时间处于阻塞状态等待资源的进程称为“I/O约束型进程(I/O-bound process)”。IO约束型进程经常发起和等待文件或网络I/0，阻塞在键盘输入或等待用户移动鼠标。关于I/0约束型进程的应用的例子包括一些文件处理小工具它们除了请求内核执行I/O操作外几乎什么都不做，比如cp或者mv;
还包括很多GUI应用，花费了大量时间在等待用户输入。

其相应最佳调度器的行为不同。
处理器约束型应用  : 应用期望会获取尽可能长的时间片，从而最大化缓存命中率(通过时间局部性原理)，尽快完成任务。
I/O约束型应用    : 不需要很长的时间片，因为它们一般在发出I/O请求前只会运行很短的一段时间，然后阻塞在某些内核资源。对于IO约束型应用，如果调度器能够优先执行，则自然会受益。对于这类应用，在阻塞后越快被唤醒，就可以调度越多的I/O请求，应用就能更好地利用系统硬件资源。更进一步说，如果一个在等待用户输入的程序，被调度的速度越快越能给用户无缝运行的感觉.

大多数应用是混合约束型，有些进程是I/O约束型，有些进程是处理器约束型。音频视频的编码/解码就是一个很好的例子，无法把它简单地划分成任意一种。许多游戏也是混合约束型。因此，对于一个应用，并非总是能够判断出它属于哪一种约束型，而且一个进程在不同时间可能会有不同的行为。

### 抢占式调度

在传统UNIX进程调度中，内核会给所有就绪进程分配一个时间片。当进程消耗完其时间片，内核会挂起该进程，开始运行另一个进程。如果系统中没有就绪进程.内核就会给消耗完时间片的所有进程重新分配时间片,并再次运行这些进程。
因此进程在创建或终止时分别进入和退出就绪进程列表，阻塞在I/O，或者被唤醒，这个过程反复执行。通过这种方式，所有的进程最后都有机会运行，即使在系统中存在优先级高的进程——优先级低的进程只需要等待优先级高的进程消耗完时间片或阻塞，就有机会运行。这种行为方式制定了UNIX调度中没有明确指出但非常重要的规则:所有进程都必须运行。

## 完全公平调度器

完全公平调度器和传统的UNIX进程调度器有很大区别。在大多数UNIX系统中包括引人CFS之前的 Linux系统，在进程调度中存在两个基本的基于进程的因素优先级和时间片。

完全公平调度器引人了一种非常不同的算法，称为公平调度，它消除了时间片作为处理器访问分配单元，相反地，它给每个进程分配了处理器的时间比例。算法很简单:CFS在最初给N个进程分别分配1/N的处理器时间。然后，CFS通过优先级(nice value)权衡每个进程的比例，调整分配。默认的优先级是0，权值是1，则比例不变。优先级的值设置越小(优先级越高)，权值就越高，就增加分配给该进程的处理器的比例值:优先级的值设置越高(优先级越低)，权值越低，就减少分配给该进程的处理器的比例值。

* 目标延迟
通过这种方式，完全公平调度器就给每个进程分配了基于权值的处理器比例。要确定每个进程真正的执行时间，完全公平调度器需要把比例划分成一个固定的周期。该周期称为“目标延迟(target latency)”，它表示系统的调度延迟。
下面我们举个例子，可以帮助理解“目标延迟”这个概念：
假设“目标延迟”设置为20ms存在两个优先级相同的可运行进程。每个进程有相同的权值，并被分配相同的处理器比例，每个进程占用10ms。这样，完全公平调度器就会先执行一个进程，运行10ms，然后执行另一个进程，也运行10ms，这样不断重复。如果系统中有五个可运行的进程，完全公平调度器会每个运行4ms。

* 最小粒度
“最小粒度”是指任一进程所运行的时间长的基准值。所有进程，不管其分配到的处理器比例是多少，都至少会运行最小粒度的时间(除非被阻塞了)。这种机制可以保证切换代价不会因为目标延迟值很小，而占用过大比例的系统总时间。

如果在最小粒度内切换进程，就破坏了公平性。设置了目标延迟和最小粒度后,在可运行进程数合理的情况下，不需要应用最小粒度，只需要满足目标延迟，就可以保证公平性。

通过给进程分配处理器资源比例，而不是固定的时间片，完全公平调度可以实现公平性:每个进程都获得了处理器资源的“公平份额”。此外，完全公平调度器还可以支持可配置的调度延迟，因为目标延迟是用户可设置的。

在传统的UNIX调度器中，进程运行几个固定的时间片，称为“priori(先验值)”，但调度延迟(运行频率)是未知的。在完全公平调度器中，进程按“配额”运行，其延迟称为“priori”时间片是根据系统上可运行的进程数而动态变化的。完全公平调度器是完全不同的处理进程调度方案，解决了传统进程调度器对于交互进程和I/O约束型进程所面临的很多问题。

## 让出处理器

linux提供了一个系统调用用以支持进程主动让出进程，并通知调度器选择新的进程来运行：

```c
#include <sched.h>

int sched_yield(void);
```

该调用会挂起当前正在运行的进程，使调度器选择一个新的进程来运行。多数情况下，系统中并没有其他就绪进程，让出的进程就会立即恢复运行。
成功时返回0，失败时返回-1，并设置errno。理论上一般不会失败。

实际上，在linux系统这样的抢占式多任务系统中，很少有使用这样调用的机会，内核完全有能力作出最优化最有效率的调度决策，这是因为内核显然比一个独立的应用程序更懂得应该合适抢占哪个进程。
这种重新调度的机制往往服务于应用需要等待一些外部事件的需求，例如等待硬件组件或者其他进程的反应，最好的解决方案就是先暂时让出处理器。

UNIX程序员一般不需要编写这样的代码。UNIX程序通常是事件驱动的，往往会在消费者和生产者之间利用阻塞机制(比如管道)来代替sched_yield()。在这种情况下，消费者从管道中读取数据，在必要的时候阻塞等待数据。生产者则在有新数据时就向管道写数据。
通过这种机制，可以避免用户空间进程之间的协同工作，而是把这些工作交给了内核; 对于内核而言，又可以通过使进程睡眠，并在需要的时候以激活的方式来优化管理。一般来说，UNIX程序会致力于使用事件驱动机制，它需要可阻塞文件描述符。

sched_yield()的另一个合理使用场景是“表现友好(playing nicely)”:一个处理器密集的程序可以周期性调用sched_yield()，减少对系统的影响。这个策略的出发点很不错，但是存在两个缺点:
第一，内核可以比一个独立进程做出更好的全局调度决策，因此，使系统操作更平滑的工作应该由调度器来承担，而不是用户进程。第二，减轻处理器密集应用带来的负担，从而保证其他应用可以运行，这是用户的责任，而不是某个应用。用户可以通过shell命令“nice”为应用程序设置偏好，后面将会探讨它。

## 进程优先级