# 第五章 进程管理

程序(program)是指编译过的、可执行的二进制代码。
进程(process)包含二进制镜像，加载到内存中包括其他方面：虚拟内存实例，打开的资源、安全上下文以及线程。每个线程包含自己的虚拟存储器如栈等还有进程状态等寄存器。

一个进程只有一个虚拟内存实例，一个虚拟处理器，虚拟内存与进程相关联，所有的线程都会共享相同的内存地址空间。

## 进程ID

任意时刻中每个pid都是唯一的。
pid为0的进程代表空闲进程，即当没有其他进程在运行时，内核所运行的进程；在启动后，内核运行的第一个进程为init进程，pid为1.

除非用户显式告诉内核要运行哪个程序，一般Linux内核会尝试四个可执行文件：

/sbin/init
/etc/init
/bin/init
/bin/sh

### 分配进程ID

缺省情况下，内核将进程ID的最大值设置为32768，可以通过修改/proc/sys/kernel/pid_max把这个值设置为更大的值，但是可能会牺牲一些兼容性。

内核分配进程ID是以严格的线性方式执行的，依次向后累加直到到达最大值，之后再返回使用已经结束的进程号。

### 进程体系

创建新进程的进程称为父进程，那么被创建的也就成为子进程，每个子进程都有一个父进程。这种关系保存在ppid中。
每个子进程都继承了父进程的用户和组。
每个进程都是某个进程组(process group)的一部分，进程组表示的是该进程和其他进程之间的关系，和前面提到的用户和组的概念不同，不应混淆。子进程通常属于其父进程所在的那个进程组。此外，当通过shell建立管道时(如用户输人了命令ls | less)，所有和管道相关的命令都是同一个进程组。
进程组这个概念使得在管道上的进程之间发送信号或者获取信息变得很容易，同样，也适用于管道中的子进程。从用户角度来看，进程组和作业 (job) 是紧密关联的。

pid_t在头文件<sys/types.h>中定义，对应的实际类型与机器的体系相关，在linux中通常是int。

### 获取进程号和父进程号

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

这两个系统调用都不会返回错误。

## 运行新进程

在UNIX中，把程序载入内存并执行程序映像与创建新进程的操作是分离的。一次系统调用会把二进制程序加载到内存当中，替换原来空间内的内容然后开始执行，这一系列操作叫做exec系统调用。

另一个不同的系统进程用于创建一个新的进程，这个操作叫做fork。
综上所述，在一个新进程中执行一个程序分为两个步骤：创建一个进程，然后通过exec调用把新的二进制程序加载到该进程中。

### exec系统调用

```c
#include <unistd.h>

int execl(const char *path,
          const char *arg,
          ...);
```

该函数是可变参数的，将path所指向的路径的映像载入内存，arg是其第一个参数。后续还可以有多个参数，参数列表必须以NULL结尾。

```c
int ret;
ret = execl("/bin/vi","vi"，NULL);
if(ret ==-1)
  perror ("execl");

```

这段代码将执行程序的文件名vi作为第一个参数传递给第一个参数argv[0]，程序在解析后就知道该二进制映像的名字了。
通常情况下execl不会返回，调用成功后会跳转到新的程序入口点。

成功的 execl(调用不仅改变了地址空间和进程映像，还改变了进程的其他一些属性:所有挂起的信号都会丢失。

1. 捕捉到的所有信号都会还原为默认处理方式，因为信号处理函数已经不存在于地址空间中了。
2. 丢弃所有内存锁 (参看第9章)
3. 大多数线程的属性会还原成默认值。
4. 重置大多数进程相关的统计信息。
5. 清空和进程内存地址空间相关的所有数据，包括所有映射的文件
6. 清空所有只存在于用户空间的数据，包括C库的一些功能 (如atexit()的函数行为)。

通常打开的文件描述符也通过exec()继承下来，这意味着新进程知道原进程锁打开的文件描述符，它就可以访问所有这些文件，但这一般不是期望的行为，实际上一般调用exec之前都会关闭打开的文件，或者通过fcntl()让内核自动完成个关闭操作。

