# 第五章 进程管理

程序(program)是指编译过的、可执行的二进制代码。
进程(process)包含二进制镜像，加载到内存中包括其他方面：虚拟内存实例，打开的资源、安全上下文以及线程。每个线程包含自己的虚拟存储器如栈等还有进程状态等寄存器。

一个进程只有一个虚拟内存实例，一个虚拟处理器，虚拟内存与进程相关联，所有的线程都会共享相同的内存地址空间。

## 进程ID

任意时刻中每个pid都是唯一的。
pid为0的进程代表空闲进程，即当没有其他进程在运行时，内核所运行的进程；在启动后，内核运行的第一个进程为init进程，pid为1.

除非用户显式告诉内核要运行哪个程序，一般Linux内核会尝试四个可执行文件：

```bash
/sbin/init
/etc/init
/bin/init
/bin/sh
```

### 分配进程ID

缺省情况下，内核将进程ID的最大值设置为32768，可以通过修改/proc/sys/kernel/pid_max把这个值设置为更大的值，但是可能会牺牲一些兼容性。

内核分配进程ID是以严格的线性方式执行的，依次向后累加直到到达最大值，之后再返回使用已经结束的进程号。

### 进程体系

创建新进程的进程称为父进程，那么被创建的也就成为子进程，每个子进程都有一个父进程。这种关系保存在ppid中。
每个子进程都继承了父进程的用户和组。
每个进程都是某个进程组(process group)的一部分，进程组表示的是该进程和其他进程之间的关系，和前面提到的用户和组的概念不同，不应混淆。子进程通常属于其父进程所在的那个进程组。此外，当通过shell建立管道时(如用户输人了命令ls | less)，所有和管道相关的命令都是同一个进程组。
进程组这个概念使得在管道上的进程之间发送信号或者获取信息变得很容易，同样，也适用于管道中的子进程。从用户角度来看，进程组和作业 (job) 是紧密关联的。

pid_t在头文件<sys/types.h>中定义，对应的实际类型与机器的体系相关，在linux中通常是int。

### 获取进程号和父进程号

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

这两个系统调用都不会返回错误。

## 运行新进程

在UNIX中，把程序载入内存并执行程序映像与创建新进程的操作是分离的。一次系统调用会把二进制程序加载到内存当中，替换原来空间内的内容然后开始执行，这一系列操作叫做exec系统调用。

另一个不同的系统进程用于创建一个新的进程，这个操作叫做fork。
综上所述，在一个新进程中执行一个程序分为两个步骤：创建一个进程，然后通过exec调用把新的二进制程序加载到该进程中。

### exec系统调用

```c
#include <unistd.h>

int execl(const char *path,
          const char *arg,
          ...);
```

该函数是可变参数的，将path所指向的路径的映像载入内存，arg是其第一个参数。后续还可以有多个参数，参数列表必须以NULL结尾。

```c
int ret;
ret = execl("/bin/vi","vi"，NULL);
if(ret ==-1)
  perror ("execl");

```

这段代码将执行程序的文件名vi作为第一个参数传递给第一个参数argv[0]，程序在解析后就知道该二进制映像的名字了。
通常情况下execl不会返回，调用成功后会跳转到新的程序入口点。

成功的 execl(调用不仅改变了地址空间和进程映像，还改变了进程的其他一些属性:所有挂起的信号都会丢失。

1. 捕捉到的所有信号都会还原为默认处理方式，因为信号处理函数已经不存在于地址空间中了。
2. 丢弃所有内存锁 (参看第9章)
3. 大多数线程的属性会还原成默认值。
4. 重置大多数进程相关的统计信息。
5. 清空和进程内存地址空间相关的所有数据，包括所有映射的文件
6. 清空所有只存在于用户空间的数据，包括C库的一些功能 (如atexit()的函数行为)。

通常打开的文件描述符也通过exec()继承下来，这意味着新进程知道原进程锁打开的文件描述符，它就可以访问所有这些文件，但这一般不是期望的行为，实际上一般调用exec之前都会关闭打开的文件，或者通过fcntl()让内核自动完成个关闭操作。

```c
#include <unistd.h>

int execlp (const char *file, const char *arg，...):
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp (const char *file, char *const argv[]);
int execve (const char *filename, char *const argv[], char *const envp[]);

```

在这些附加的后缀中，l/v代表参数是以列表方式还是数组(向量)方式提供。p表示会在用户的绝对路径path下查找可执行文件，使用变量p的命令可以只指定文件名，该文件必须在用户路径下。最后，e表示会为新进程提供新的环境变量。奇怪的是，exec函数中没有一个同时可以搜索路径和使用新环境变量的函数。
虽然从技术角度看完全可以实现它。这可能是因为带p的exec函数要是用于shell的，因为 shell执行的进程通常会从shell本身继承环境变量。

当需要设置组ID和设置用户ID操作时，进程应该以二进制程序的组或用户权限运行，而不应该以调用方的组或用户身份运行---不要调用shell或那些会调用shell的操作。否则会产生安全漏洞，调用方可能会设置环境变量来操纵shell行为。对于这类攻击，最常见的形式是“路径注入(path injection)”，黑客设置PATH变量，导致进程通过execlp()执行他选中的二进制代码，使得黑客可以以和该进程相同的权限运行任意程序。

execve()是唯一系统调用，其原型和用户调用完全相同。

### fork系统调用

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

调用成功后，会创建一个新的进程，其几乎与调用fork的进程完全相同。这两个进程都会继续运行，调用者从fork()返回后，还是会照常运行。子进程返回pid为0，父进程返回pid为子进程的pid。

返回的pid为-1时说明出错。

### 写时复制

在早期的 UNIX 系统中，创建进程很简单，甚至有些过于简单。调用 fork()时，内核会复制所有的内部数据结构，复制进程的页表项，然后把父进程的地址空间按页(page-by-page)复制到子进程的地址空间中。糟糕的是，这种按页复制方式是十分耗时的。
现代UNIX系统采取了更优的实现方式。在现代UNIX 系统如 Linux 中，采用了写时复(copy-on-write，COW)的方式，而不是对父进程空间进行整体复制。

写时复制是一种基于惰性算法的优化策略，为了避免复制时的系统开销。
其前提假设很简单:如果有多个进程要读取它们自己那部分资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有一个进程修改自己的“副本”，每个进程就好像独占那个资源，从而避免了复制带来的开销。如果某个进程想要修改自己的那份资源“副本”，就会开始复制该资源，并把副本提供给这个进程。复制过程对进程而言是“透明”的。这个进程后面就可以反复修改其持有的副本，而其他进程还是共享原来那份没有修改过的资源。
这就是“写时复制”这个名称的由来:只看在写入时才执行复制。

在使用虚拟内存的场景下，写时复制是以页为基础执行的，在fork调用结束后，父进程和子进程共享父进程的原始页。
写时复制在内核中的实现非常简单。这些页被标记为只读，并对内核页相关的数据结构实现写时复制。如果有进程试图修改某个页，就会产生缺页中断。内核处理缺页中断的处理方式就是对该页执行一次透明复制。这时，会清空该页的写时复制属性，表示这个页不再被共享。现代的计算机结构体系中都在内存管理单元(MMU)提供了硬件级别的写时复制支持，所以实现是很容易的。
对于调用fork()创建进程的场景，写时复制有更大的优势。由于大量的fork创建之后都会紧接着执行exec,因此把整个父进程地址空间中的内容复制到子进程的地址空间往往只是纯属浪费: 如果子进程立刻执行一个新的二进制可执行文件的映像.它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。

vfork()是BSD开发者在BSD3.0引入的系统调用。

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

该调用功能上大体相同，vfork系统调用会通过挂起父进程，直到子进程中止或者执行新的二进制镜像，从而避免地址空间和页表拷贝。

系统调用vfork()是个历史遗留，Linux系统本不应该实现它，虽然需要注意的是即使提供了写时复制机制，vfork()也比fork()快，因为它没有进行页表项的复制。然而，写时复制的出现减弱了以vfork()替换 fork()的争论。实际上，在Linux内核2.2.0之前，vfork()只是简单的fork()封装。由于对vfork()的需求要小于fork()，所以vfork()的这种实现方式是可行的。
严格来讲，vfork()的所有实现都是有bug的: 考虑一下这种情况，如果exec调用失败了，父进程将被一直挂起，直到子进程采取措施或退出。程序应该更倾向于使用简单明了的fork()调用。

## 中止进程

POSIX和C89都定义了一个标准函数，可以中止当前进程：

```c
#include <stdlib.h>

void exit(int status);
void _Exit(int status);

```

该调用会执行一些基本的关闭步骤，然后通知内核中止这个进程，因此无法返回任何值。

status用于标识进程的退出状态，其他程序可以检查这个值。在linux中0通常标识成功，非零值表示失败。

在终止进程之前，C库会按顺序执行以下关闭进程的步骤。
1.调用任何由atexit()或on_exit()注册的函数，和在系统中注册时顺序相反
2.清空所有已打开的标准I/O 流.
3.删除由tmpfile()函数创建的所有临时文件。
这些步骤完成了在用户空间需要做的所有工作，最后exit()会调用系统调用_exit(),内核可以处理终止进程的剩余工作:

```c
#include <unistd.h>

void _exit(int status);
```

当进程退出时，内核会清理进程所创建的不再使用的所有资源，包括但不限于分配的内存，打开的文件，System V的信号量。完成后会摧毁进程。

应用可以直接调用_exit()，这样会跳过一些必要的清理工作。但是vfork()用户中止进程必须调用_exit()，而不是exit()

### 中止进程的其他方式

当main函数返回后，编译器会在最后关闭代码后插入隐式exit()调用，在main()函数返回时显式给出返回状态值，或者调用exit()是一个良好的编程习惯。

如果进程受到SIGTERM或者SIGKILL这样的信号，进程也会中止。

* 使用atexit注册指定的函数作为中止函数。

```c
#include <stdlib.h>

void atexit(void (*function)(void));
```

指定的函数会在程序正常结束时运行，必须是无参的，且没有返回值。
如果进程调用了exec()函数，会清空所注册的函数列表，同时如果进程是通过信号结束，也不会执行这些函数，

函数是存储在栈中的，也就是先进后出。注册的函数不能调用exit，否则会导致递归死循环，如果需要提前结束进程，应该调用_exit(),同时也会损失一些必要的清理工作。
POSIX标准要求atexit()至少支持注册ATEXIT_MAX个注册函数，而且这个值至少是32。具体的最大值可以通过sysconf()得到，参数是SC_ATEXIT_MAX。

* 关于类似于atexit的on_exit

SunOS 4自定义了一个和atexit等价的函数，工作方式类似于atexit，只是注册的函数形式不同。

```c
#include <stdlib.h>

void atexit(void (*function)(int, void *), void *arg);
```

`void my_function(int status, void *arg)`
参数status是传给exit()的值，或者说是从main返回的值，arg是传给on_exit的第二个参数，所有参数指向的内存必须是合法的。

新版本的solaris不再支持on_exit函数了。

* 关于类似于atexit的on_exit

当一个进程终止时，内核会向其父进程发送SIGCHILD信号。默认情况下，父进程会忽略此信号量，也不会采取任何操作。但是，进程也可以选择通过signal()或sigaction()系统调用来处理这个信号。

## 等待子进程中止

如果中止时，子进程完全消失了，父进程就无法获取子进程的任何信息，所以UNIX最初设计者作出了这样的决定，如果子进程在父进程之前结束，内核应该把该子进程设置成特殊的进程状态。

Linux提供了一些接口，可以获取已终止子进程的信息，其中最简单的一个是wait()：

```c
#include <sys/types.h>
#include <sys/wait.h>


pid_t wait(int *status);
```

