# 第四章 高级文件IO

## 分散聚集IO

分散聚集IO是一种可以在单次系统中对多个缓冲区输入输出的方法，可以把多个缓冲区的数据写到单个数据流，也可以把单个数据写进到多个缓冲区中，这种输入输出方法也称为向量IO，上一章的可以称为线性IO
>分散聚集IO优势在于：
编码模式更自然
效率更高
性能更好
支持原子性

* 使用readv()函数从文件描述符fd中读取count个段到参数iov所指定的缓冲区

```c
#include <sys/uio.h>

ssize_t readv(int fd, const struct iovec *iov, int count);
ssize_t writev(int fd, const struct iovec *iov, int count);

struct iovc{
    void *iov_base;     //指向段首的指针
    size_t iov_len;     //段长度
}
```

每个iovc结构体描述一个独立、物理不连续的缓冲区，我们称其为段segment。

readv函数在处理下个缓冲区之前，会填满当前缓冲区的iov_len个字节。writev则相反，填满当前缓冲区的iov_len个字节。
这两个函数都会顺序处理向量中的段，从iov下标0开始。

操作成功时，这两个函数都分别返回读写的字节数，等于count个iov_len的和，出错返回-1并设置errno。

实际上Linux内核中的所有IO都是向量IO，read()和write()都是作为向量IO实现的，且向量中只有一个段。

## event poll

epoll的实现要远复杂于poll和select，但是解决了基本的性能问题，并且增加了新的特性。

对于poll()和select(), 每次调用时都需要所有被听的文件描述符列表。内核必须遍历所有被监视的文件描述符。当这个文件描述符列表变得很大时包含几百个甚至几千个文件描述符时,每次调用都要遍历列表就变成规模上的瓶颈。
epoll把监听注册从实际监听中分离出来，从而解决了这个问题。一个系统调用会初始化epoll上下文，另一个从上下文中加人或删除监视的文件描述符，第三个执行真正的事件等待(event wait)

```c
#include <sys/epoll.h>
int epoll_create1(int flag);
int epoll_create(int szie);

```

调用成功后，epoll_create1会创建新的epoll实例，并返回和该实例关联的文件描述符，和真正的文件没有关系，只是为了后续调用epoll而创建。参数flags支持修改epoll的行为。
EPOLL_CLOEXEC表示进程被替换时关闭文件描述符。

出错时返回-1并设置errno。

epoll_create是epoll_create1老版本的实现，已经被废弃。不接受任何标志位。

* 使用epoll_ctl向指定的epoll上下文加入或者删除文件描述符

```c
#include <sys/epoll.h>
int epoll_ctl(int epfd,
              int op,
              int fd,
              struct epoll_event *event
              );
struct epoll_event{
  __u32 events;
  union{
    void *ptr,
    int fd,
    __u32 u32,
    __u64 u64
  }data;

}         

```

执行成功时，控制和文件描述符epfd相关联的epoll实例，op指定了对fd所指向的文件的执行的操作，event规定了进一步的行为，如删除修改增加等。


