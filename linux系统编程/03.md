# 第三章 缓冲IO

块是文件系统中的最小存储单元的抽象，在内核中，所有的文件系统都是基于块执行的，对于非整数倍块大小的操作效率都非常低。

## 用户缓冲IO

用户缓冲IO是在用户空间而不是内核中完成的，以用户空间的程序dd的使用为例:

```bash
dd bs=1 count=2097152 if=/dev/zero of=pirate
```

设置了参数bs=1，dd命令会从设备/dev/zero拷贝2MB的数据到文件pirate中每次操作拷贝一个字节，这样就要执行2097152次。
另一种就是定义大的块

```bash
dd bs=1024 count=2048 if=/dev/zero of=pirate
```

读写操作次数是前一次的1/1024，从时间上节省了数百倍的时间。

为了利用性能提升的优势，需要预先了解物理块的大小，块大小一般是1024，1024的整数倍或者是其约数，对于/dev/zero最优的块大小是4096.
应用的各类读写请求不是直接从文件中读取，而是从缓冲区中读取。

## 标准IO

C提供的标准IO库stdio已经相当不陌生，首先讨论文件指针。

### 文件指针

标准IO程序集并不直接操纵文件描述符，通过唯一标识符，即文件指针来操作，在C标准库中，文件指针和文件描述符一一对应。在标准IO中，打开的文件被称为"流"，用于读或者写，甚至同时兼备。

```c
#include <stdio.h>

FILE *fopen(const char *path, const char *mode);
```

根据mode参数，按照指定模式打开path所指向的文件，并关联一个新的流。
使用w或者w+的时候如果文件存在，文件就会被清空。
成功返回一个合法的FILE指针，失败返回NULL并设置errno。

* 使用fdopen通过文件描述符打开文件：

```c
#include <stdio.h>

FILE *fdopen(int fds, const char *mode);

```

使用fdopen时不会清空文件，一旦文件描述符被转换成流，则在该文件描述符上不应该直接执行IO操作，虽然这么做是合法的。但是需要注意的是文件描述符并没有被复制，而是关联了一个新的流，关闭流也就是关闭相应的文件描述符。

* 使用fclose关闭流，成功时返回0，失败时返回EOF并设置errno：

```c
#include <stdio.h>

void fclose(FILE *stream);

//关闭所有的流，关闭前所有的流都会写出，固定返回0
int fcloseall(void);          

```

## 读取数据

通常情况下，理想的IO模式是每次读取一个字符，通过使用fgetc()

```c
#include <stdio.h>

int fgetc(FILE *stream);

```

从stream中读取一个字符，并将其强制转成unsigned int返回，文件结束或者错误都会返回EOF。

* 使用ungetc()把字符放回流中，每次调用会把int c强制转型成unsigned char。
失败时返回EOF。

```c
#include <stdio.h>

int unfgetc(int c, FILE *stream);

```

读取的时候，最后返回的字符会最先被读出。
如果在调用unfgetc()之后，但在发起下一次读请求之前，如果发起了一次seek函数调用，会导致所有放回stream中的字符被丢弃，单个进程的多线程场景中会发生这一情况，因为所有的线程共享一个缓冲区。

* 使用fgets()从stream中读取size-1个字节的数据。读完后会向缓冲区中写入一个`'\0'`，读到EOF或换行会结束，换行符`'\n'`也会被写入缓冲区

```c
#include <stdio.h>

int fgets(char *str, int size, FILE *stream);

```

可移植程序使用`<limits.h>`中的LINE_MAX来保证安全，linux中该值一般比较大。

fgets的局限在于规定死遇到换行会结束，无法使用开发者自定的分隔符，所以一般结合fgetc自定义字符串读取。
虽然这么做会带来额外的函数调用代价，但是远远优于size=1时的字节搬运。

* 读二进制文件

使用fread读取二进制文件：

```c
#include <stdio.h>

size_t fread(void *buf, size_t size, size_t nr, FILE *stream);
```

从stream中读取nr项数据，每项size个字节，并保存到buf所指向的缓冲区。返回读到的数据项的个数，如果读取失败，fread会返回一个比nr小的数。不幸的是必须使用ferror()或feof()函数才能确定是失败还是文件结束。

* 关于对齐

> 处理器并不是以字节大小的块对内存进行读写相反地，处理器以特定的粒度(如2、4、8字节或 16字节)来访问内存。因为每个进程的地址空间都是从地址0开始的，进程必须从特定粒度的整数倍开始读取
因此，C变量的存储和访问都要求地址对齐。一般而言，变量是自动对齐的，这指的是和C数据类型大小相关的对齐。例如，一个32位整数占用4个字节，它每4个字节会对齐。换句话说，在大多数体系结构中，int需要存储在能被4整除的内存地址中。
访问不对齐的数据会带来不同程度的性能问题，这取决于不同的体系结构。有些处理器能够访问不对齐的数据，但是会有很大性能损失。有些处理器根本就无法访问不对齐的数据，尝试这么做会导致硬件异常。更糟的是，有些处理器为了强制地址对齐，会丢弃了低位的数据，从而导致不可预料的行为。
通常，编译器会自动对齐所有的数据，而且对程序员而言，对齐是“透明”的。处理结构体，手动执行内存管理，把二进制数据保存到磁盘中，以及网络通信都会涉及对齐问题。

## 向流中写入数据

* 和fgetc相对应的是fputc():

```c
#include <stdio.h>

int fputc(int c, FILE *stream);

```

进行一个强制转换成unsigned char，成功返回c否则返回EOF并设置errno。

* 使用fputs写入字符串

```c
#include <stdio.h>

int fgets(const char *str, FILE *stream);

```

成功时返回一个非负整数，失败时返回EOF。

* 使用fwrite写入二进制数据

```c
#include <stdio.h>

size_t fwrite(void *buf, size_t size, size_t nr, FILE *stream);
```

将buf指向的nr和数据项写入到stream中，每个数据项长size，文件指针向前移动写入的所有字节的长度。成功返回数据项个数，出错时返回值小于nr。

由于变量长度，对齐等因素不同，一个应用程序写入的数据可能另一个无法读取，不同的应用程序甚至是在不同机器上的同一个程序可能都无法正确读取，只能在ABI相同的特定机器上才能保持一致。

## 定位流