# 第二章 文件IO

在对文件进行读写之前，首先需要打开文件，内核会为每个进程维护一个打开文件的列表，这个列表称为`file table`，其由一些非负整数进行索引，这些非负整数成为文件描述符`file descryptors`，列表的每一项是一个打开文件的信息，包括指向该文件索引节点内存拷贝的指针以及关联的元数据，比如文件位置指针和访问模式。
打开文件会返回文件描述符，后续操作都是将文件描述符作为参数。

一般来说每个进程至少包括三个文件描述符，0，1，2表示标准输入，标准输出和标准错误。

## 打开文件

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *name, int flags)
int open(const char *name, int flags, mode_t mode)
```

调用成功会返回文件描述符，指向文件name所指向的路径，文件的位置是文件的起始位置0。

`flags`支持三种模式: O_RDONLY, O_WORNLY, O_RDWR，分别表示只读，只写或者读写模式打开文件。

通过和其他参数进行按位与运算，进一步修改和定义打开文件的行为。

* 关于新建文件的所有者
确定新建文件的所有者很简单，文件所有者的uid就是创建该文件的进程的有效uid。
默认情况下使用创建进程的有效gid就是新建文件的用户组(System V行为)，BSD规定了自己的规则，新建文件的用户组被定义成文件父目录的gid，可以通过系统调用fchown()手动设置所属组。

## 新建文件的权限

使用O_CREAT时如果文件已经存在，则该选项无效，如果同时指定了O_EXCL，在文件存在时open()的执行会失败。
在使用参数O_CREAT参数时如果没有设置参数mode，结果是未定义的。mode提供了新建文件的权限，对于新建的文件打开时不会检查权限，因此可以执行与权限相反的操作，比较常见的权限八进制数0644(文件的所有者可以读写，其他人只能读)，为了弥补mode 的不可移植性，同样可以通过一些选项与mode进行按位与。

最终写入磁盘的权限位是由mode参数和用户的文件创建掩码(umask)执行按位与操作而得到，umask是进程级属性，通常由login shell设置，通过调用umask()修改。

## creat函数

O_WRONLY | O_CREAT | O_TRUNC 的组合经常被使用，因此专门有个系统提供这个功能

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int creat(const char *name, mode_t mode);
```

系统调用open()和creat()在成功时都会返回文件描述符，出错时返回-1，并把errno设置成相应的错误值。

## 通过read打开文件

```cpp
#include <unisd.h>

ssize_t read(int fd, void *buf, size_t len);
```

每次调用read()，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中，执行成功返回写入的字节数，出错时返回-1并设置errno。
同时fd的文件位置指针会向前移动相应的长度，除非fd所指向的对象不支持seek对象，比如字符设备文件。

读取的字节数即unsigned long类型的大小，在32位上是四字节，64位上是8字节。

这样的实现可能存在两种问题：可能还没读取到len字节，调用就返回了，会产生某些可操作的错误。
很多情况下都会返回都会出现返回值小于len的情况，例如读取被信号打断，管道被破坏，可用的字节数小于len。此外，当read到达文件末尾(EOF)时read返回0
如果调用是要读取len个字节，但是没有字节可读时，调用就会被阻塞(sleep)直到有数据可读。没有字节可读和到达文件结尾是两个不同的概念，进入阻塞模式后，表示正在等待更多的数据，在非阻塞模式下，不会发生这样的结果。

如何读入所有的字节呢，需要有一个循环:

```cpp
ssize_t ret;

while(len != 0 && (ret = read(fd, buf, len)) != 0){
  if (ret == -1){
    if (errno == EINTR)
      continue;
    perror("read");
    break;
  }

  len -= ret;
  buf += ret;
}
```

EINTR代表了read调用被中断，当进入中断时就会重启read，其他的情况则会中断读取。

有时候开发人员不希望read在调用时在没有数据可读时阻塞，并希望立即返回表示无数据可读。因此需要检查errno是否为EAGAIN，如果文件描述符以非阻塞模式打开(open()中指定O_NONBLOCK)会在没有数据可读时立即返回。

* read()调用的大小限制
类型size_t,ssize_t是由POSIX确定的，在32位上对应的c类型分别为unsigned int和int，最大值则是SIZE_MAX和SSIZE_MAX，len值超越最大值会导致未定义行为，SSIZE_MAX在32位上是LONG_MAX，所以需要对参数添加检查的门槛。

## 调用write()写

```cpp
#include <unisd.h>

ssize_t write(int fd, void *buf, size_t count);
```

同理，write会从文件描述符fd指向的位置开始写入最大count的字节，不支持seek的文件总是从起始位置开始写。最后返回写入的字节数并会在出错时返回-1，同时设置errno。
当返回0个字节时，并没有什么特别的含义，即单纯写入0个字节。
如果count大于SSIZE_MAX，那么调用wirte()的结果是未定义的。count为0，则立即返回0.

但是，其实现也需要同样的严谨，例如检查部分写(patial wirte)

* 部分写
对于普通文件，不太可能会出现部分写的情况，但是对于其他类型的文件，比如socket需要循环来保证写入所有的字节，使用循环的另一个好处是第二次调用write可能会返回错误值，以说明第一次调用为什么发生了部分写。

```cpp
ssize_t ret, nr;

while(len != 0 && (ret = write(fd, buf, len)) != 0){
  if (ret = -1){
    if (errno == EINTR)
      continue;
    perror("write");
    break;
  }
  len -= ret;
  buf += ret;
}

```

### Append(追加)模式

当使用Append模式打开文件描述符，写操作是从文件的结尾开始。其特点在于保证文件指针总是指向了文件末尾，可以理解成在每次写请求之前的文件位置更新操作是一个原子操作。更新文件位置，指向新的文件末尾，这和下一次的wirte没有关系，因为是自动完成的，但是如果下一个调用是read，会有一些影响。

### 非阻塞写

以非阻塞模式，即调用O_NONBLOCK模式打开文件，发起写操作时，调用write()返回-1并设置errno为EAGAIN，然后稍后可以再次发起请求。

### write()行为

当write调用返回时，内核已经把数据从提供的缓冲区拷贝到内核缓冲区中，但是数据不一定已经写到了目的地。
当用户空间发起write系统调用时Linux内核会做检查，然后直接把数据拷贝到缓冲区中，然后在后台中，内核会收集所有的这样的脏缓冲区，进行排序优化，并将缓冲区写到磁盘上，通过这种方式，write可以频繁调用并且返回。

假如要对一份刚写到缓冲区但还没写到磁盘的数据执行读操作，请求响应会直接读取缓冲区的数据，而不是读取磁盘上的陈旧数据，这种方式进一步提高了效率。
延迟写的另一个问题在于无法强制"顺序写"，虽然应用可能会考虑对于请求写进行排序，但是内核一般是出于性能考虑按照合适的方式对于写请求进行排序，按特定的顺序写入磁盘。一般来说只有系统崩溃时延迟写才会出现问题，

最后一个问题是对于某些IO错误的提示信息不准确，在回写时产生的任何IO错误，都不能报告给发起写请求的进程，内核的脏数据区和进程无关，多个进程可能会弄脏同一片数据区。而且一般来说进程可能早就已经返回并退出了，对于这些问题，为了保证数据按时写入内核设置了最大缓存时效，这个时间很短，小于0.01秒，在超出给定时效前将所有脏数据的缓存写入磁盘。

## 同步IO

有时候可以牺牲一些性能手动控制将缓冲写入磁盘，通过调用fsync()和fdatasync()，定义如下:

```cpp
#include <unistd.h>

int fsync(int fd);

```

该函数可以确保和文件描述符fd所指向的文件相关的所有脏数据都会回写到磁盘上，因此文件描述符fd必须以写方式打开，该调用会回写数据和元数据，后者指一些创建的时间戳以及索引节点中的其他属性。该调用在硬件驱动器确认数据和元数据已经写到磁盘上之前不会返回。
但是对于一些自身包含写缓存的磁盘。并没有办法知道是否真正写到磁盘上，好在正常情况下，磁盘自身的缓冲区写到磁盘上的时间也很短。

```cpp
#include <unistd.h>

int fdatasync(int fd);

```

fdatasync()和fsync类似，区别在于前者只会写入数据以及以后要访问文件所需要的元数据，不保证非基础性的元数据也写到了磁盘上，因此节省了时间提高了效率。因为索引节点和文件数据在磁盘上可能并不是相邻的，因而fsync可能会带来相当的seek代价。

这两个函数都不保证任何已经更新的包含该文件的目录项会同步到磁盘上。这意味着如果文件链接最近刚更新，文件数据可能会成功写入磁盘，但是却没有更新到相关的目录中，导致文件不可用。为了保证对目录项的更新也都同步到磁盘上，必须对文件目录也调用fsync()进行同步。

二者成功时返回0，失败后会返回-1并更新errno。

对于某些linux系统，直接调用fsync可能会失败，因为其文件系统没有实现该函数，即使实现了fdatasync()，某些固执的应用可能会在fysnc返回EINVAL(给定文件描述符所指向的对象不支持同步)时尝试使用fdatasync。

### sync()

用于对磁盘上所有缓冲区进行同步，虽然效率不高，但是广泛使用。

```cpp
#include <unistd.h>

void fdatasync(void);
```

POSIX标准并不要求sync()一直等待所有的缓冲区都写到磁盘后才返回，只需要调用它来启动把所有的缓冲区都写到磁盘上即可，一般建议多次调用。但是对于linux而言，一定是等到所有缓冲区都写入完成了才返回，因此调用一次就够了。
当系统繁忙时，sync可能需要相当久的时间才能返回。

### O_SYNC标志位

在open中使用O_SYNC标志位表示该文件的所有IO都需要同步。将调用返回和写入磁盘强制绑定，相当于每次执行完write后隐式执行fsync()，linux内核在具体实现上对此做了优化。其相对来说也会带来更多的时间开销，因为大量使用会带来频繁的同步。

### O_DSYNC和O_RSYNC

O_DSYNC指定每次写操作后，只同步普通数据，不同步元数据。可以理解为每次写请求后，隐式调用fdatasync()，相对于O_SYNC更好的提升了性能。

O_RSYNC标志位指定读请求和写请求之间的同步，该标志位必须和O_SYNC或者O_DSYNC一起使用，O_RSYNC保证读操作带来的任何影响也是同步的，即读操作带来的任何元数据更新必须在调用返回前写入磁盘。

## 直接IO

在open()中指定O_DIRECT会使内核对于io管理的影响最小化，如果提供O_DIRECT标志位，IO操作会忽略页缓存机制，直接对于用户空间缓冲区和设备进行初始化，所有的IO操作哦都是同步的，操作在完成之前不会返回。
使用直接IO时，请求长度，缓冲区对齐以及文件偏移都必须是底层设备扇区大小的整数倍(通常是512字节)。

## 关闭文件

通过close()取消文件描述符到对应文件的映射。

```cpp
#include <unistd.h>

int close(int fd);
```

调用成功时返回0，出错时返回-1并相应设置errno.

> 当关闭指向某个文件的最后一个文件描述符时,内核中表示该文件的数据结构就释放了。如果释放了数据结构会清除和文件相关的索引节点的内存拷贝。如果已经没有内存和索引节点关联，该索引节点也会被从内存中清除(出于性能考虑，也可能会保存在内核中，但也可能不需要)。如果文件已经从磁盘上解除链接，但是解除之前还一直打开，在文件被关闭并且其索引节点从内存中删除之后,该文件才会真正从物理磁盘上删除。因此.调用 close()可能会使得一个已解除链接的文件最终从磁盘上删除。

## 用lseek查找

Iseek只更新文件位置，能够将文件描述符的位置指针设置成指定值。

```cpp
#include <sys/tyes.h>
#include <unistd.h>

off_t lseek(int fd, off_t pos, int origin);

```

其调用的行为依赖于origin参数:
SEEK_CUR 将文件位置设置成当前值加上pos个偏移值，pos可以是正负整数，如果为0，直接返回当前。
SEEK_END 将文件位置设置成文件长度加上pos个偏移值，pos可以是正负整数，如果为0，直接返回文件结尾。
SEEK_SET 将文件位置设置成pos值，pos可以是正负整数，如果为0，直接返回文件开始。

尽管lseek支持在文件末尾后查找，但是查找到文件末尾后似乎没有什么意义，但是如果在该位置如果有一个写请求，在文件的新旧长度位置之间就会用0来填充，在unix系统中，这种零填充不占用物理磁盘空间，意味着文件系统上所有文件大小加起来可能会大于磁盘的空间，包含这种填充的文件叫做稀疏文件，对空洞部分的读请求会返回相应的二进制0.

最大文件位置受限于off_t的大小，可能是long或者long long(内核实现)。

## 定位读写

使用pread()和pwrite()替代lseek：

```cpp
#define _XOPEN_SOURCE 500

#include <unistd.h>
ssize_t pread(int fd, void *buf, siez_t count, off_t pos);
ssize_t pwrite(int fd,const void *buf, siez_t count, off_t pos);

```

它们最大的特点就是忽略了当前文件位置，且在调用完成后不会更新文件位置指针，换句话说，read和open的交替调用可能会破坏定位读写的结果。
最重要的是，它们避免了在使用lseek时出现的竞争。因为线程共享文件表，可能会出现在lseek和读写之间插入其他线程对该文件的操作。

## 文件截短

```cpp
#include <sys/tyes.h>
#include <unistd.h>

int ftruncate(int fd, off_t len);
int truncate(const char* path, off_t len);

```

这两个调用都将给定文件截短为参数len指定的长度，成功时返回0，出错时都返回-1，区别在于载入的参数不同。
被丢弃的部分即介于len和老的文件长度之间的部分不可再读。
不会修改文件当前位置。

## IO多路复用

如果不使用线程，而是独立处理每个文件描述符，单个进程可能无法同时在多个文件描述符上阻塞。
使用非阻塞IO是一个解决方案，应用可以发送IO请求，并且返回特定的错误，而不是阻塞。但是这样的方案效率不高，因为要连续发送请求以跟进，同时进程睡眠可以释放资源，使得CPU能同时处理其他问题。

* IO多路复用在设计上遵循以下原则：
当任何一个文件描述符IO就绪时进行通知。
在有可用的文件描述符之前处于睡眠状态。
唤醒时检索可用的文件描述符
处理完所有的IO就绪的文件描述符后，没有阻塞
返回第一步，从头开始，

select提供了一种实现同步IO多路复用的机制：

```cpp
#include <sys/select.h>
#include <sys/time.h>

int select(int n,             // 集合中所有文件描述符的最大值加1
          fd_set *readfds,
          fd_set *writefds,
          fd_set *exceptfds,
          struct timeval *timeout);

struct timeval{
  long tv_sec;    //秒
  long tv_usec;   //毫秒
}

FD_CLR(int fd, fd_set *set);    //向指定集中删除一个文件描述符
FD_ISSET(int fd, fd_set *set);  //向指定集中检查一个文件描述符是否存在，在则返回非0，否则返回0
FD_SET(int fd, fd_set *set);    //向指定集中添加一个文件描述符
FD_ZERO(fd_set *set);           //用以在指定集合中删除所有的文件描述符，每次调用select之前都应该调用该宏
```

调用成功时返回三个集合中IO就绪的文件描述符总数，如果给出了超时设置，返回值可能是0，返回-1代表出错，并设置相应errno

在超出指定的时间限制之前，select就会发生阻塞。
对于三类fd_set，分别代表对于对应集中的文件描述符能够无阻塞完成读，写，以及没有任何异常的检测或出现带外(out-of-band)数据。集的值也可以是NULL。

成功返回时，每个集合都含相应类修改成只包型的IO就绪的文件描述符。
如果该参数(timeout)不是NULL，在时间归零后就会返回。

文件描述符集是静态建立的，所以存在上限值，由FD_SETSIZE设定，在linux中该值为1024.

### pselect()

```cpp
#include <sys/select.h>
#include <sys/time.h>

int select(int n,             // 集合中所有文件描述符的最大值加1
          fd_set *readfds,
          fd_set *writefds,
          fd_set *exceptfds,
          const struct timespec *timeout,
          const sigset_t *sigmask);

struct timeval{
  long tv_sec;    //秒
  long tv_nsec;   //毫秒
}

```

pselect使用了timespec结构体，使用秒和纳秒，提高了更高的精确度
pselect不会修改timeout参数.
pselect使用的sigmask参数，是为了解决文件描述符和信号之间的等待而出现竞争条件，如果信号处理程序设置了全局标志位，进程每次调用之前都会检查都会检查该标志位，

## poll()

poll调用的是SystemV的多路复用解决方案，解决了一些select的不足，不过select还是被频繁使用，出于可移植性的考虑。

```cpp
#include <poll.h>

//timeout单位毫秒，为负值表示永远等待
int poll(struct pollfd *fds, nfds_t nfds, int timeout)  

struct pollfd{
  int fd;
  short events;     //要监视的文件描述符的事件的位掩码
  short revents;    //该文件描述符的结果事件的位掩码
};
```

每个pollfd结构体指定一个被监视的文件描述符，可以给poll()传递多个pollfd结构体，使其能够监视多个文件描述符。

### ppoll()

linux提供了特有的ppoll()

```cpp
#define _GNU_SOURCE

#include <poll.h>

int ppoll(struct pollfd *fds,
          nfds_t nfds,
          const struct timespec *timeout, 
          const sigset_t *sigmask         
          )

```

其用途和结构类似于pselect()


### poll和select的区别

poll在调用有很多方面优于select调用

* poll不需要计算最大文件描述符值加上1传递参数
* poll对于值很大的文件描述符效率更高。
* select的文件描述符集是静态的，需要对大小设置进行权衡，如果过大会导致效率降低。对于poll只需要创建大小合适的数组即可。
* 对于select，返回时会重新创建文件描述符集，因此每次调用都需要重新初始化。
* select调用的timeout参数在返回时是未定义的。

## 内核内幕

### 虚拟文件系统

也称，虚拟文件交换(virtual file switch),支持Linux内核在不了解甚至不需要了解文件系统类型的情况下调用文件系统函数并操作文件系统的数据。
虚拟文件系统通过通用文件模型(common file model)实现这种抽象，框架提供了hook，支持读写链接等功能。能够很好支持fat ntfs等文件系统。

例如，当应用发起read系统调用时，从C库获取系统调用的定义，在编译时转化为相应的trap语句，这个指的是用于指定在接收到信号后要采取的操作。一旦进程从用户空间进入内核，交给系统调用handler处理，然后交给read系统调用。内核确定文件描述符所对应的对象类型，并调用相应的read()函数。对于文件系统而言，read函数是文件系统代码的一部分，然后函数将数据读取返回给用户空间中的read调用，该调用返回系统调用handler，它把数据拷贝到用户空间，最后read系统调用返回，程序继续执行。

### 页缓存

页缓存是通过内存保存最近在磁盘文件系统上访问过的数据的一种方式，相对于当前处理器速度而言，磁盘访问速度过慢，通过在内存中保存被请求数据，内核后续对于相同数据的请求就可以直接在内存中进行读取，避免重复访问磁盘。

linux页缓存的大小是动态变化的，随着存在新的访问请求，会对旧的数据进行裁剪。且裁剪一般通过swap进行，并非单纯的清理后再读入，这样能提升相当的性能。通过/proc/sys/vm/swappiness进行调整，虚拟文件可以是0~100。默认60，值越大时，表示优先保存页缓存，交换数据；值越小表示有限清理页缓存。

内核同时也实现了页缓存预读技术，并动态管理预读的内容等。

### 页回写

前面提到过的，内核通过缓冲区延迟写操作，当缓冲区中的脏数据需要写到磁盘上时，将磁盘文件和内存数据同步，这个过程就叫做回写。
两种情况会触发回写，脏缓冲区时长超过设定的时间或者可用的空闲空间小于设定的大小就会触发。

回写时一组被称为flusher的内核线程来执行的，可能会存在多个flusher同时执行回写。多线程是为了更好地利用并行性，避免拥塞，确保等待向某个块设备进行写操作时，还能够支持其他的写操作。如果其他块设备存在脏缓冲区，不同的flusher线程会充分利用每一块设备。

缓冲区在内核中是通过buffer_head数据结构来表示，该数据结构跟踪和缓冲区相关的任何元数据，同时维护一个指向真实数据的指针。通过这种方式实现了缓冲子系统和页缓存之间的统一。
