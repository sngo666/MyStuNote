# 第二章 文件IO

在对文件进行读写之前，首先需要打开文件，内核会为每个进程维护一个打开文件的列表，这个列表称为`file table`，其由一些非负整数进行索引，这些非负整数成为文件描述符`file descryptors`，列表的每一项是一个打开文件的信息，包括指向该文件索引节点内存拷贝的指针以及关联的元数据，比如文件位置指针和访问模式。
打开文件会返回文件描述符，后续操作都是将文件描述符作为参数。

一般来说每个进程至少包括三个文件描述符，0，1，2表示标准输入，标准输出和标准错误。

## 打开文件

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *name, int flags)
int open(const char *name, int flags, mode_t mode)
```

调用成功会返回文件描述符，指向文件name所指向的路径，文件的位置是文件的起始位置0。

`flags`支持三种模式: O_RDONLY, O_WORNLY, O_RDWR，分别表示只读，只写或者读写模式打开文件。

通过和其他参数进行按位与运算，进一步修改和定义打开文件的行为。

* 关于新建文件的所有者
确定新建文件的所有者很简单，文件所有者的uid就是创建该文件的进程的有效uid。
默认情况下使用创建进程的有效gid就是新建文件的用户组(System V行为)，BSD规定了自己的规则，新建文件的用户组被定义成文件父目录的gid，可以通过系统调用fchown()手动设置所属组。

## 新建文件的权限

使用O_CREAT时如果文件已经存在，则该选项无效，如果同时指定了O_EXCL，在文件存在时open()的执行会失败。
在使用参数O_CREAT参数时如果没有设置参数mode，结果是未定义的。mode提供了新建文件的权限，对于新建的文件打开时不会检查权限，因此可以执行与权限相反的操作，比较常见的权限八进制数0644(文件的所有者可以读写，其他人只能读)，为了弥补mode 的不可移植性，同样可以通过一些选项与mode进行按位与。

最终写入磁盘的权限位是由mode参数和用户的文件创建掩码(umask)执行按位与操作而得到，umask是进程级属性，通常由login shell设置，通过调用umask()修改。

## creat函数

O_WRONLY | O_CREAT | O_TRUNC 的组合经常被使用，因此专门有个系统提供这个功能

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int creat(const char *name, mode_t mode);
```

系统调用open()和creat()在成功时都会返回文件描述符，出错时返回-1，并把errno设置成相应的错误值。

## 通过read打开文件

```cpp
#include <unisd.h>

ssize_t read(int fd, void *buf, size_t len);
```

每次调用read()，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中，执行成功返回写入的字节数，出错时返回-1并设置errno。
同时fd的文件位置指针会向前移动相应的长度，除非fd所指向的对象不支持seek对象，比如字符设备文件。

读取的字节数即unsigned long类型的大小，在32位上是四字节，64位上是8字节。

这样的实现可能存在两种问题：可能还没读取到len字节，调用就返回了，会产生某些可操作的错误。
很多情况下都会返回都会出现返回值小于len的情况，例如读取被信号打断，管道被破坏，可用的字节数小于len。此外，当read到达文件末尾(EOF)时read返回0
如果调用是要读取len个字节，但是没有字节可读时，调用就会被阻塞(sleep)直到有数据可读。没有字节可读和到达文件结尾是两个不同的概念，进入阻塞模式后，表示正在等待更多的数据，在非阻塞模式下，不会发生这样的结果。

如何读入所有的字节呢，需要有一个循环:

```cpp
ssize_t ret;

while(len != 0 && (ret = read(fd, buf, len)) != 0){
  if (ret == -1){
    if (errno == EINTR)
      continue;
    perror("read");
    break;
  }

  len -= ret;
  buf += ret;
}
```

EINTR代表了read调用被中断，当进入中断时就会重启read，其他的情况则会中断读取。

有时候开发人员不希望read在调用时在没有数据可读时阻塞，并希望立即返回表示无数据可读。因此需要检查errno是否为EAGAIN，如果文件描述符以非阻塞模式打开(open()中指定O_NONBLOCK)会在没有数据可读时立即返回。

* read()调用的大小限制

