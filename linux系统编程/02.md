# 第二章 文件IO

在对文件进行读写之前，首先需要打开文件，内核会为每个进程维护一个打开文件的列表，这个列表称为`file table`，其由一些非负整数进行索引，这些非负整数成为文件描述符`file descryptors`，列表的每一项是一个打开文件的信息，包括指向该文件索引节点内存拷贝的指针以及关联的元数据，比如文件位置指针和访问模式。
打开文件会返回文件描述符，后续操作都是将文件描述符作为参数。

一般来说每个进程至少包括三个文件描述符，0，1，2表示标准输入，标准输出和标准错误。

## 打开文件

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *name, int flags)
int open(const char *name, int flags, mode_t mode)
```

调用成功会返回文件描述符，指向文件name所指向的路径，文件的位置是文件的起始位置0。

`flags`支持三种模式: O_RDONLY, O_WORNLY, O_RDWR，分别表示只读，只写或者读写模式打开文件。

通过和其他参数进行按位与运算，进一步修改和定义打开文件的行为。

* 关于新建文件的所有者
确定新建文件的所有者很简单，文件所有者的uid就是创建该文件的进程的有效uid。
默认情况下使用创建进程的有效gid就是新建文件的用户组(System V行为)，BSD规定了自己的规则，新建文件的用户组被定义成文件父目录的gid，可以通过系统调用fchown()手动设置所属组。

## 新建文件的权限

使用O_CREAT时如果文件已经存在，则该选项无效，如果同时指定了O_EXCL，在文件存在时open()的执行会失败。
在使用参数O_CREAT参数时如果没有设置参数mode，结果是未定义的。mode提供了新建文件的权限，对于新建的文件打开时不会检查权限，因此可以执行与权限相反的操作，比较常见的权限八进制数0644(文件的所有者可以读写，其他人只能读)，为了弥补mode 的不可移植性，同样可以通过一些选项与mode进行按位与。

最终写入磁盘的权限位是由mode参数和用户的文件创建掩码(umask)执行按位与操作而得到，umask是进程级属性，通常由login shell设置，通过调用umask()修改。

## creat函数

O_WRONLY | O_CREAT | O_TRUNC 的组合经常被使用，因此专门有个系统提供这个功能

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int creat(const char *name, mode_t mode);
```

系统调用open()和creat()在成功时都会返回文件描述符，出错时返回-1，并把errno设置成相应的错误值。

## 通过read打开文件

```cpp
#include <unisd.h>

ssize_t read(int fd, void *buf, size_t len);
```

每次调用read()，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中，执行成功返回写入的字节数，出错时返回-1并设置errno。
同时fd的文件位置指针会向前移动相应的长度，除非fd所指向的对象不支持seek对象，比如字符设备文件。

读取的字节数即unsigned long类型的大小，在32位上是四字节，64位上是8字节。

这样的实现可能存在两种问题：可能还没读取到len字节，调用就返回了，会产生某些可操作的错误。
很多情况下都会返回都会出现返回值小于len的情况，例如读取被信号打断，管道被破坏，可用的字节数小于len。此外，当read到达文件末尾(EOF)时read返回0
如果调用是要读取len个字节，但是没有字节可读时，调用就会被阻塞(sleep)直到有数据可读。没有字节可读和到达文件结尾是两个不同的概念，进入阻塞模式后，表示正在等待更多的数据，在非阻塞模式下，不会发生这样的结果。

如何读入所有的字节呢，需要有一个循环:

```cpp
ssize_t ret;

while(len != 0 && (ret = read(fd, buf, len)) != 0){
  if (ret == -1){
    if (errno == EINTR)
      continue;
    perror("read");
    break;
  }

  len -= ret;
  buf += ret;
}
```

EINTR代表了read调用被中断，当进入中断时就会重启read，其他的情况则会中断读取。

有时候开发人员不希望read在调用时在没有数据可读时阻塞，并希望立即返回表示无数据可读。因此需要检查errno是否为EAGAIN，如果文件描述符以非阻塞模式打开(open()中指定O_NONBLOCK)会在没有数据可读时立即返回。

* read()调用的大小限制
类型size_t,ssize_t是由POSIX确定的，在32位上对应的c类型分别为unsigned int和int，最大值则是SIZE_MAX和SSIZE_MAX，len值超越最大值会导致未定义行为，SSIZE_MAX在32位上是LONG_MAX，所以需要对参数添加检查的门槛。

## 调用write()写

```cpp
#include <unisd.h>

ssize_t write(int fd, void *buf, size_t count);
```

同理，write会从文件描述符fd指向的位置开始写入最大count的字节，不支持seek的文件总是从起始位置开始写。最后返回写入的字节数并会在出错时返回-1，同时设置errno。
当返回0个字节时，并没有什么特别的含义，即单纯写入0个字节。
如果count大于SSIZE_MAX，那么调用wirte()的结果是未定义的。count为0，则立即返回0.

但是，其实现也需要同样的严谨，例如检查部分写(patial wirte)

* 部分写
对于普通文件，不太可能会出现部分写的情况，但是对于其他类型的文件，比如socket需要循环来保证写入所有的字节，使用循环的另一个好处是第二次调用write可能会返回错误值，以说明第一次调用为什么发生了部分写。

```cpp
ssize_t ret, nr;

while(len != 0 && (ret = write(fd, buf, len)) != 0){
  if (ret = -1){
    if (errno == EINTR)
      continue;
    perror("write");
    break;
  }
  len -= ret;
  buf += ret;
}

```

### Append(追加)模式

当使用Append模式打开文件描述符，写操作是从文件的结尾开始。其特点在于保证文件指针总是指向了文件末尾，可以理解成在每次写请求之前的文件位置更新操作是一个原子操作。更新文件位置，指向新的文件末尾，这和下一次的wirte没有关系，因为是自动完成的，但是如果下一个调用是read，会有一些影响。

### 非阻塞写

以非阻塞模式，即调用O_NONBLOCK模式打开文件，发起写操作时，调用write()返回-1并设置errno为EAGAIN，然后稍后可以再次发起请求。

### write()行为

当write调用返回时，内核已经把数据从提供的缓冲区拷贝到内核缓冲区中，但是数据不一定已经写到了目的地。
当用户空间发起write系统调用时Linux内核会做检查，然后直接把数据拷贝到缓冲区中，然后在后台中，内核会收集所有的这样的脏缓冲区，进行排序优化，并将缓冲区写到磁盘上，通过这种方式，write可以频繁调用并且返回。

假如要对一份刚写到缓冲区但还没写到磁盘的数据执行读操作，请求响应会直接读取缓冲区的数据，而不是读取磁盘上的陈旧数据，这种方式进一步提高了效率。
延迟写的另一个问题在于无法强制"顺序写"，虽然应用可能会考虑对于请求写进行排序，但是内核一般是出于性能考虑按照合适的方式对于写请求进行排序，按特定的顺序写入磁盘。一般来说只有系统崩溃时延迟写才会出现问题，

最后一个问题是对于某些IO错误的提示信息不准确，在回写时产生的任何IO错误，都不能报告给发起写请求的进程，内核的脏数据区和进程无关，多个进程可能会弄脏同一片数据区。而且一般来说进程可能早就已经返回并退出了，对于这些问题，为了保证数据按时写入内核设置了最大缓存时效，这个时间很短，小于0.01秒，在超出给定时效前将所有脏数据的缓存写入磁盘。

## 同步IO

有时候可以牺牲一些性能手动控制将缓冲写入磁盘，通过调用fsync()和fdatasync()，定义如下:

```cpp
#include <unistd.h>

int fsync(int fd);

```

该函数可以确保和文件描述符fd所指向的文件相关的所有脏数据都会回写到磁盘上，因此文件描述符fd必须以写方式打开，该调用会回写数据和元数据，后者指一些创建的时间戳以及索引节点中的其他属性。该调用在硬件驱动器确认数据和元数据已经写到磁盘上之前不会返回。
但是对于一些自身包含写缓存的磁盘。并没有办法知道是否真正写到磁盘上，好在正常情况下，磁盘自身的缓冲区写到磁盘上的时间也很短。

```cpp
#include <unistd.h>

int fdatasync(int fd);

```

fdatasync()和fsync类似，区别在于前者只会写入数据以及以后要访问文件所需要的元数据，不保证非基础性的元数据也写到了磁盘上，因此节省了时间提高了效率。因为索引节点和文件数据在磁盘上可能并不是相邻的，因而fsync可能会带来相当的seek代价。

这两个函数都不保证任何已经更新的包含该文件的目录项会同步到磁盘上。这意味着如果文件链接最近刚更新，文件数据可能会成功写入磁盘，但是却没有更新到相关的目录中，导致文件不可用。为了保证对目录项的更新也都同步到磁盘上，必须对文件目录也调用fsync()进行同步。

二者成功时返回0，失败后会返回-1并更新errno。

对于某些linux系统，直接调用fsync可能会失败，因为其文件系统没有实现该函数，即使实现了fdatasync()，某些固执的应用可能会在fysnc返回EINVAL(给定文件描述符所指向的对象不支持同步)时尝试使用fdatasync。

### sync()

用于对磁盘上所有缓冲区进行同步，虽然效率不高，但是广泛使用。

```cpp
#include <unistd.h>

void fdatasync(void);
```

POSIX标准并不要求sync()一直等待所有的缓冲区都写到磁盘后才返回，只需要调用它来启动把所有的缓冲区都写到磁盘上即可，一般建议多次调用。但是对于linux而言，一定是等到所有缓冲区都写入完成了才返回，因此调用一次就够了。
当系统繁忙时，sync可能需要相当久的时间才能返回。

### O_SYNC标志位

在open中使用O_SYNC标志位表示该文件的所有IO都需要同步。将调用返回和写入磁盘强制绑定，相当于每次执行完write后隐式执行fsync()，linux内核在具体实现上对此做了优化。其相对来说也会带来更多的时间开销，因为大量使用会带来频繁的同步。

### O_DSYNC和O_RSYNC

O_DSYNC指定每次写操作后，只同步普通数据，不同步元数据。可以理解为每次写请求后，隐式调用fdatasync()，相对于O_SYNC更好的提升了性能。

O_RSYNC标志位指定读请求和写请求之间的同步，该标志位必须和O_SYNC或者O_DSYNC一起使用，O_RSYNC保证读操作带来的任何影响也是同步的，即读操作带来的任何元数据更新必须在调用返回前写入磁盘。

## 直接IO

在open()中指定O_DIRECT会使内核对于io管理的影响最小化，如果提供O_DIRECT标志位，IO操作会忽略页缓存机制，直接对于用户空间缓冲区和设备进行初始化，所有的IO操作哦都是同步的，操作在完成之前不会返回。
使用直接IO时，请求长度，缓冲区对齐以及文件偏移都必须是底层设备扇区大小的整数倍(通常是512字节)。

## 关闭文件

通过close()取消文件描述符到对应文件的映射。

```cpp
#include <unistd.h>

int close(int fd);
```

调用成功时返回0，出错时返回-1并相应设置errno.

> 当关闭指向某个文件的最后一个文件描述符时,内核中表示该文件的数据结构就释放了。如果释放了数据结构会清除和文件相关的索引节点的内存拷贝。如果已经没有内存和索引节点关联，该索引节点也会被从内存中清除(出于性能考虑，也可能会保存在内核中，但也可能不需要)。如果文件已经从磁盘上解除链接，但是解除之前还一直打开，在文件被关闭并且其索引节点从内存中删除之后,该文件才会真正从物理磁盘上删除。因此.调用 close()可能会使得一个已解除链接的文件最终从磁盘上删除。

## 用lseek查找

