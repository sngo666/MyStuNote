# 进程地址空间与页表

进程 = 内核数据结构（PCB+mm_struct+页表(MMU)）+ 代码和数据

## 写实拷贝过程

1. 在写实拷贝前，子进程和父进程的数据地址相同，两个进程共享同一片数据空间。
2. 写实拷贝发生时，子进程打算修改共享空间内的数据，对父进程的数据进行拷贝，将拷贝的空间给子进程形成独立。
3. 子进程和父进程的数据值不一样，但是地址是相同的。
4. 因为地址并不是直接物理内存上的地址，地址其实是进程空间地址。

* 进程地址空间

高地址     内核区
          命令行参数或者环境变量
          栈
          ...
          共享区
          ...
          堆
          BSS:未初始化数据段
          已初始化数据段
低地址     代码段

* 进程地址空间结构体:

```c
// from 0x00000000 -->  0xffffffff
struct mm_struct{
  size_t code_end;
  size_t code_begin;

  size_t init data_begin;
  size_t init_data_begin;

  size_t uninit_data_begin;
  size_t uninit_data_end;

  size_t E_Variable_begin;
  size_t E_Variable_end;
}
```

linux在进行启动过程中，首先进行内存的初始化，先创建页表。每个进程都拥有各自的进程空间，而每个进程空间又分为内核空间和用户空间，内核空间是所有进程共享的，因此内核空间地址的页表也是所有进程共享的。页表是承接进程地址空间与物理地址空间的桥梁。
Linux内核中用户进程内存页表的管理是通过一个结构体mm_struct来描述的。

为了让cpu快速在虚拟地址访问到进程入口处，我们无论是哪个进程的main函数地址都是一样的。然后再从与对应的物理内存实际映射找到物理内存上该进程main实际的地址。

## 缺页中断

缺页中断就是操作系统先暂停对进程通过页表访问物理内存，然后操作系统对物理内存进行操作（拷贝父进程数据（写实拷贝），申请动态内存空间），然后再让进程操作该空间数据。

以一个例子分析缺页中断:

```cpp
#include <iostream>
#include <unistd.h>

int main(){
  int *p = new int[10];
  sleep(10);
  *p = 1;
  delete []p;
  return;
}

```

1. 首先当我们定义一个40字节的空间时，首先申请的是虚拟空间，内核反馈告诉进程，申请空间成功，但是并没有在物理空间中申请。
2. 这时语句选择让进程进入休眠状态，由于选择申请的是虚拟内存，并没有占用使用实际的物理空间，如果申请的是物理空间，那么休眠期间这40个空间就要被别的进程先使用。
3. 休眠结束，这时开始向数组内写入数据，由于没有申请物理空间，进入缺页中断。
4. 操作系统先去物理内存申请40个字节空间然后与该进程建立映射关系，然后才将数据写入空间。

其中缺页中断再进行一个详细化：
当我们需要对数组成员进行赋值时，先暂停写入，毕竟还没有安排物理内存嘛。

1. 操作系统首先在物理内存开辟空间。
2. 将开辟的空间与进程地址空间建立映射关系，也就是new建立的页表空间。
3. 映射关系建立完成后，在物理地址上写入数据。

所有的页表也是按需申请页表项的。

## 基于缺页中断的写时拷贝原理

发生创建子进程，其实就是将PCB、mm_struct、页表拷贝一份给子进程，那么还没写实拷贝前，其实所有的数据都是和父进程一模一样的。就是直接拷贝一份父进程数据给子进程。创建子进程时，将父进程的虚拟内存与物理内存映射关系复制到子进程中，并将内存设置为只读。

当我们想要改变子进程的val值会发生写实拷贝。发现该数据为在页表项为只读发生缺页中断，拷贝该物理空间数据，将映射关系改为映射拷贝的物理内存数据。

1. 子进程将改变原本存在于父进程的变量val的信号传入页表，由于val被设置为只读变量，因此发生缺页中断。
2. 操作系统开辟新的物理内存空间，并将val的值传入拷贝。
3. 改变子进程的页表映射关系，将新的物理内存空间地址映射给val的进程地址空间
4. 中断取消，子进程根据新的映射关系改变val。

