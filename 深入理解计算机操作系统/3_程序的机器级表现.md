# 第三章 程序的机器级表现

* 程序编码

gcc如何将程序编译成机器语言的过程：

1. _c预处理器_ 扩展源代码，插入所有用`#include`命令指定的文件，并扩展所有`#define`声明指定的宏。
2. 接着，_编译器_ 产生两个文件的汇编代码。(.s)
3. _汇编器_ 将汇编代码转化成二进制目标代码文件(.o)。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
4. _链接器_ 将目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件，可执行代码是机器代码的第二种形式。

* 指令集体系架构(Instruction Set Architecture, ISA)

我们使用ISA来定义机器级程序的的格式和行为，它包括了处理器状态、指令的格式、以及每条指令对状态的影响。
虽然程序的行为是每条指令按顺序执行的，但实际上处理器的硬件处理要复杂的多，它们是 _并发性_ 地执行许多指令。可以保证整体行为从宏观上依然是顺序执行指令。

虽然众所周知，但是还是说一句，计算机中的`字`(WORD)定义为16位。

* 使用 `rep; ret` 结束函数以返回函数的调用点

在AMD给编程者的指导意见书中，他们建议使用rep后面跟着ret的组合，以避免使ret成为结构跳转语句的目标。这里的rep指令抽象上相当于一条空指令。

* 运行时栈

c语言的过程调用使用了关键的的机制特性，即后进先出的堆栈机制。

|      栈底      |
| :------------: |
|    较早的帧    |
|      ...       |
|     参数n      |
|      ...       |
|     参数7      |
|    返回地址    |
| 被保存的寄存器 |
|    局部变量    |
|   参数构造区   |
|      栈顶      |

从栈顶到被保存的寄存器为正在执行的函数帧Q，参数和返回地址组成了调用函数Q的函数P，当执行函数Q时，函数P及所有调用P的向上追溯的过程都被暂时挂起。
x86-64的栈指针向低地址方向生长。

* union 的使用

使用union来定义为不同的变量引用同一片内存区域。当我们使用不同的数据类型指向同一片内存时，例如定义一个`unsigned long`类型与`double`的位表示是相同的，然而，从变量角度来说，它们所代表的数值含义完全不同。

* 数据对齐

许多计算机系统对于基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(2,4或8)的倍数。

_对齐原则_ 是任何K字节的基本对象的地址必须是K的倍数。例如：char类型的K值为1，short类型为2，指针类型为8(64位)等。在汇编中我们使用这样的命令:`.align 8`以保证后面的数据起始地址是8的倍数，因为每个表项字长8个字节，后面元素也会遵循8字节对齐的限制。



