# 从简单光追说起

通过使用`nvvk::ContextCreateInfo`请求Vulkan扩展，需要使用`VK_KHR_ACCELERATION_STRUCTURE`和`VK_KHR_RAY_TRACING_PIPELINE`，同时这些扩展还需要依赖于其他扩展，因此需要添加:

```cpp

nvvk::ContextCreateInfo contextInfo;
// #VKRay: Activate the ray tracing extension
VkPhysicalDeviceAccelerationStructureFeaturesKHR accelFeature{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR};
contextInfo.addDeviceExtension(VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME, false, &accelFeature);  // To build acceleration structures
VkPhysicalDeviceRayTracingPipelineFeaturesKHR rtPipelineFeature{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR};
contextInfo.addDeviceExtension(VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME, false, &rtPipelineFeature);  // To use vkCmdTraceRaysKHR
contextInfo.addDeviceExtension(VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME);  // Required by ray tracing pipeline
```

这里主要分为两个部分，通过添加Extension查询物理设备是否支持。其次是通过`vkGetPhysicalDeviceFeatures2`查询添加的Feature是否支持。
最后记得在初始化设备的时候，将`pNext`指向该Feature链。

通过一个函数查询GPU的光追能力:

```cpp
//.h
void                                            initRayTracing();
VkPhysicalDeviceRayTracingPipelinePropertiesKHR m_rtProperties{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR};

// .cpp
void initRayTracing()
{
  // Requesting ray tracing properties
  VkPhysicalDeviceProperties2 prop2{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2};
  prop2.pNext = &m_rtProperties;
  vkGetPhysicalDeviceProperties2(m_physicalDevice, &prop2);
}
```

因为忘了，特意去查了一下`VkPhysicalDeviceProperties2`一个存储properties的结构体，因而在查询`vkGetPhysicalDeviceProperties2`存储在`m_rtProperties`中。
通过查询光追能力获取最大递归深度，单条光线可执行的嵌套光线追踪调用次数。这可以看作是在递归路径追踪器中光线在场景中反弹的次数。需要注意的是，为了提高性能，在实践中应尽量减少递归，而采用循环方式。这也可以查询着色器头的大小，在后面的章节中创建着色器绑定表时需要用到。

## 加速结构(Acceleration Structure)

为了提高效率，光线追踪需要将几何图形组织到加速结构(AS)中，以减少渲染过程中光线-三角形交叉测试的次数。
但用户只能看到两个层次：一个顶层加速结构(TLAS)引用任意数量的底层加速结构(BLAS)，最大限制`VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxInstanceCount`。

通常，一个BLAS对应一个场景中的单个三维模型，而一个TLAS则对应通过定位(使用3×4变换矩阵)单个引用BLAS而构建的整个场景。
BLAS存储实际顶点数据。它们由一个或多个顶点缓冲区构建而成，每个缓冲区都有自己的变换矩阵。
因此我们可以在单个BLAS中存储多个定位模型。需要注意的是，如果一个对象在同一个BLAS中被实例化多次，它的几何体将被复制。这对于提高静态、非实例化场景组件的性能特别有用(经验法则是BLAS越少越好)。

TLAS将包含对象实例，每个实例都有自己的变换矩阵和相应 BLAS 的引用。我们将从一个底层AS和一个顶层AS开始，通过身份变换对其进行一次实例化。

对于一个obj文件，一般会读取其vertex, index和相关material存储到一个自建数据结构中，在这里是一个`ObjModel`结构中。该模型由一个`ObjInstance`结构引用，该结构还包含该特定实例的变换矩阵。对于光线跟踪，`ObjModel`和`ObjInstance`列表将自然地分别适合BLAS和TLAS。
构建BLAS对象的第一步是将`ObjModel`的几何数据转换为AS生成器使用的多个结构。我们将所有这些结构保存在 `nvvk::RaytracingBuilderKHR::BlasInput`下。

```cpp
auto objectToVkGeometryKHR(const ObjModel& model);
```

它的执行将填充三个结构，这些结构最终将传递给AS生成器:

`VkAccelerationStructureGeometryTrianglesDataKHR` : 指向存放三角形顶点/索引数据的缓冲区，以及将其解释为数组的信息（跨度、数据类型等）。
`VkAccelerationStructureGeometryKHR` : 包装器，其中包含几何体类型枚举（本例中为三角形）以及AS生成器的标志。
`VkAccelerationStructureBuildRangeInfoKHR` : 顶点数组中的索引，以作为BLAS的几何输入源。

其中，`VkAccelerationStructureGeometryTrianglesDataKHR`作为union`VkAccelerationStructureGeometryDataKHR` 的一部分传递的。

上述多个结构可以组合成数组，并内置于一个BLAS中。在本例中，该数组的长度始终为1。每个BLAS有多个几何图形是有原因的。主要原因是加速结构会更有效率，因为它能正确划分相交对象的体积。只有大型或复杂的静态对象组才需要考虑这一点。

请注意，我们目前认为所有对象都是不透明的，并向生成器说明了这一点，以便进行潜在的优化。

```cpp
//--------------------------------------------------------------------------------------------------
// Convert an OBJ model into the ray tracing geometry used to build the BLAS
//
auto objectToVkGeometryKHR(const ObjModel& model)
{
  // BLAS builder requires raw device addresses.
  VkDeviceAddress vertexAddress = nvvk::getBufferDeviceAddress(m_device, model.vertexBuffer.buffer);
  VkDeviceAddress indexAddress  = nvvk::getBufferDeviceAddress(m_device, model.indexBuffer.buffer);

  uint32_t maxPrimitiveCount = model.nbIndices / 3;

  // Describe buffer as array of VertexObj.
  VkAccelerationStructureGeometryTrianglesDataKHR triangles{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR};
  triangles.vertexFormat             = VK_FORMAT_R32G32B32_SFLOAT;  // vec3 vertex position data.
  triangles.vertexData.deviceAddress = vertexAddress;
  triangles.vertexStride             = sizeof(VertexObj);
  // Describe index data (32-bit unsigned int)
  triangles.indexType               = VK_INDEX_TYPE_UINT32;
  triangles.indexData.deviceAddress = indexAddress;
  // Indicate identity transform by setting transformData to null device pointer.
  //triangles.transformData = {};
  triangles.maxVertex = model.nbVertices - 1;

  // Identify the above data as containing opaque triangles.
  VkAccelerationStructureGeometryKHR asGeom{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR};
  asGeom.geometryType       = VK_GEOMETRY_TYPE_TRIANGLES_KHR;
  asGeom.flags              = VK_GEOMETRY_OPAQUE_BIT_KHR;
  asGeom.geometry.triangles = triangles;

  // The entire array will be used to build the BLAS.
  VkAccelerationStructureBuildRangeInfoKHR offset;
  offset.firstVertex     = 0;
  offset.primitiveCount  = maxPrimitiveCount;
  offset.primitiveOffset = 0;
  offset.transformOffset = 0;

  // Our blas is made from only one geometry, but could be made of many geometries
  nvvk::RaytracingBuilderKHR::BlasInput input;
  input.asGeometry.emplace_back(asGeom);
  input.asBuildOffsetInfo.emplace_back(offset);

  return input;
}

```

在上述代码中，我们利用了`position`是`VertexObj`结构的第一个成员这一事实。如果是在其他位置，我们就必须使用`offsetof`手动调整`vertexAddress`。
在 AS 构建中只需要`position`属性；稍后，我们将学习在光线跟踪时绑定顶点缓冲区，并手动查找其他所需的属性。

下一步就是将`Geometry`结构转化为`BLAS`:

```cpp
void HelloVulkan::createBottomLevelAS()
{
  // BLAS - Storing each primitive in a geometry
  std::vector<nvvk::RaytracingBuilderKHR::BlasInput> allBlas;
  allBlas.reserve(m_objModel.size());
  for(const auto& obj : m_objModel)
  {
    auto blas = objectToVkGeometryKHR(obj);

    // We could add more geometry in each BLAS, but we add only one for now
    allBlas.emplace_back(blas);
  }
  m_rtBuilder.buildBlas(allBlas, VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR);
}

```

遍历一遍所有的已加载模型，然后批量转化为`RaytracingBuilderKHR::BlasInput`并输入`m_rtBuilder`(`nvvk::RaytracingBuilderKHR m_rtBuilder`)进行构建。

## `RaytracingBuilder::buildBlas()`

nvpro内置该函数用于将`RaytracingBuilderKHR::BlasInput`生成一个`BLAS`。

创建一个BLAS结构需要具备一下要素：

* `VkAccelerationStructureBuildGeometryInfoKHR` : 于创建和构建加速度结构，于`objectToVkGeometryKHR()`中创建。
* `VkAccelerationStructureBuildRangeInfoKHR`范围引用，也在`objectToVkGeometryKHR()`中创建。
* `VkAccelerationStructureBuildSizesInfoKHR`：创建AS和从头开始缓冲区所需的大小。
* `nvvk::AccelKHR`: 结果。

接下来就是`buildBlas`:

```cpp

void nvvk::RaytracingBuilderKHR::buildBlas(const std::vector<BlasInput>& input, VkBuildAccelerationStructureFlagsKHR flags)
{
  m_cmdPool.init(m_device, m_queueIndex);
  uint32_t     nbBlas = static_cast<uint32_t>(input.size());
  VkDeviceSize asTotalSize{0};     // Memory size of all allocated BLAS
  uint32_t     nbCompactions{0};   // Nb of BLAS requesting compaction
  VkDeviceSize maxScratchSize{0};  // Largest scratch size

  // 为每个BLAS填充BuildAccelerationStructure，包含几何体的引用、构建range、所需内存和scratch缓冲区的大小，每次抓取使用相同的一片内存，因此需要预先准备内存所需要的最大大小，

  std::vector<BuildAccelerationStructure> buildAs(nbBlas);
  for(uint32_t idx = 0; idx < nbBlas; idx++)
  {
    // Filling partially the VkAccelerationStructureBuildGeometryInfoKHR for querying the build sizes.
    // Other information will be filled in the createBlas (see #2)
    buildAs[idx].buildInfo.type          = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
    buildAs[idx].buildInfo.mode          = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;
    buildAs[idx].buildInfo.flags         = input[idx].flags | flags;
    buildAs[idx].buildInfo.geometryCount = static_cast<uint32_t>(input[idx].asGeometry.size());
    buildAs[idx].buildInfo.pGeometries   = input[idx].asGeometry.data();

    // Build range information
    buildAs[idx].rangeInfo = input[idx].asBuildOffsetInfo.data();

    // Finding sizes to create acceleration structures and scratch
    std::vector<uint32_t> maxPrimCount(input[idx].asBuildOffsetInfo.size());
    for(auto tt = 0; tt < input[idx].asBuildOffsetInfo.size(); tt++)
      maxPrimCount[tt] = input[idx].asBuildOffsetInfo[tt].primitiveCount;  // Number of primitives/triangles
    vkGetAccelerationStructureBuildSizesKHR(m_device, VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
                                            &buildAs[idx].buildInfo, maxPrimCount.data(), &buildAs[idx].sizeInfo);

    // Extra info
    asTotalSize += buildAs[idx].sizeInfo.accelerationStructureSize;
    maxScratchSize = std::max(maxScratchSize, buildAs[idx].sizeInfo.buildScratchSize);
    nbCompactions += hasFlag(buildAs[idx].buildInfo.flags, VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR);
  }

  // 遍历所有BLAS后，我们得到了最大的从头开始缓冲区大小，我们将创建它。

  // Allocate the scratch buffers holding the temporary data of the acceleration structure builder
  nvvk::Buffer scratchBuffer =
      m_alloc->createBuffer(maxScratchSize, VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT);
  VkBufferDeviceAddressInfo bufferInfo{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, nullptr, scratchBuffer.buffer};
  VkDeviceAddress           scratchAddress = vkGetBufferDeviceAddress(m_device, &bufferInfo);

  // 通过使用VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR查询每个BLAS的实际大小，默认情况下，vkGetAccelerationStructureBuildSizesKHR 返回的大小为最坏情况的大小。创建后，实际空间可能会更小，而且有可能将加速结构复制到正好使用所需空间的加速结构。这样可以节省50%以上的设备内存使用量。

  // Allocate a query pool for storing the needed size for every BLAS compaction.
  VkQueryPool queryPool{VK_NULL_HANDLE};
  if(nbCompactions > 0)  // Is compaction requested?
  {
    assert(nbCompactions == nbBlas);  // Don't allow mix of on/off compaction
    VkQueryPoolCreateInfo qpci{VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO};
    qpci.queryCount = nbBlas;
    qpci.queryType  = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR;
    vkCreateQueryPool(m_device, &qpci, nullptr, &queryPool);
  }

  //单个命令缓冲区中创建所有 BLAS 是可行的，但可能会导致管线停滞，并产生潜在问题。为了避免这一潜在问题，将BLAS的创建分割成约256MB的所需内存块。如果我们请求压缩，就会立即执行，从而限制了所需的内存分配。
  std::vector<uint32_t> indices;  // Indices of the BLAS to create
  VkDeviceSize          batchSize{0};
  VkDeviceSize          batchLimit{256'000'000};  // 256 MB
  for(uint32_t idx = 0; idx < nbBlas; idx++)
  {
    indices.push_back(idx);
    batchSize += buildAs[idx].sizeInfo.accelerationStructureSize;
    // Over the limit or last BLAS element
    if(batchSize >= batchLimit || idx == nbBlas - 1)
    {
      VkCommandBuffer cmdBuf = m_cmdPool.createCommandBuffer();
      cmdCreateBlas(cmdBuf, indices, buildAs, scratchAddress, queryPool);
      m_cmdPool.submitAndWait(cmdBuf);

      if(queryPool)
      {
        VkCommandBuffer cmdBuf = m_cmdPool.createCommandBuffer();
        cmdCompactBlas(cmdBuf, indices, buildAs, queryPool);
        m_cmdPool.submitAndWait(cmdBuf);  // Submit command buffer and call vkQueueWaitIdle

        // Destroy the non-compacted version
        destroyNonCompacted(indices, buildAs);
      }
      // Reset

      batchSize = 0;
      indices.clear();
    }
  }

  //创建的加速度结构保存在该类中，因此可以通过创建索引进行检索。
  for(auto& b : buildAs)
  {
    m_blas.emplace_back(b.as);
  }

  //最后的扫尾工作
  vkDestroyQueryPool(m_device, queryPool, nullptr);
  m_alloc->finalizeAndReleaseStaging();
  m_alloc->destroy(scratchBuffer);
  m_cmdPool.deinit();
}
```

这里使用了很多nvpro库封装的数据结构，如果要在自己构建的vk封装中使用，也不是很麻烦的事情，手动安排buffer, command buffer等相关缓冲就行了。

### `cmdCreateBlas`

BLAS的创建包含两个部分：

* Creating : 使用`createAcceleration()`从内存分配器和先前的信息中创建加速结构，这也同时会创造缓冲区。
* Building : 有了加速结构、Scratch Buffer和几何信息，就可以实际构建BLAS了

`m_alloc->createAcceleration`按照加速结构的大小查询所需并创建一个缓冲区，并赋予其 `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR`和`VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT`使用位(后者是必需的，因为TLAS生成器需要BLAS的原始地址)
通过填写`VkAccelerationStructureCreateInfoKHR`的缓冲区字段，将加速结构绑定到其分配的内存中。
缓冲区和图像的`Vk*`句柄分配和内存绑定是分步完成的，而加速结构则不同，只需调用一次`vkCreateAccelerationStructureKHR`就能创建加速结构并将其绑定到内存。

```cpp
void nvvk::RaytracingBuilderKHR::cmdCreateBlas(VkCommandBuffer                          cmdBuf,
                                               std::vector<uint32_t>                    indices,
                                               std::vector<BuildAccelerationStructure>& buildAs,
                                               VkDeviceAddress                          scratchAddress,
                                               VkQueryPool                              queryPool)
{
  //重置查询
  if(queryPool)  // For querying the compaction size
    vkResetQueryPool(m_device, queryPool, 0, static_cast<uint32_t>(indices.size()));
  uint32_t queryCnt{0};

  for(const auto& idx : indices)
  {
    // Actual allocation of buffer and acceleration structure.
    VkAccelerationStructureCreateInfoKHR createInfo{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR};
    createInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
    createInfo.size = buildAs[idx].sizeInfo.accelerationStructureSize;  // Will be used to allocate memory.
    buildAs[idx].as = m_alloc->createAcceleration(createInfo);
    NAME_IDX_VK(buildAs[idx].as.accel, idx);
    NAME_IDX_VK(buildAs[idx].as.buffer.buffer, idx);

    // BuildInfo #2 part
    buildAs[idx].buildInfo.dstAccelerationStructure  = buildAs[idx].as.accel;  // Setting where the build lands
    buildAs[idx].buildInfo.scratchData.deviceAddress = scratchAddress;  // All build are using the same scratch buffer

    // Building the bottom-level-acceleration-structure
    vkCmdBuildAccelerationStructuresKHR(cmdBuf, 1, &buildAs[idx].buildInfo, &buildAs[idx].rangeInfo);

    // Since the scratch buffer is reused across builds, we need a barrier to ensure one build
    // is finished before starting the next one.
    VkMemoryBarrier barrier{VK_STRUCTURE_TYPE_MEMORY_BARRIER};
    barrier.srcAccessMask = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    barrier.dstAccessMask = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR;
    vkCmdPipelineBarrier(cmdBuf, VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
                         VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, 0, 1, &barrier, 0, nullptr, 0, nullptr);

    if(queryPool)
    {
      // Add a query to find the 'real' amount of memory needed, use for compaction
      vkCmdWriteAccelerationStructuresPropertiesKHR(cmdBuf, 1, &buildAs[idx].buildInfo.dstAccelerationStructure,
                                                    VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, queryPool, queryCnt++);
    }
  }
}
```

虽然这种方法具有保持所有`BLAS`独立的优势，但高效构建多个`BLAS`需要分配更大的抓取缓冲区，并同时启动多个构建。本教程没有使用压缩，而压缩可以显著减少加速结构的内存占用。这两个方面将成为未来高级教程的一部分。

### `cmdCompactBlas`

选择构建压缩BLAS，这不是必需的，将把BLAS压缩到实际使用的内存中。我们必须等到所有BLAS都构建(build)完成后，才能在更合适的内存空间中复制一份。这就是我们在调用此函数之前使用`m_cmdPool.submitAndWait(cmdBuf)`的原因。

```cpp


void nvvk::RaytracingBuilderKHR::cmdCompactBlas(VkCommandBuffer                          cmdBuf,
                                                std::vector<uint32_t>                    indices,
                                                std::vector<BuildAccelerationStructure>& buildAs,
                                                VkQueryPool                              queryPool)
{
  uint32_t                    queryCtn{0};
  std::vector<nvvk::AccelKHR> cleanupAS;  // previous AS to destroy

  // Get the compacted size result back
  std::vector<VkDeviceSize> compactSizes(static_cast<uint32_t>(indices.size()));
  vkGetQueryPoolResults(m_device, queryPool, 0, (uint32_t)compactSizes.size(), compactSizes.size() * sizeof(VkDeviceSize),
                        compactSizes.data(), sizeof(VkDeviceSize), VK_QUERY_RESULT_WAIT_BIT);

  for(auto idx : indices)
  {
    buildAs[idx].cleanupAS                          = buildAs[idx].as;           // previous AS to destroy
    buildAs[idx].sizeInfo.accelerationStructureSize = compactSizes[queryCtn++];  // new reduced size

    // Creating a compact version of the AS
    VkAccelerationStructureCreateInfoKHR asCreateInfo{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR};
    asCreateInfo.size = buildAs[idx].sizeInfo.accelerationStructureSize;
    asCreateInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR;
    buildAs[idx].as   = m_alloc->createAcceleration(asCreateInfo);
    NAME_IDX_VK(buildAs[idx].as.accel, idx);
    NAME_IDX_VK(buildAs[idx].as.buffer.buffer, idx);

    // Copy the original BLAS to a compact version
    VkCopyAccelerationStructureInfoKHR copyInfo{VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR};
    copyInfo.src  = buildAs[idx].buildInfo.dstAccelerationStructure;
    copyInfo.dst  = buildAs[idx].as.accel;
    copyInfo.mode = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR;
    vkCmdCopyAccelerationStructureKHR(cmdBuf, &copyInfo);
  }
}
```

## TLAS

TLAS是光线追踪场景描述的入口点，存储了所有实例。
使用`VkAccelerationStructureInstanceKHR`以表示一个实例，将变换矩阵和BLAS的引用(ID)存储在传递给`buildBlas`的向量中，其还包含一个实例标识符（在着色过程中将作为`gl_InstanceCustomIndex`提供），以及表示着色时将调用的着色器的命中组索引`VkAccelerationStructureInstanceKHR::instanceShaderBindingTableRecordOffset`。

这个索引和命中组的概念与光线跟踪管道的定义和着色器绑定表(Shader Binding Table)息息相关，本教程稍后将对此进行介绍，并用于选择确定在运行时调用哪些着色器。现在只需说明，我们将在整个场景中只使用一个着色组，因此着色组索引始终为0。
实例可以使用其`VkGeometryInstanceFlagsKHR.flags`成员来指示剔除偏好，如背面剔除。在我们的示例中，我们决定完全禁用剔除，以简化并独立于输入模型的绕组。

```cpp
void HelloVulkan::createTopLevelAS()
{
  std::vector<VkAccelerationStructureInstanceKHR> tlas;
  tlas.reserve(m_instances.size());
  for(const HelloVulkan::ObjInstance& inst : m_instances)
  {
    VkAccelerationStructureInstanceKHR rayInst{};
    rayInst.transform                      = nvvk::toTransformMatrixKHR(inst.transform);  // Position of the instance
    rayInst.instanceCustomIndex            = inst.objIndex;                               // gl_InstanceCustomIndexEXT
    rayInst.accelerationStructureReference = m_rtBuilder.getBlasDeviceAddress(inst.objIndex);
    rayInst.flags                          = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
    rayInst.mask                           = 0xFF;       //  Only be hit if rayMask & instance.mask != 0
    rayInst.instanceShaderBindingTableRecordOffset = 0;  // We will use the same hit group for all objects
    tlas.emplace_back(rayInst);
  }
  m_rtBuilder.buildTlas(tlas, VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR);
}
```

### `RaytracingBuilder::buildTlas()`

同样，用于构建顶层加速结构的辅助函数是 nvpro-samples 的一部分，它从`Instance`对象向量中构建TLAS。
首先建立一个命令缓冲区，并复制用户的TLAS标志。

```cpp
 // Creating the top-level acceleration structure from the vector of Instance
  // - See struct of Instance
  // - The resulting TLAS will be stored in m_tlas
  // - update is to rebuild the Tlas with updated matrices
  void buildTlas(const std::vector<VkAccelerationStructureInstanceKHR>&         instances,
                 VkBuildAccelerationStructureFlagsKHR flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
                 bool                                 update = false)
  {
    // Cannot call buildTlas twice except to update.
    assert(m_tlas.accel == VK_NULL_HANDLE || update);
    uint32_t countInstance = static_cast<uint32_t>(instances.size());

    // Command buffer to create the TLAS
    nvvk::CommandPool genCmdBuf(m_device, m_queueIndex);
    VkCommandBuffer   cmdBuf = genCmdBuf.createCommandBuffer();

    // Create a buffer holding the actual instance data (matrices++) for use by the AS builder
    nvvk::Buffer instancesBuffer;  // Buffer of instances containing the matrices and BLAS ids
    instancesBuffer = m_alloc->createBuffer(cmdBuf, instances,
                                            VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
                                                | VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR);
    NAME_VK(instancesBuffer.buffer);
    VkBufferDeviceAddressInfo bufferInfo{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, nullptr, instancesBuffer.buffer};
    VkDeviceAddress           instBufferAddr = vkGetBufferDeviceAddress(m_device, &bufferInfo);

    // Make sure the copy of the instance buffer are copied before triggering the acceleration structure build
    VkMemoryBarrier barrier{VK_STRUCTURE_TYPE_MEMORY_BARRIER};
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR;
    vkCmdPipelineBarrier(cmdBuf, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
                         0, 1, &barrier, 0, nullptr, 0, nullptr);

    //我们有了一个命令缓冲区 (cmdBuf)、一个实例数（countInstance）和存放所有 VkAccelerationStructureInstanceKHR 的缓冲区地址。有了这些信息，我们就可以调用一个函数来构建TLAS。该函数将分配一个从头开始的缓冲区，我们需要在所有工作完成后销毁该缓冲区。

    nvvk::Buffer scratchBuffer;
    cmdCreateTlas(cmdBuf, countInstance, instBufferAddr, scratchBuffer, flags, update, motion);

    // Finalizing and destroying temporary data
    genCmdBuf.submitAndWait(cmdBuf);  // queueWaitIdle inside.
    m_alloc->finalizeAndReleaseStaging();
    m_alloc->destroy(scratchBuffer);
    m_alloc->destroy(instancesBuffer);
}

```

接下来就是熟悉的`cmdCreateTlas`：

```cpp
//--------------------------------------------------------------------------------------------------
// Low level of Tlas creation - see buildTlas
//
void nvvk::RaytracingBuilderKHR::cmdCreateTlas(VkCommandBuffer                      cmdBuf,
                                               uint32_t                             countInstance,
                                               VkDeviceAddress                      instBufferAddr,
                                               nvvk::Buffer&                        scratchBuffer,
                                               VkBuildAccelerationStructureFlagsKHR flags,
                                               bool                                 update,
                                               bool                                 motion)
{
   // Wraps a device pointer to the above uploaded instances.
  VkAccelerationStructureGeometryInstancesDataKHR instancesVk                 
            {VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR};
  instancesVk.data.deviceAddress = instBufferAddr;

  // Put the above into a VkAccelerationStructureGeometryKHR. We need to put the instances struct in a union and label it as instance data.
  VkAccelerationStructureGeometryKHR topASGeometry{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR};
  topASGeometry.geometryType       = VK_GEOMETRY_TYPE_INSTANCES_KHR;
  topASGeometry.geometry.instances = instancesVk;

  // Find sizes
  VkAccelerationStructureBuildGeometryInfoKHR buildInfo{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR};
  buildInfo.flags         = flags;
  buildInfo.geometryCount = 1;
  buildInfo.pGeometries   = &topASGeometry;
  buildInfo.mode = update ? VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR : VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR;
  buildInfo.type                     = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
  buildInfo.srcAccelerationStructure = VK_NULL_HANDLE;

  VkAccelerationStructureBuildSizesInfoKHR sizeInfo{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR};
  vkGetAccelerationStructureBuildSizesKHR(m_device, VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR, &buildInfo,
                                          &countInstance, &sizeInfo);

  // 创造加速结构

  VkAccelerationStructureCreateInfoKHR createInfo{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR};
  createInfo.type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR;
  createInfo.size = sizeInfo.accelerationStructureSize;

  m_tlas = m_alloc->createAcceleration(createInfo);
  NAME_VK(m_tlas.accel);
  NAME_VK(m_tlas.buffer.buffer);

  // Allocate the scratch memory
  scratchBuffer = m_alloc->createBuffer(sizeInfo.buildScratchSize,
                                        VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT);

  VkBufferDeviceAddressInfo bufferInfo{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, nullptr, scratchBuffer.buffer};
  VkDeviceAddress           scratchAddress = vkGetBufferDeviceAddress(m_device, &bufferInfo);
  NAME_VK(scratchBuffer.buffer);


  // 构建加速结构(build)
  // Update build information
  buildInfo.srcAccelerationStructure  = VK_NULL_HANDLE;
  buildInfo.dstAccelerationStructure  = m_tlas.accel;
  buildInfo.scratchData.deviceAddress = scratchAddress;

  // Build Offsets info: n instances
  VkAccelerationStructureBuildRangeInfoKHR        buildOffsetInfo{countInstance, 0, 0, 0};
  const VkAccelerationStructureBuildRangeInfoKHR* pBuildOffsetInfo = &buildOffsetInfo;

  // Build the TLAS
  vkCmdBuildAccelerationStructuresKHR(cmdBuf, 1, &buildInfo, &pBuildOffsetInfo);

}

```

## Ray Tracing Descriptor Set

光线追踪着色器与光栅化着色器一样，使用由描述符集引用的外部资源。通过光栅化图形管道，在使用不同材质绘制场景时，我们可以按材质分组对象，并按所使用的材质排列绘制顺序。只有在绘制该材质的对象时，才需要绑定该材质的管道和描述符。

相比之下，光线追踪无法提前知道哪些物体会被光线击中，因此可以随时调用任何着色器。这样，Vulkan 光线追踪扩展就可以使用一组描述符集，其中包含渲染场景所需的所有资源：例如，它将包含所有材质的所有纹理。此外，由于加速结构只包含位置数据，我们需要将原始顶点和索引缓冲区传递给着色器，以便手动查找其他顶点属性。

为了保持光栅化与光线追踪之间的兼容性，我们将重新使用旧光栅化渲染器中包含场景信息的描述符集，并添加另一个描述符集，引用TLAS和用于存储输出图像的缓冲区。

首先需要一些对象，这些都是常见的vk数据结构，在自己使用的时候需要单独构建。

```cpp
void           createRtDescriptorSet();

nvvk::DescriptorSetBindings                     m_rtDescSetLayoutBind;
VkDescriptorPool                                m_rtDescPool;
VkDescriptorSetLayout                           m_rtDescSetLayout;
VkDescriptorSet                                 m_rtDescSet;
```

光线生成着色器可以访问加速结构，因为我们希望从该着色器调用`traceRayEXT()`。在本文档的稍后部分，我们还将让"最近点着色器"也能访问加速结构，以便从该着色器发送光线。输出图像是光栅化所使用的离屏图像，将仅由`RayGen`着色器写入。

```cpp
//--------------------------------------------------------------------------------------------------
// This descriptor set holds the Acceleration structure and the output image
//
void HelloVulkan::createRtDescriptorSet()
{
  m_rtDescSetLayoutBind.addBinding(RtxBindings::eTlas, VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, 1,
                                   VK_SHADER_STAGE_RAYGEN_BIT_KHR);  // TLAS
  m_rtDescSetLayoutBind.addBinding(RtxBindings::eOutImage, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 1,
                                   VK_SHADER_STAGE_RAYGEN_BIT_KHR);  // Output image

  m_rtDescPool      = m_rtDescSetLayoutBind.createPool(m_device);
  m_rtDescSetLayout = m_rtDescSetLayoutBind.createLayout(m_device);

  VkDescriptorSetAllocateInfo allocateInfo{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO};
  allocateInfo.descriptorPool     = m_rtDescPool;
  allocateInfo.descriptorSetCount = 1;
  allocateInfo.pSetLayouts        = &m_rtDescSetLayout;
  vkAllocateDescriptorSets(m_device, &allocateInfo, &m_rtDescSet);


  VkAccelerationStructureKHR                   tlas = m_rtBuilder.getAccelerationStructure();
  VkWriteDescriptorSetAccelerationStructureKHR descASInfo{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR};
  descASInfo.accelerationStructureCount = 1;
  descASInfo.pAccelerationStructures    = &tlas;
  VkDescriptorImageInfo imageInfo{{}, m_offscreenColor.descriptor.imageView, VK_IMAGE_LAYOUT_GENERAL};

  std::vector<VkWriteDescriptorSet> writes;
  writes.emplace_back(m_rtDescSetLayoutBind.makeWrite(m_rtDescSet, RtxBindings::eTlas, &descASInfo));
  writes.emplace_back(m_rtDescSetLayoutBind.makeWrite(m_rtDescSet, RtxBindings::eOutImage, &imageInfo));
  vkUpdateDescriptorSets(m_device, static_cast<uint32_t>(writes.size()), writes.data(), 0, nullptr);
}
```

此外，由于光线追踪着色器也必须访问场景描述，我们需要扩展原始`createDescriptorSetLayout()`中相应缓冲区的访问标志。`RayGen`需要访问摄像机矩阵来计算光线方向，而`ClosestHit`则需要访问材质、场景实例、纹理、顶点缓冲区和索引缓冲区。尽管顶点缓冲区和索引缓冲区只会被光线追踪着色器使用，但我们还是将它们添加到了描述符集，因为它们在语义上与场景描述符集相匹配。

```cpp
// Camera matrices
m_descSetLayoutBind.addBinding(SceneBindings::eGlobals, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1,
                               VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_RAYGEN_BIT_KHR);
// Obj descriptions
m_descSetLayoutBind.addBinding(SceneBindings::eObjDescs, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1,
                               VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR);
// Textures
m_descSetLayoutBind.addBinding(SceneBindings::eTextures, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, nbTxt,
                               VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR);

```

最初，包含顶点和索引的缓冲区只被光栅化管道使用。
光线追踪需要将这些缓冲区用作存储缓冲区，因此我们添加了`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`；
此外，加速结构生成器将读取这些缓冲区，这需要原始设备地址（在`VkAccelerationStructureGeometryTrianglesDataKHR`中），因此缓冲区也需要 `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR`位。

最后是更新描述符集：

```cpp
//--------------------------------------------------------------------------------------------------
// Writes the output image to the descriptor set
// - Required when changing resolution
//
void HelloVulkan::updateRtDescriptorSet()
{
  // (1) Output buffer
  VkDescriptorImageInfo imageInfo{{}, m_offscreenColor.descriptor.imageView, VK_IMAGE_LAYOUT_GENERAL};
  VkWriteDescriptorSet  wds = m_rtDescSetLayoutBind.makeWrite(m_rtDescSet, RtxBindings::eOutImage, &imageInfo);
  vkUpdateDescriptorSets(m_device, 1, &wds, 0, nullptr);
}
```

## 光线追踪管线

在光线追踪流程中，与光栅化不透光，我们无法按照材质对绘制进行分组，因此在光线追踪中，每个着色器必需随时可以执行。所执行的着色器是在运行时在设备上选择的。
接下来两节的最终目标是建立Shader Binding Table（SBT）：使运行时选择着色器成为可能的结构。它本质上是一个包含不透明着色器句柄（可能是设备地址）的表，类似于C++的v-table，只是我们必须自己建立这个表。
具体步骤：

* 以常规方式将着色器载入并编译到`VkShaderModules`中。
* 将这些`VkShaderModules`打包成一个`VkPipelineShaderStageCreateInfo`数组。
* 创建一个`VkRayTracingShaderGroupCreateInfoKHR`数组；每个数组最终都将成为一个`SBT`条目。此时，着色器组会通过上述 `VkPipelineShaderStageCreateInfo`数组中的索引引用单个着色器，因为尚未分配设备地址。
* 使用`vkCreateRayTracingPipelineKHR`将上述两个数组(加上一个管道布局，与往常一样)编译成一个光线跟踪管道。
* pipeline编译将先前的着色器索引数组转换为着色器句柄数组。使用`vkGetRayTracingShaderGroupHandlesKHR`查询。
* 使用`VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR`使用位分配一个Buffer，并将句柄复制进去。

与光栅化图形管道相比，光线跟踪管道更像计算管道。光线跟踪在抽象的3D 宽度/高度/深度空间中调度，并使用`imageStore`手动写入结果。
不过，与计算管道不同的是，开发者需要调度单个着色器调用，而不是本地组。光线追踪的入口点是**光线生成着色器(Ray Generation Shader)**，我们将为每个像素调用该着色器。它通常会初始化一条射线，射线从摄像机位置开始，方向由评估像素位置的摄像机镜头模型决定。然后，它会调用`traceRayEXT()`，将光线射入场景中。`traceRayEXT`会调用接下来的几种着色器类型，这些着色器会使用光线跟踪payload来交流结果。

光线跟踪payload被声明为`rayPayloadEXT`或`rayPayloadInEXT`变量；它们共同建立了着色器阶段之间的调用者/被调用者关系。当调用`traceRayEXT()`来调用另一个着色器时，调用者可以选择其中一个payload作为`rayPayloadInEXT`变量（也称为"传入payload"）让被调用者着色器看到。

以下两种着色器类型是必须被使用：

* 当光线没有与任何几何体相交时，就会执行**未命中着色器(Miss Shader)**。例如，它可能会对环境贴图进行采样，或通过光线payload返回一个简单的颜色。
* **最近命中着色器(Closest Hit Shader)**在命中最接近射线起点的几何实例时被调用。例如，该着色器可以执行光照计算，并通过射线payload返回计算结果。可以根据需要设置多个最接近的着色器，就像基于光栅化的应用程序根据其对象设置多个像素着色器一样。

另外两种着色器类型选择性被使用：

* **交集着色器(Intersection Shader)**，允许与用户定义的几何体相交。可用于按需加载几何图形的几何图形占位符相交，或在不事先进行网格划分的情况下与程序化几何图形相交。使用这种着色器需要修改加速结构的构建方式。我们将依赖扩展提供的内置射线-三角形相交测试，该测试会返回2个浮点数值，代表三角形内命中点的重心坐标(u,v)，也就是根据三个顶点的值进行lerp。
* 在每个潜在交点上执行**任意命中着色器(Any Hit Shader)**：当搜索最接近射线原点的命中点时，可能会在途中发现多个候选点。任意命中着色器常用于高效地执行阿尔法测试。如果阿尔法测试失败，则无需再次调用`traceRayEXT()`即可继续进行射线遍历。内置的任意命中着色器只是将交点返回给遍历引擎的一个直通工具，它会确定哪个射线交点最接近。

最简单的一个光线追踪由三个Shader模块组成：一个Ray Generation Shader，一个Miss Shader和一个Closest Hit Shader。首先将每个 GLSL 着色器程序编译到 SPIR-V 中。这些 SPIR-V着色器将被链接到光线追踪管线中，该管线可将交集计算路由到正确的命中着色器。

## 添加Shader

光线生成Shader声明了对光线追踪输出缓冲区图像和光线追踪加速结构`topLevelAS`的访问，并将其绑定为`accelerationStructureEXT`。目前，该着色器程序只是向输出缓冲区写入一个常量颜色。

```glsl
#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;

void main() 
{
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0.5, 0.5, 0.5, 1.0));
}
```

丢失Shader定义了未命中着色器。该着色器将在没有几何体被击中时执行，并在射线有效载荷`rayPayloadInEXT`中写入一个常量颜色。由于我们当前的光线生成程序暂时没有跟踪任何光线，因此不会调用此着色器。

```glsl
#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 0) rayPayloadInEXT vec3 hitValue;

void main()
{
    hitValue = vec3(0.0, 0.1, 0.3);
}
```

最近命中Shader暂时只具备了最基础的结构，它将在击中几何体（我们的三角形）时执行。与未命中着色器一样，它也接收射线payload`rayPayloadInEXT`。它还有第二个输入，定义了内置三角形射线交点测试提供的交点属性`hitAttributeEXT`（即偏心坐标）。此着色器只需将一个常量颜色写入payload。

```glsl
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

layout(location = 0) rayPayloadInEXT vec3 hitValue;
hitAttributeEXT vec3 attribs;

void main()
{
  hitValue = vec3(0.2, 0.5, 0.5);
}
```

回到我们的vulkan构筑，让我们添加光线跟踪管道构建方法的定义，以及管道的存储成员：

```cpp
void                                              createRtPipeline();

std::vector<VkRayTracingShaderGroupCreateInfoKHR> m_rtShaderGroups;
VkPipelineLayout                                  m_rtPipelineLayout;
VkPipeline                                        m_rtPipeline;
```

用于推送的常量：

```cpp
// Push constant structure for the ray tracer
struct PushConstantRay
{
  vec4  clearColor;
  vec3  lightPosition;
  float lightIntensity;
  int   lightType;
};
```

首先是添加光线生成和未命中着色器阶段，然后是最接近的命中着色器。
请注意，这个顺序是任意的，因为扩展允许开发人员以任意顺序设置流水线。"阶段"这一术语是光栅化流水线遗留下来的；在光线跟踪中，我们自行安排着色器的调用顺序以及它们之间的数据流。 

```cpp
//--------------------------------------------------------------------------------------------------
// Pipeline for the ray tracer: all shaders, raygen, chit, miss
//
void HelloVulkan::createRtPipeline()
{

  //所有阶段都存储在VkPipelineShaderStageCreateInfo对象的std::vector中。如前所述，在此步骤中，该向量中的索引将用作着色器的唯一标识符。三个阶段将使用相同的入口点"main"。然后，我们从预编译的着色器中创建一个vkCreateShaderModule，并定义其对应的阶段。

  enum StageIndices
  {
    eRaygen,
    eMiss,
    eClosestHit,
    eShaderGroupCount 
  };

  // All stages
  std::array<VkPipelineShaderStageCreateInfo, eShaderGroupCount> stages{};
  VkPipelineShaderStageCreateInfo              stage{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO};
  stage.pName = "main";  // All the same entry point
  // Raygen
  stage.module = nvvk::createShaderModule(m_device, nvh::loadFile("spv/raytrace.rgen.spv", true, defaultSearchPaths, true));
  stage.stage    = VK_SHADER_STAGE_RAYGEN_BIT_KHR;
  stages[eRaygen] = stage;
  // Miss
  stage.module = nvvk::createShaderModule(m_device, nvh::loadFile("spv/raytrace.rmiss.spv", true, defaultSearchPaths, true));
  stage.stage  = VK_SHADER_STAGE_MISS_BIT_KHR;
  stages[eMiss] = stage;
  // Hit Group - Closest Hit
  stage.module = nvvk::createShaderModule(m_device, nvh::loadFile("spv/raytrace.rchit.spv", true, defaultSearchPaths, true));
  stage.stage  = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
  stages[eClosestHit] = stage;

  //这些标识符存储在VkRayTracingShaderGroupCreateInfoKHR结构中。该结构首先指定了一种类型，它代表了结构中所代表的着色器组类型。光线生成着色器和错失着色器被称为"通用(General)"着色器。在这种情况下，类型为VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR，并且只填充结构中的 generalShader 成员。
  //本教程中未使用的可调用着色器也是这种情况。在我们的布局中，射线生成排在第一位(0)，其次是缺失着色器(1)。

  // Shader groups
  // 请注意，如果几何体不是三角形，我们就需要将类型设置为VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR，并定义一个交点着色器。
  VkRayTracingShaderGroupCreateInfoKHR group{VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR};
  group.anyHitShader       = VK_SHADER_UNUSED_KHR;
  group.closestHitShader   = VK_SHADER_UNUSED_KHR;
  group.generalShader      = VK_SHADER_UNUSED_KHR;
  group.intersectionShader = VK_SHADER_UNUSED_KHR;

  // Raygen
  group.type          = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
  group.generalShader = eRaygen;
  m_rtShaderGroups.push_back(group);

  // Miss
  group.type          = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
  group.generalShader = eMiss;
  m_rtShaderGroups.push_back(group);

  // closest hit shader
  group.type             = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;
  group.generalShader    = VK_SHADER_UNUSED_KHR;
  group.closestHitShader = eClosestHit;
  m_rtShaderGroups.push_back(group);

  //创建着色器组后，我们需要设置管道布局(Layout)，以描述管道如何访问外部数据
  VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo;

  // Push constant: we want to be able to update constants used by the shaders
  VkPushConstantRange pushConstant{VK_SHADER_STAGE_RAYGEN_BIT_KHR | VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR | VK_SHADER_STAGE_MISS_BIT_KHR,
                                   0, sizeof(PushConstantRay)};


  VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo{VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};
  pipelineLayoutCreateInfo.pushConstantRangeCount = 1;
  pipelineLayoutCreateInfo.pPushConstantRanges    = &pushConstant;

  // 管线使用两个描述符集：set=0 是光线追踪管线(TLAS和输出图像)专用的，set=1 则与光栅化(场景数据)共享
  // Descriptor sets: one specific to ray tracing, and one shared with the rasterization pipeline
  std::vector<VkDescriptorSetLayout> rtDescSetLayouts = {m_rtDescSetLayout, m_descSetLayout};
  pipelineLayoutCreateInfo.setLayoutCount             = static_cast<uint32_t>(rtDescSetLayouts.size());
  pipelineLayoutCreateInfo.pSetLayouts                = rtDescSetLayouts.data();

  vkCreatePipelineLayout(m_device, &pipelineLayoutCreateInfo, nullptr, &m_rtPipelineLayout);

  //光线追踪流水线的创建不同于传统的图形流水线。在图形流水线中，我们只需填入一组固定的可编程阶段(vertex, fragment等)。光线追踪流水线可以包含任意数量的阶段，具体取决于场景中活动着色器的数量。
  // Assemble the shader stages and recursion depth info into the ray tracing pipeline
  VkRayTracingPipelineCreateInfoKHR rayPipelineInfo{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR};
  rayPipelineInfo.stageCount = static_cast<uint32_t>(stages.size());  // Stages are shaders
  rayPipelineInfo.pStages    = stages.data();

  //说明如何将着色器组合成组。光线生成或未命中着色器本身就是一个组，但命中组最多可由 3 个着色器（交点、任意命中、最近命中）组成.
  // In this case, m_rtShaderGroups.size() == 3: we have one raygen group,
  // one miss shader group, and one hit group.
  rayPipelineInfo.groupCount = static_cast<uint32_t>(m_rtShaderGroups.size());
  rayPipelineInfo.pGroups    = m_rtShaderGroups.data();

  //设置最大递归深度为1，即不进行递归，
  rayPipelineInfo.maxPipelineRayRecursionDepth = 1;  // Ray depth
  rayPipelineInfo.layout                       = m_rtPipelineLayout;
  vkCreateRayTracingPipelinesKHR(m_device, {}, {}, 1, &rayPipelineInfo, nullptr, &m_rtPipeline);

  //资源回收
  for(auto& s : stages)
    vkDestroyShaderModule(m_device, s.module, nullptr);
}
```

如前所述，交点由3种着色器管理：

1. 交点着色器计算射线-几何交点。
2. 任意命中着色器针对每个潜在交点运行。
3. 最近命中着色器应用于射线上最近的命中点。

这3个着色器被绑定到一个命中组中。在我们的例子中，几何体是由三角形组成的，因此`VkRayTracingShaderGroupCreateInfoKHR`的类型是`VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR`。

我们首先将`generalShader`重置为`VK_SHADER_UNUSED_KHR`。因此，光线追踪硬件取代了交点着色器，所以我们将 `intersectionShader`成员设置为`VK_SHADER_UNUSED_KHR`。
我们不使用any-hit着色器，让系统使用内置的直通着色器。因此，我们也将`anyHitShader`设置为`VK_SHADER_UNUSED_KHR`。我们定义的唯一着色器是最近命中着色器，方法是将`closestHitShader`成员设置为索引2(chit)，因为阶段向量已包含光线生成和未命中着色器。

## SBT表

在典型的光栅化设置中，当前着色器及其相关资源会在绘制相应对象之前绑定，然后为其他对象绑定另一个着色器和资源集，以此类推。由于光线追踪可以在任何时间击中场景的任何表面，因此所有着色器必须同时可用。
着色器绑定表是光线追踪过程的 "蓝图"。通过它，我们可以选择使用哪个光线生成着色器作为入口点，在找不到交点时执行哪个未命中着色器，以及每个实例可以执行哪个命中着色器组。实例和着色器组之间的关联是在设置几何体时建立的：我们在TLAS中为每个实例提供了一个`hitGroupId`。该值用于计算SBT中与该实例的着色组相对应的索引。条目之间所需的间距由以下公式计算得出:

* `PhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleSize`
* `PhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment`
* 开发者选择性提供的`shaderRecordEXT`

SBT是最多四个数组的集合，包含光线跟踪管道中使用的着色器组的句柄。
光线生成、未命中、命中和可调用（此处未使用）着色器组各有一个数组。在我们的示例中，我们将创建一个缓冲区来存储前三个组的数组。现在，我们每种类型只有一个着色器，因此每个 "数组 "只是一个着色器组的句柄。

我们将确保所有起始组都以对齐到`shaderGroupBaseAlignment`的地址开始，并且组中的每个条目都对齐到`shaderGroupHandleAlignment`字节。所有分组条目都按`shaderGroupHandleAlignment`对齐。

在不能保证对齐方式与句柄或组大小一致的情况下，必须四舍五入。使用`groupHandleSize`作为跨距可能会在你的硬件上凑巧起作用，但并非所有硬件都是如此。在句柄大小小于对齐方式的硬件上，可以交错使用一些 shaderRecordEXT 数据，而无需额外占用内存。

首先添加SBT创建方法和SBT缓冲区本身的声明：

```cpp
void           createRtShaderBindingTable();

nvvk::Buffer                    m_rtSBTBuffer;
VkStridedDeviceAddressRegionKHR m_rgenRegion{};
VkStridedDeviceAddressRegionKHR m_missRegion{};
VkStridedDeviceAddressRegionKHR m_hitRegion{};
VkStridedDeviceAddressRegionKHR m_callRegion{};
```

在`createRtShaderBindingTable()`开始时，我们会收集有关组的信息。射线源始终只有一个，因此我们添加常数1。

```cpp
//--------------------------------------------------------------------------------------------------
// The Shader Binding Table (SBT)
// - getting all shader handles and write them in a SBT buffer
// - Besides exception, this could be always done like this
//
void HelloVulkan::createRtShaderBindingTable()
{
  uint32_t missCount{1};
  uint32_t hitCount{1};
  auto     handleCount = 1 + missCount + hitCount;
  uint32_t handleSize  = m_rtProperties.shaderGroupHandleSize;


  // 设置每个组的跨距和大小。除了RayGen，跨距将是按照shaderGroupHandleAlignment对齐的手柄大小。而每个群组的大小，则是群组中按照shaderGroupBaseAlignment对齐的元素个数。
  // The SBT (buffer) need to have starting groups to be aligned and handles in the group to be aligned.
  uint32_t handleSizeAligned = nvh::align_up(handleSize, m_rtProperties.shaderGroupHandleAlignment);

  m_rgenRegion.stride = nvh::align_up(handleSizeAligned, m_rtProperties.shaderGroupBaseAlignment);
  m_rgenRegion.size   = m_rgenRegion.stride;  // The size member of pRayGenShaderBindingTable must be equal to its stride member
  m_missRegion.stride = handleSizeAligned;
  m_missRegion.size   = nvh::align_up(missCount * handleSizeAligned, m_rtProperties.shaderGroupBaseAlignment);
  m_hitRegion.stride  = handleSizeAligned;
  m_hitRegion.size    = nvh::align_up(hitCount * handleSizeAligned, m_rtProperties.shaderGroupBaseAlignment);

  //获取管线着色器组的句柄。
  // Get the shader group handles
  uint32_t             dataSize = handleCount * handleSize;
  std::vector<uint8_t> handles(dataSize);
  auto result = vkGetRayTracingShaderGroupHandlesKHR(m_device, m_rtPipeline, 0, handleCount, dataSize, handles.data());
  assert(result == VK_SUCCESS);
  
  //分配用于保存句柄数据的缓冲区。请注意，SBT缓冲区需要VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR标志。为了跟踪射线，我们还需要SBT的地址，这需要VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT标志。
  // Allocate a buffer for storing the SBT.
  VkDeviceSize sbtSize = m_rgenRegion.size + m_missRegion.size + m_hitRegion.size + m_callRegion.size;
  m_rtSBTBuffer        = m_alloc.createBuffer(sbtSize,
                                       VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT
                                           | VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
                                       VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
  m_debug.setObjectName(m_rtSBTBuffer.buffer, std::string("SBT"));  // Give it a debug name for NSight.

  //存储每个着色器组的设备地址。由于我们不使用可调用设备，因此将其保留为 0。
  // Find the SBT addresses of each group
  VkBufferDeviceAddressInfo info{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, nullptr, m_rtSBTBuffer.buffer};
  VkDeviceAddress           sbtAddress = vkGetBufferDeviceAddress(m_device, &info);
  m_rgenRegion.deviceAddress           = sbtAddress;
  m_missRegion.deviceAddress           = sbtAddress + m_rgenRegion.size;
  m_hitRegion.deviceAddress            = sbtAddress + m_rgenRegion.size + m_missRegion.size;

  // 这个 lambda 函数将返回指向先前获取的句柄的指针。
  // Helper to retrieve the handle data
  auto getHandle = [&] (int i) { return handles.data() + i * handleSize; };
  // Map the SBT buffer and write in the handles.
  auto*    pSBTBuffer = reinterpret_cast<uint8_t*>(m_alloc.map(m_rtSBTBuffer));
  uint8_t* pData{nullptr};
  uint32_t handleIdx{0};

  
}
```