# 条款35 优先考虑基于任务的编程而非基于线程的编程

如果开发者想要异步执行doAsyncWork函数，通常有两种方式。

其一是通过创建std::thread执行doAsyncWork，这是应用了基于线程（thread-based）的方式：

```cpp
int doAsyncWork();
std::thread t(doAsyncWork);
```

其二是将doAsyncWork传递给std::async，一种基于任务（task-based）的策略：

```cpp
auto fut = std::async(doAsyncWork); //“fut”表示“future”
```

基于线程与基于任务最根本的区别在于，基于任务的抽象层次更高。
基于任务的方式使得开发者从线程管理的细节中解放出来，对此在C++并发软件中总结了“thread”的三种含义：

* 硬件线程（hardware threads）

是真实执行计算的线程。现代计算机体系结构为每个CPU核心提供一个或者多个硬件线程。

* 软件线程（software threads）

是操作系统管理的在硬件线程上执行的线程。通常可以存在比硬件线程更多数量的软件线程，因为当软件线程被阻塞的时候（比如 I/O、同步锁或者条件变量），操作系统可以调度其他未阻塞的软件线程执行提供吞吐量。

* std::thread

 是C++执行过程的对象，并作为软件线程的句柄（handle）。
 有些std::thread对象代表“空”句柄，即没有对应软件线程，因为它们处在默认构造状态（即没有函数要执行）；
 有些被移动走（移动到的std::thread就作为这个软件线程的句柄）；
 有些被join（它们要运行的函数已经运行完）；
 有些被detach（它们和对应的软件线程之间的连接关系被打断）

而软件线程是有限的资源。如果开发者试图创建大于系统支持的线程数量，会抛出std::system_error异常。即使你编写了不抛出异常的代码，这仍然会发生：

```cpp
int doAsyncWork() noexcept;         //noexcept见条款14
std::thread t(doAsyncWork);         //如果没有更多线程可用，则抛出异常
```

设计良好的软件必须能有效地处理这种可能性，但是怎样做？
一种方法是在当前线程执行doAsyncWork，但是这可能会导致负载不均，而且如果当前线程是GUI线程，可能会导致响应时间过长的问题。
另一种方法是等待某些当前运行的软件线程结束之后再创建新的std::thread，但是仍然有可能当前运行的线程在等待doAsyncWork的动作。

如果你把这些问题推给另一个人做，你就会变得很轻松，而使用std::async就做了这件事：

```cpp
auto fut = std::async(doAsyncWork); //线程管理责任交给了标准库的开发者
```

这种调用方式将线程管理的职责转交给C++标准库的开发者。举个例子，这种调用方式会减少抛出资源超额异常的可能性，因为这个调用可能不会开启一个新的线程。
std::async不保证会创建新的软件线程。然而，他们允许通过调度器来将特定函数（本例中为doAsyncWork）运行在等待此函数结果的线程上（即在对fut调用get或者wait的线程上），合理的调度器在系统资源超额或者线程耗尽时就会利用这个自由度。

有了std::async，GUI线程中响应变慢仍然是个问题，因为调度器并不知道你的哪个线程有高响应要求。这种情况下，你会想通过向std::async传递std::launch::async启动策略来保证想运行函数在不同的线程上执行。

对比基于线程的编程方式，基于任务的设计为开发者避免了手动线程管理的痛苦，并且自然提供了一种获取异步执行程序的结果（即返回值或者异常）的方式。当然，仍然存在一些场景直接使用std::thread会更有优势：

1. 你需要访问非常基础的线程API。C++并发API通常是通过操作系统提供的系统级API（pthreads或者Windows threads）来实现的，系统级API通常会提供更加灵活的操作方式（举个例子，C++没有线程优先级和亲和性的概念）。为了提供对底层系统级线程API的访问，std::thread对象提供了native_handle的成员函数，而std::future（即std::async返回的东西）没有这种能力。
2. 你需要且能够优化应用的线程使用。举个例子，你要开发一款已知执行概况的服务器软件，部署在有固定硬件特性的机器上，作为唯一的关键进程。
3. 你需要实现C++并发API之外的线程技术，比如，C++实现中未支持的平台的线程池。
