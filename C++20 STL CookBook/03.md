# 第三章 STL容器

## 使用擦除函数从容器中删除项

C++20 前，`erase-remove`通常用于从 STL 容器中删除元素。这操作有点麻烦，通常使用这样的函数来完成:

```cpp
template<typename Tc, typename Tv>
void remove_value(Tc & c, const Tv v) {
  auto remove_it = std::remove(c.begin(), c.end(), v);
  c.erase(remove_it, c.end());
}
```

`std::remove()`函数在`<algorithms>`头文件中声明。`remove()`搜索指定的值，并将元素从容器的末尾向前移动来删除它，所以并不会改变容器的大小。它返回一个超出移位范围末端的迭代器，然后调用容器的`erase()`函数删除剩余的元素。

```cpp
std::erase(c, 5); // same as remove_value() function

std::erase_if(c, [](auto x) { return x % 2 == 0; });
```

具体表现为：

```cpp
vector v{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };
printc(v);                              // 0 1 2 3 4 5 6 7 8 9

erase(v, 5);
printc(v);                              // 0 1 2 3 4 6 7 8 9
```

使用`remove(c.begin()，c.end()，5)`时，算法从`begin()`迭代器开始搜索匹配的元素。对于找到的每个匹配元素，将下一个元素移到它的位置。然后，继续搜索和移动，直到到达`end()`迭代器。结果是一个容器，其中所有剩余的元素都在最开始的部分，没有删除的元素，并按照它们原来的顺序。
`end()`迭代器不变，其余元素未定义。

## 常数时间内从未排序的向量中删除项

使用擦除函数(或`erase-remove`)从vector 中间删除项需要 O(n)(线性) 时间。因为元素必须从向量的末尾移动，以填补删除项之间的空白。若 vector 中项目的顺序不重要，就可以优化这个过程，使其花费`O(1)`(常数) 时间。

`quick_delete()`函数有两个参数，一个 vector v 和一个索引 idx。首先，检查索引是否在边界之内。然后，从`<algorithms>`头文件中调用 move() 函数将 vector 的最后一个元素移动到索引的位置。最后，调用`v.pop_back()`函数从后面缩短vector:

```cpp
template<typename T>
void quick_delete(T& v, size_t idx) {
  if (idx < v.size()) {
    v[idx] = move(v.back());
    v.pop_back();
  }
}
```

以及基于迭代器非索引版本：

```cpp
template<typename T>
void quick_delete(T& v, typename T::iterator it) {
  if (it < v.end()) {
    *it = move(v.back());
    v.pop_back();
  }
}
```

## 安全地访问 vector 元素

