# 第五章 Lambda表达式

## 用于作用域可重用代码

Lambda 表达式可以定义和存储供后续使用，也可以作为参数传递，存储在数据结构中，并在不同的上下文中使用不同的参数调用。它们和函数一样灵活，并且具有数据的移动性。

· lambda 基本定义需要一对方括号和花括号，圆括号并不总是必需的。
lambda 表达式唯一需要的部分是捕获列表和函数体，函数体可以为空:

```cpp
[]{}
```

在类内使用 lambda 时，不能直接捕获对象成员，可以捕获`this`或`*this`来解除对类成员的引用。

## 算法库中作为谓词

算法库中的某些函数需要使用谓词函数。谓词是测试条件并返回布尔 true/false 响应的函数 (或函子或 lambda)。
也可以将函子用作谓词:

```cpp
struct is_div4 {
  bool operator()(int i) {
    return i % 4 == 0;
  }
};
...
int count = count_if(v.begin(), v.end(), is_div4());
```

这里唯一的变化是需要使用类的实例作为谓词。

## 与`std::function`一起作为多态包装器

类模板`std::function`是函数的精简多态包装器，可以存储、复制和调用函数、lambda表达式或其他函数对象，在想要存储对函数或lambda的引用的地方很有用。使用`std::function`允许在同一个
容器中存储具有不同签名的函数和lambda，并且其可以维护lambda捕获的上下文。

`function`类的性质使它在很多方面都很有用，可以将其视为一个多态函数容器。可以存储为一个独立的函数:

```cpp
void hello() {
  cout << "hello\n";
}
int main() {
  function<void(void)> h = hello;
  h();
}
```

可以存储一个成员函数，使用`std::bind`来绑定函数形参:

```cpp
struct hello {
  void greeting() const { cout << "Hello Bob\n"; }
};
int main() {
  hello bob{};
  const function<void(void)> h = std::bind(&hello::greeting, &bob);
  h();
}

```

或者可以存储可执行对象:

```cpp
struct hello {
  void operator()() const { cout << "Hello Bob\n"; }
};
int main() {
  const function<void(void)> h = hello();
  h();
}
```

## 用递归连接lambda

