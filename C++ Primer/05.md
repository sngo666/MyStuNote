# 第六章 函数

* 函数规定调用实参的数量应当与形参一直，形参一定会被初始化。
* 当我们在函数的数组类型形参中声明数组长度，如`void print(const int a[10])`,其本质没有任何作用，只是自欺欺人，对于限制实参的长度没有任何用。
* 接上条，正确的约束方式是使用引用类型的数组形参，如`void print( int (&a)[10])`，由此我们传递的实参长度被局限在了10.
* 传递二维数组时，数组的第二维(如果有的话或者是更高维)都是数组类型的一部分，是不能够省略的。

* 当使用argv向main传递函数后，argv的第一个元素指向程序的名字或者是一个空字符串。

* 为了能够处理不同数量实参，我们使用两种方法，如果所有的实参类型相同，我们可以传入一个叫做initializer_list的标准库类型；如果类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。
* 一个返回值类型是void的函数也能够使用return调用一个返回值为void类型的函数，不过只限于这样的情况。

* 当我们在返回引用类型的函数中使用return返回一个字面值字符串时，该字符串在内存中被转换为一个局部临时string对象，因此在函数结束调用后，该return指向了不可用的内存空间。指针和引用便是这个道理。
* 函数的返回类型决定返回的是左值还是右值，当我们返回一个引用类型时，我们可以为函数的返回值赋值。

* 返回数组指针的格式:`Type (*function(param_list))[dimension]`
* C++11提供了一种简化写法，尾置返回类型，如：`auto func(int i) -> int (*)[10];`

* 如果形参是某种类型的指针或者引用，通过区分其指向的是常量对象还是非常量对象可以实现函数重载。当传入一个非常量版本时，编译器会优先选择非常量版本。
* 我们在函数内层作用域中声明函数或者变量，会覆盖掉外层作用域的函数或者变量，对于内层作用域来说外层作用域的函数名已经被隐藏。在C++中，名字查找发生在类型匹配之前。
* 局部变量不能作为默认实参。
* 函数声明时添加默认值，定义时不添加。

* constexpr本质是一种内联函数，在执行初始化任务时，编译器会将其直接替换为结果。constexpr允许包含任何不在运行时执行任何操作的语句。但是constexpr不一定返回的是常量表达式。
* 内联函数和constexpr通常定义在头文件中。
* 函数实参中，顶层const和非const类型不构成函数重载。
* decltype不会自动将函数类型转换成函数指针类型。