# 第十二章 动态内存

* 当动态指针不再被使用，其所指的对象也将会被释放。
* 使用容器存放shared_ptr时，当部分元素不再被需要，要及时使用erase删除。
* 一般而言，当我们使用两个对象共享相同的内存数据，当其中一个被销毁时，我们希望数据不应当被清除，因为另一个正在使用，因此在类中定义智能指针共享数据部分可以实现这样的情况。

* 默认情况下，动态分配的对象是默认初始化的，然而内置类型或组合类型的值是未定义的，类会调用默认构造函数进行初始化。
* 对于内置指针管理的动态对象，直到显式释放之前都是存在的，比如new和delete
* 在delete一个指针后，指针值就变成无效了，然而在很多机器上仍然保留着动态指针的地址，此时指针为空悬指针，处理空悬指针很简单，即在其被delete后将nullptr赋予其内。
* 一段没有被指针指向且未被delete的内存空间会造成内存泄漏。

* 尽量使用make_shared开辟内存空间进行智能指针的初始化，而不是使用new进行初始化比较好
* 使用new初始化一个指针，再将其用于初始化一个智能指针并传递给一个函数，会导致函数结束后执行智能指针销毁程序，会导致对应的内存空间也会被销毁，因此不应该将new和之智能指针混合使用。
* 也不要使用get(获取内置指针)初始化另一个智能指针。或者delete一个get返回的指针
* 内置指针只会等待到delete完成销毁，中途如果发生异常，则永远不会被释放。
* 如果使用的智能指针管理的资源不是new返回的指针，记得传递一个删除器。
* 使用unique_ptr时注意，当设置删除器时，尖括号内第二个参数为删除器的函数指针类型，如`unique_ptr<connection, decltype(end_connection)*> p(&conn, end_connection)`

* 与unique_ptr不同，shared_ptr不直接支持管理动态数组，必须要指定自己的删除器才可以，例如定义一个lamda表达式，使用delete[]进行删除。
* allocator分配的内存是未被构造的，需要通过callocator.construct进行构造，并且在使用完之后，对每个构造的元素调用destory来销毁他们。