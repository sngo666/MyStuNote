# 第十二章 动态内存

* 当动态指针不再被使用，其所指的对象也将会被释放。
* 使用容器存放shared_ptr时，当部分元素不再被需要，要及时使用erase删除。
* 一般而言，当我们使用两个对象共享相同的内存数据，当其中一个被销毁时，我们希望数据不应当被清除，因为另一个正在使用，因此在类中定义智能指针共享数据部分可以实现这样的情况。

* 默认情况下，动态分配的对象是默认初始化的，然而内置类型或组合类型的值是未定义的，类会调用默认构造函数进行初始化。
* 对于内置指针管理的动态对象，直到显式释放之前都是存在的，比如new和delete
* 在delete一个指针后，指针值就变成无效了，然而在很多机器上仍然保留着动态指针的地址，此时指针为空悬指针，处理空悬指针很简单，即在其被delete后将nullptr赋予其内。
* 一段没有被指针指向且未被delete的内存空间会造成内存泄漏。

* 尽量使用make_shared开辟内存空间进行智能指针的初始化，而不是使用new进行初始化比较好
* 使用new初始化一个指针，再将其用于初始化一个智能指针并传递给一个函数，会导致函数结束后执行智能指针销毁程序，会导致对应的内存空间也会被销毁，因此不应该将new和之智能指针混合使用。
* 也不要使用get(获取内置指针)初始化另一个智能指针