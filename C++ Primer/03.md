# 第四章 表达式

* 重载无法改变运算符的优先级，结合律和运算对象的个数。
* 后置自增自减运算符优先级高于前置的。
* 编程当中应该尽量使用前置递增递减。
* 对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发并产生错误的未定义行为，有四种运算符明确定义了运算对象的求值顺序：三种逻辑运算符和逗号运算符。如果表达式里的运算对象互不相干，是不会出现这种情况的。且当改变运算对象的子表达式本身是另外一个子表达式的运算对象时该规则无效。

* 一元正号运算符，一元负号运算符都能作用于指针，当一个正号运算符作用于一个指针或者算术值时，返回运算对象值一个提升后的副本。
* (-m)%n被处理为-(m%n),m%(-n)被处理为m%n
* 逻辑运算符都是先求左侧值，当左侧值无法确定表达式的值之后才会求右侧表达式的值，这种策略被称为短路求值。
* 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值的true和false作为比较对象。

* 如果我们使用列表初始化为变量进行初始化且存在丢失信息的风险时，编译器会报错。
* 一定要记得点运算符的优先级高于解引用运算符。

* 当条件运算符(?:)的两个表达式是可以表示为同一种左值类型时，运算的结果是左值，否则表达式的结果是右值。同时条件运算符满足右结合性。

* 强烈建议仅将位运算用于无符号数。

## 关于sizeof

* sizeof不需要加括号，因为并不是库函数，而是关键字。
* 在sizeof中解引用一个无效指针依然是安全的行为，因为并没有真正使用这个指针，不需要真正的解引用指针的对象也能够知道其类型。

* 对string或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用多少空间。比如对vector使用sizeof可以发现结果固定为24(具体细节可以查阅STL源代码)

## 关于类型转换

* 我们已经知道当参与整数运算时多半会发生整型提升，但是无符号数参与的计算中，首先是进行整型提升(将小类型数提升为int类型)，如果两个提升后的对象要么都是带符号的要么都是无符号的。如果其中有一个是带符号的，一个是无符号的，且无符号的对象(内存空间)不小于有符号的对象(内存空间)，则将有符号的对象转换成无符号的对象，比如int和uint类型，会把int转为uint类型。剩下一种情况依赖于机器。

* 当数组被用作decltype或取地址符、sizeof以及typeid的运算对象时，不会发生将数组类型转换为指针类型的事件，当我们个指针类型元素赋值时，会发生这种隐式转换。还包括将0转换为字面值nullptr，指向任意非常量的指针都可以转换为void*
* IO库定义了istream转为bool类型的法则，如果读入成功，可以将结果转换为true，反之则反。

* static_cast对于找回编译器无法执行自动类型转换非常有用，比如使用其强制转换void*内的值，如果类型不符合，将会产生未定义的行为。
* const_cast只能用于改变运算对象的底层const(包括去const化和添加const)。
* 只有const_cast才能改变常量属性。其他cast关键词不能改变常量属性。但是可以使用static_cast将char *字面值转换为string类型。
* 使用reinterpret_cast是非常危险的。其依赖于机器和编译器，想要使用必须要有完全的理解和认识。