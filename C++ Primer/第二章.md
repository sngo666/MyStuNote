# 第二章 变量和基本类型

C++定义了一套包括算术类型和空类型的基本数据类型，其中算术类型包含整型和浮点型。
大部分都是很基础的东西，所以只挑一些很重要的知识点记下来，后面的指针和引用类型的重要知识点也会重点记录一下。

## 基本数据类型

* 一个char类型大小应当是和一个机器字节一样。
* 类型char16_t,char32_t,wchar_t等类型服务于Unicode字符集类型（别忘了NT的内核是由Unicode编写的）
* C++规定一个int类型应当至少和一个short类型一样大，一个long类型应当至少和int类型一样大，一个long long类型应当至少和一个long类型一样大。其中long long类型定义于C++11中。
* long double通常使用3或4个字来表示，即96或128个位。
* 一般来说float类和double类分别于有7和16个有效位。
* 负数在计算机中的存储形式为其绝对值并对符号位置位之后的补码。例:

> 源码:1011 (-3)  
> 反码:1100
> 补码:1101 即为最终在计算机中的存储形式

* 当一个有符号数和一个无符号数相加时，会发生自动类型转换，将有符号类型转换为无符号类型，值根据其二进制内容作出相应改变。
* 当从一个无符号数中减去一个数，不管这个值是不是无符号，我们都要确保结果不能是一个负值。(所以尽量控制好无符号数据的计算范围，防止不可控的溢出)
* 十进制字面值在其容量允许的范围内，是int，long和long long中最小的那一个，而八进制和十六进制则是容量允许的前提下同样数据类型的无符号版本中最小的那一个。
* 分开书写的多行字符串要分别用双引号括起来
* 给面值添加U后缀代表无符号类型数，添加L表示long类型，前缀L表示宽字符(wchar_t)，其他格式参考书中内容。（同样遵循最小匹配原则）

* 编译器的编译法则是从上到下，从左到右。
* 使用列表初始化定义变量会导致数据类型不能自动转换，引发问题。(同时说明列表初始化更加严谨，有利于代码规范)
* 内置类型的变量未被显式初始化，那么它的值由定义的位置决定，全局变量初始值为0，但是定义在函数体内部的变量不会被初始化，即可能是随机值。
* 类的对象如果没有被显式初始化，其值由类的定义决定。

* 一个变量的定义只有一次，但是声明可以有很多次。声明使得变量为程序所知，定义创建了与之相关联的实体。对变量的初始化会使这条语句变成定义。
* 不能在函数体内部试图初始化一个extern类型变量。使用其他文件所定义的extern变量需要在当前文件声明一次该变量。
* 代码规范中不建议使用下划线开头命名变量(STL内部变量)

## 复合类型

* 引用必须被初始化。
* 引用绑定的对象是永久的，不存在绑定之后再次绑定到别的对象上。因为引用本身不是对象，所以不能够定义引用的引用。
* 左值引用的初始值必须是一个对象，且与定义同类型。

* 对于指针变量的声明中，*仅为修饰之后的一个变量为指针类型，并非整条语句的变量声明为指针类型。
* 指针可以在定义时不声明初始值，但是同初始值的法则一样，在函数体内部声明的无初始值指针将存放随机值。
* 指针的值应当是指向一个对象，此外有效的情况还有紧邻对象的空间，空指针，应当尽量避免这些情况。更不应该出现上述情况之外的无效指针。
* 使用`nullptr`或0来使指针不指向任何对象，应当尽量避免指针未被初始化的情况。

## const

* 默认情况下const仅在文件内使用，多个文件中定义的同名const等同于各自定义了独立的const常量。
* 想要只在一个文件中定义一个const常量并在其他文件中使用，需要使用extern关键字，不管是声明定义都需要加上extern，否则链接器会报错。
* const引用仅支持常量引用，例如`const int &i = r`，意为不允许通过引用变量i修改r的值，常量引用限制的是引用，而不是引用的值，通过常量引用依然可以修改对象（如果引用的对象不是一个常量。）
* 常量引用在定义中可以赋值一个常量或者一个表达式，会对不匹配的数据类型作自动转换(视为表达式)。
* 非const引用不能赋值一个常量或者表达式，当引用对象的数据类型不匹配时，会直接报错。
  
* 指针支持指针常量(`int *const `)和常量指针(`const int *`)，对于const变量，只能使用常量指针来指向，不能使用一般指针。（绝大多数情况，指针的类型应当与绑定的对象类型一致）
* 不一致的情况指的是，一个常量指针指向一个非const变量，这时候不能通过该指针修改变量的值，但是变量的值依旧可以被修改。

* 