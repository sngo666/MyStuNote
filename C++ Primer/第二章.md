# 第二章 变量和基本类型

C++定义了一套包括算术类型和空类型的基本数据类型，其中算术类型包含整型和浮点型。
大部分都是很基础的东西，所以只挑一些很重要的知识点记下来，后面的指针和引用类型的重要知识点也会重点记录一下。

## 基本数据类型

* 一个char类型大小应当是和一个机器字节一样。
* 类型char16_t,char32_t,wchar_t等类型服务于Unicode字符集类型（别忘了NT的内核是由Unicode编写的）
* C++规定一个int类型应当至少和一个short类型一样大，一个long类型应当至少和int类型一样大，一个long long类型应当至少和一个long类型一样大。其中long long类型定义于C++11中。
* long double通常使用3或4个字来表示，即96或128个位。
* 一般来说float类和double类分别于有7和16个有效位。
* 负数在计算机中的存储形式为其绝对值并对符号位置位之后的补码。例:

> 源码:1011 (-3)  
> 反码:1100
> 补码:1101 即为最终在计算机中的存储形式

* 当一个有符号数和一个无符号数相加时，会发生自动类型转换，将有符号类型转换为无符号类型，值根据其二进制内容作出相应改变。
* 当从一个无符号数中减去一个数，不管这个值是不是无符号，我们都要确保结果不能是一个负值。(所以尽量控制好无符号数据的计算范围，防止不可控的溢出)
* 十进制字面值在其容量允许的范围内，是int，long和long long中最小的那一个，而八进制和十六进制则是容量允许的前提下同样数据类型的无符号版本中最小的那一个。
* 分开书写的多行字符串要分别用双引号括起来
* 给面值添加U后缀代表无符号类型数，添加L表示long类型，前缀L表示宽字符(wchar_t)，其他格式参考书中内容。（同样遵循最小匹配原则）

* 编译器的编译法则是从上到下，从左到右。
* 使用列表初始化定义变量会导致数据类型不能自动转换，引发问题。(同时说明列表初始化更加严谨，有利于代码规范)
* 内置类型的变量未被显式初始化，那么它的值由定义的位置决定，全局变量初始值为0，但是定义在函数体内部的变量不会被初始化，即可能是随机值。
* 类的对象如果没有被显式初始化，其值由类的定义决定。

* 一个变量的定义只有一次，但是声明可以有很多次。声明使得变量为程序所知，定义创建了与之相关联的实体。对变量的初始化会使这条语句变成定义。
* 不能在函数体内部试图初始化一个extern类型变量。使用其他文件所定义的extern变量需要在当前文件声明一次该变量。
* 代码规范中不建议使用下划线开头命名变量(STL内部变量)

## 复合类型

* 引用必须被初始化。
* 引用绑定的对象是永久的，不存在绑定之后再次绑定到别的对象上。因为引用本身不是对象，所以不能够定义引用的引用。
* 左值引用的初始值必须是一个对象，且与定义同类型。

* 对于指针变量的声明中，*仅为修饰之后的一个变量为指针类型，并非整条语句的变量声明为指针类型。
* 指针可以在定义时不声明初始值，但是同初始值的法则一样，在函数体内部声明的无初始值指针将存放随机值。
* 指针的值应当是指向一个对象，此外有效的情况还有紧邻对象的空间，空指针，应当尽量避免这些情况。更不应该出现上述情况之外的无效指针。
* 使用`nullptr`或0来使指针不指向任何对象，应当尽量避免指针未被初始化的情况。

## const

* 默认情况下const仅在文件内使用，多个文件中定义的同名const等同于各自定义了独立的const常量。
* 想要只在一个文件中定义一个const常量并在其他文件中使用，需要使用extern关键字，不管是声明定义都需要加上extern，否则链接器会报错。
* const引用仅支持常量引用，例如`const int &i = r`，意为不允许通过引用变量i修改r的值，常量引用限制的是引用，而不是引用的值，通过常量引用依然可以修改对象（如果引用的对象不是一个常量。）
* 常量引用在定义中可以赋值一个常量或者一个表达式，会对不匹配的数据类型作自动转换(视为表达式)。
* 非const引用不能赋值一个常量或者表达式，当引用对象的数据类型不匹配时，会直接报错。
  
* 指针支持指针常量(`int *const `)和常量指针(`const int *`)，对于const变量，只能使用常量指针来指向，不能使用一般指针。（绝大多数情况，指针的类型应当与绑定的对象类型一致）
* 不一致的情况指的是，一个常量指针指向一个非const变量，这时候不能通过该指针修改变量的值，但是变量的值依旧可以被修改。

* 顶层const表示指针本身是一个常量(如指针常量)，底层const表示指针所指的是一个常量(如常量指针)，指针类型既可以是顶层const也可以是底层const，一个常量指针或者一个指针常量可以赋值给一个指向常量的常量指针。即新定义的指针必须要比被赋值对象严格才满足。记住法则：从右往左更严格。

## 常量表达式

* 常量表达式指的是值不改变且编译阶段就能得到结果的表达式。常量表达式必须是const类型变量，如:

> `const i = j + i`
> `const i = 20`

以上 都为常量表达式。
c++11标准可以使用`constexpr`关键字来声明常量表达式，如果你认定一个变量是常量表达式，使用此关键字避免潜在的错误。

如果在`constexpr`中定义了一个指针，那么该关键词仅对指针有效，与指针所指的对象无关。

> ```cpp
> const int *p = nullptr;
> constexpr int *q =nullptr;
> ```

在上述两个式子中，第一句定义了一个底层const，第二句定义了一个顶层指针。关键在于`constexpr`把它所定义的对象置为了顶层const。尽管指针和引用都能定义成constexpr，constexpr的指针初始值必须要是nullptr或者是0,或者是某个存在于固定地址中的对象(定义在任何函数体之外的变量，其地址固定不变)。

## 类型别名

* 使用类型别名方便更好的代码阅读。
* `typedef double base, *p`中base是double的同义词，p是double *的同义词。

* 如果某个类型别名指代的是复合类型或者是常量，那么声明时可能会产生意想不到的后果(书中举例为一个字符指针声明别名并声明该类型别名下const类型的变量，理论上const char *类型应当是一个常量指针，但是从实际实验上来看声明了一个指针常量)。
* 上述情况的解释：const是对给定类型的修饰，但是在发生类型替换后，const修饰的是别名，别名本身是指向char的指针，那么在这种情况指针是常量，typedef带来的不仅仅是字面上的等效替换。通俗来说，不恰当的比喻为，[const char *]中const修饰的是char，替换过后相当于[const (char *)],实际上并没有这种荒谬的写法，只是为了方便理解。

## auto类型说明符

使用编译器代替开发者去判断表达式的结果并赋值给声明的变量，但是尽管使用auto可以在一条语句中声明多个变量，但是一条语句中只能定义同一种类型，例如:
`auto i=0, j =3.14`是不合法的定义。
且一般auto会忽略掉顶层const，但是会保留底层const，如果希望推断出的auto类型是一个顶层const，需要明确指出:
`const auto f = ci`

* 也可以将引用的类型设为auto，此时初始化的规则仍然存在(`auto &i = ci`)。
* const int类型和int类型不能在同一条语句中定义。

## decltype类型指示符

C++11新标准引入了第二种类型说明符decltype，用于选择并返回操作数的数据类型，但是并不实际计算表达式的值，如果decltype使用的表达式是一个变量，那么返回该变量的类型，并且包括顶层const和引用在内。用法：
`decltype(f()) sum = x`编译器并不实际调用函数f，而是使用当调用时的返回类型作为sum的类型。

需要注意的是解引用所能够得到指针所指的对象，因此对指针类型变量解引用得到的是该变量的类型的引用。此外，且对要判断的变量加上括号时，decltype((variable))的结果永远是变量的引用类型。且赋值表达式也会产生引用类型的表达式，对于赋值表达式使用decltype也会产生引用类型。

## 自定义数据结构

确保头文件多次包含但是仍然能够正常工作的常用技术是预处理器，它由C++语言从C继承而来，使用头文件保护符有效防止重复定义的情况发生。
