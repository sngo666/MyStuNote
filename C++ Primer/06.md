# 第七章 类

* 导致深拷贝和浅拷贝的原因在于类内部是否只有内置数据类型，或存在指针等现象，因此对于自定义类，需要认真考虑编写copy构造函数。

* 在类的声明(一般来说指的是在头文件中)中定义函数，并非显式地声明其为内联函数，本质是隐式内联.
* 一个const成员函数如果返回*this指针，那么返回类型也将是一个常量引用，即不能通过该指针修改指向的对象.

* 前向声明指的是可以类似于将函数的声明和定义分开，事先声明类名称，这样使其为一种不完全类型。不完全类型的使用范围非常有限，可以定义指向其的引用或指针，也可以声明其参与的函数，但不能定义。站在编译器角度，如果在一个类里声明该类的对象，会导致错误，因为编译器不知道该类具体占有多少内存空间。但引用和指针的大小是固定的。

* 友元关系不存在传递性.
* 友元的声明仅仅是指定了访问权限，如果需要调用友元函数，必须在调用之前单独声明或者定义一次.

* 因为返回类型是出现在作用域声明之前的，所以需要声明位于哪个作用域.

* 编译器要先处理完类中的全部声明再处理成员的定义.
* 如果在类内声明const类型变量，必须要在列表初始化时完成，不能在构造函数体内初始化。同理，因为声明时必须初始化的特性，引用也是如此。
* 当类内部声明了没有定义默认构造函数的类的对象，也必须使用列表初始化完成初始化。列表初始化的顺序和列表的顺序没有关系，而是和成员在类内的声明顺序有关。
* 如果一个构造函数为所有参数都提供了默认实参，那么它实际上也定义了默认构造函数。
* 编译器只有在发现没有定义任何构造函数的情况下，尝试生成一个合成构造函数。

* string可以接受将一个const char*类型进行隐式转换。但是接受容量参数的vector的构造函数是explicit的。
* constexpr函数最好只包含一个return.
* 静态成员不能声明为const.因为const本身就是限制的是this指针，而静态成员只和类本身有关。静态成员不属于类的一部分，是单独存储的，因此也不是在初始化对象的时候分配空间的。然而，C++提供了静态整型类型的const常量。
* 然而，不仅如此，还有一些静态成员适用而非静态不适用的情况，可以在类内定义本类的静态对象，或是对象指针，但是不能直接定义此类对象。因为静态成员可以是不完全类型。