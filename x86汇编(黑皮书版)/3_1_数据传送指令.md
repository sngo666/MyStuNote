## 数据传送指令

指令的操作数个数可以是0，1，2或者是3个，而操作数有三种基本类型：

1. 立即数：使用数字文本表达式。
2. 寄存器操作数：使用CPU命名的寄存器。
3. 内存操作数：引用内存位置。

32位模式下指令操作数符号如图所示：
|符号|说明|
|:----:|:----:|
|reg8/16/31|8/16/32位寄存器|
|reg|通用寄存器|
|imm8/16/32|8/16/32位立即数|
|mem8/16/32|8/16/32位内存操作数|

&emsp;

* 直接内存操作数

变量名引用的是数据段内的的偏移量，可以编写指令，通过内存操作数的地址来解析这些操作数。假设定义标识符`var1`的地址偏移量为`00010400`,通过如下命令操作时：
> `mov al var1`  
> 经过汇编变成如下的机器指令.  
> `A0 00010400`  
> 该机器指令的第一个字节是操作码(opcode)，剩余部分是`var1`的32位地址。  
> 也可以使用如下方式表示：  
> `mov al,[var1 + 0]`  
> 这是直接偏移量操作数。  

&emsp;

* MOV指令

MOV指令将源操作数复制到目的操作数。
> 基本格式：  
> `MOV destination, source`  
需要遵循如下原则：

1. 两个操作数必须是相同的大小。
2. 两个操作数不能同时为内存操作数。、
3. 指令指针寄存器(IP,EIP,RIP)不能作为目标操作数。

> _关于从内存到内存_
> 将一个内存的数据传递到另一个内存的位置中，必须先经过一个寄存器中转传递。

&emsp;

* 整数的全零和符号化扩展

MOV指令不支持将较小的操作数复制到较大的操作数中，将一个无符号整数赋值到另一个操作数时，可先对其进行置0初始化。
当对一个有符号整数进行同样的操作会导致结果与预期完全不同，应该对目标操作数作置1，再进行低位覆盖。

&emsp;

* MOVZX指令

MOVZX指令(进行全零扩展并传送)用于将源操作数赋值到目标操作数，并吧目的操作数0扩展到16或32位，故该指令只适用于无符号整数。形式如下:

> ```asm  
> MOVZX reg32,reg/mem8  
> MOVZX reg32,reg/mem16  
> MOVZX reg16,reg/mem8  
> ```  
>  
> _通俗解释就是将位数低的复制入位数高的，并对其剩余位进行自动补零。_  

&emsp;

* MOVSX指令

同指令`MOVZX`，补全高位时置1。

&emsp;

* LAHF指令和SAHF指令

LAHF(加载状态标志位到AH)将EFLAGS寄存器的低字节复制到AH，其中内容有：符号标志位，零标志位，辅助进位标志位，奇偶标志位和进位标志位。

SAHF(保存AH内容到状态标志位)将AH内容复制到EFLAGS（或RFLAGS）寄存器低字节。

&emsp;

* XCHG指令

XCHG(交换数据)指令交换两个操作数的内容，除了XCHG不使用立即数作为操作数之外，使用原则与MOV指令的使用原则是一样的。
如果想要交换两个内存的操作数，同样需要使用寄存器作为中转容器。

&emsp;

* 直接-偏移量操作数
用于访问没有显示标记的内存位置，如：

> `mov al, [array + 1]`  
> 此时源操作数是array内存位置后的下一个字节。  

但是对于多字节元素数组，想要访问数组元素时，偏移量需要考虑跨越元素较于字节倍数整数倍的字节数。
