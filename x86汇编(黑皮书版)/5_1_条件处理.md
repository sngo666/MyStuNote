## 布尔和比较指令

* 部分布尔指令

|操作|说明|
|:----:|:----:|
|AND|源操作数和目的操作数进行与操作|
|OR|源操作数和目的操作数进行或操作|
|XOR|源操作数和目的操作数进行异或操作|
|NOT|对目标操作数进行非操作|
|TEST|源操作数和目的操作数进行逻辑与操作，并适当设置CPU标示位|

&emsp;

* 复习CPU状态标志位
布尔指令影响零标志位、进位标志位、符号标志位、溢出标志位和奇偶标志位。
操作结果为0，零标志位置1。
目标操作数的最高位有进位，进位标志位置1。
符号标志位是目标操作数最高位的副本，1表示为负。
运算结果超出范围，溢出标志位置1。
运算使目标操作数低字节有偶数个1时，奇偶标志位置1.

&emsp;

* AND指令

AND指令在两个操作数的对应位之间使用与操作，并将结果存放在目标操作数之中。两个操作数不能同时存在于内存中。
>`AND destination, source`
AND指令总是会清除溢出和进位标志位，并根据目标操作数的值来修改符号标志位，零标志位和奇偶标志位。

&emsp;

* OR指令

格式与AND指令相似，同样不支持同时对两个内存中的操作数进行运算。

&emsp;

* 位映射集

可以用位向量把一个二进制中的位映射为数组中的对象。
使用NOT获取集合的补集，使用AND获取交集，并使用OR获取并集。
&emsp;

* XOR指令

XOR指令用以在两个目标操作数之间使用逻辑异或运算，即两个位相同，则结果位为0，否则为1。
XOR指令对于标志位的影响与AND运算符相同。

&emsp;

* NOT指令  

NOT指令不影响标志位。

&emsp;

* TEST指令  

TEST指令与AND指令唯一不同的地方是，TEST指令不修改目标操作数。

&emsp;

* CMP指令  

比较指令执行从目的操作数减去源操作数的隐含减法操作，并且不修改任何操作数。
CMP指令所产生的的结果呈现在标志位中，实际结果发生时，CMP指令修改溢出、符号、零、进位、辅助进位以及奇偶标志位。

1. 当比较的是两个无符号数，则进位标志位和零标志位表示的关系如表所示。

|结果|ZF|CF|
|:----:|:----:|:----:|
|目的操作数<源操作数|0|1|
|目的操作数>源操作数|0|0|
|目的操作数=源操作数|1|0|

2. 当比较的是两个有符号数，则溢出标志位、符号标志我和零标志位表示的关系如表所示。

|CMP结果|标志位|
|:----:|:----:|
|目的操作数<源操作数|SF≠OF|
|目的操作数>源操作数|SF=OF|
|目的操作数=源操作数|ZF=1|

&emsp;

* 置位和清除单个标志位

要将零标志位置1，就要把操作数与0进行TEST或AND操作；而要将零标志位清零，就要把操作数与1进行OR操作。

要将进位标志位置1，使用STC；清除进位标志位使用CLC指令。

将符号标志位置1，将操作数最高位和1进行OR操作；清除符号标志位，将操作数最高位和0进行AND操作。

将溢出标志位置1，把两个整数相加使之产生负的和数；清除溢出标志位只需要将操作数和0进行OR操作。

* 64位下的布尔命令

大多数情况下，64位模式中的64位指令与32位中指令是一样的。
如果源操作数是小于32位的常数，而目的操作数是64位寄存器或内存操作数。那么目的操作数中所有位数都会受影响：
>
> ```asm
> .data
> allones QWORD 0FFFFFFFFFFFFFFFh
> .code
> mov rax, allones
> and rax, 80h      ;rax = 0000000000000080h
> ```

但是如果源操作数是32位常数或者寄存器，那么目的操作数中只有低32位会受到影响。
当目的操作数是内存时结果是正常的。
