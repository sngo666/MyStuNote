## x86汇编基础

* 段
在汇编程序中被伪代码分割标记的片区，称为段，程序有代码段、数据段以及堆栈。

>`.data`  
>`...  ;此为数据区`  
>`.code`  
>`...  ;此为代码区`  

* 整型常量

>具体组成
>`[{+ | -}] digits [radix]`  
>注：方括号内符号可选  
&emsp;

radix(进制形式)

|h|d|b|r|q/o|t|y|
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|十六进制|十进制|二进制|编码实数|八进制|十进制(备用)|二进制(备用)|
_以字母十六进制数必须开头加个0_
&emsp;

* 实数常量

> 具体组成:  
> `[sign] integer.[integer][exponent]`  
> 其中：  
> `sign:  {+ | -}`  
> `exponent:  E[{+ | -}]integer`  
&emsp;

* 字符常量
汇编器在内存中保存的是该字符二进制ASCII码的数值。

&emsp;

* 字符串常量
字符串常量指的是用单引号或双引号包含的一个字符(含空格符)序列，允许引号嵌套。

&emsp;

###### 保留字

保留字有特殊意义并只能在其正确的上下文使用，默认情况下不区分大小写。
> 分为以下几种类别:  
>
> 1. 指令助记符，如MOV、ADD等  
> 2. 寄存器名称。  
> 3. 伪指令。  
> 4. 属性，提供变量与操作数的的大小与使用信息，如BYTE和WORD。  
> 5. 运算符。  
> 6. 预定义符号，如@data。  

&emsp;

* 标识符
标识符是由程序员选择的名称，用于标识变量、常数、子程序和代码标签，一般避免使用@与下划线开头。
&emsp;
* 伪指令
伪指令是嵌入源代码中的命令，用于定义变量、宏和子程序；为内存段分配名称；以及定义程序区段。

> 定义程序段  
> 使用.data标识一个用于定义变量的程序段。  
> 使用.stack标识的程序区段定义了运行时的堆栈，并定义大小: &ensp;`.stack 100h。`  
&emsp;

###### 指令

> 一条指令由四部分组成：标号 _label_（可选），指令助记符 _mnemonic_（必须），操作数 _operands_ 和注释 _comment_。  
> 组成：`[label：] mnemonic [operands][;comment]`  

* 标号
标号本质是一种标识符，用于指令和数据的位置标记。
数字标号的使用：

> `count DWORD 100`  
> ;定义了一个双字节变量名为count  
> `array DWORD 1024,2048`  
> &emsp;&emsp;&ensp; `DWORD 4096,8192`  
> 变量array定义了第一个数字（1024），其他数字在内存空间中紧随其后。  

程序代码区的标号必须以冒号结束，代码标号的作用是用于跳转和循环指令的目标，例：
>
>```asm  
> target:  
> mov ax,bx
> ...
> JMP target
>```  

或者用于行标号：
> `L1: mov ax,bx`  
> `L2: ...`  

&emsp;

* 指令助记符

> 对于二元指令助记符，前一个参数一般作为目标参数，后者为被源参数。

|助记符|说明|
|:----:|:----:|
|MOV| (二元)  分配（传送）数字|
|ADD| (二元) 两个数值相加|
|SUB| (二元) 从一个数值减去另一个数值|
|MUL| (二元)两数相乘|
|CALL|调用一个子程序|
|STC| (无操作数) 进位标志位置1|
|INC| (一元) 加1|
|IMUL| (三元) 后两个参数相乘放入目标参数|

_注：x86指令集不允许两个变量相加，但是允许将一个变量加入另一个寄存器，这就是经常使用`EAX`作为累加器的原因。_

* 注释

> 使用块注释  
> `COMMENT !`  
> &emsp;`This line is a comment`  
> `!`  
> 或者如`COMMENT & ... &`也是可以的。  
