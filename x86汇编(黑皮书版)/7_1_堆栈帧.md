# 堆栈帧

大多数现代编程语言在调用子程序之前都会先把参数压入堆栈，反过来，子程序也常常会把它们的局部变量压入堆栈。

* 堆栈参数

在之前的章节中，子程序接受的是寄存器参数，比如在Irvine32链接库中就是如此。本章展示子程序如何使用堆栈接受参数。32位模式下，堆栈参数总是由Windows API函数使用，在64位模式下，Windows函数可以同时接收寄存器参数以及堆栈参数。
堆栈帧的定义是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器，下为堆栈帧的创建步骤。

> 1. 被传递的实际参数，如果有，则压入堆栈。
> 2. 当子程序被调用，使子程序的返回值压入堆栈。
> 3. 子程序开始执行时，EBP被压入堆栈。
> 4. 设置EBP等于ESP。从这时开始，EBP变成了该子程序所有参数的引用基址。
> 5. 如果有局部变量，修改ESP以便在堆栈中为这些变量预留空间。
> 6. 如果需要保存寄存器，就将它们压入堆栈。

多年以来，MicroSoft在32位程序中包含了一种参数传递规则，成为fastcall，只需要简单地在调用子程序之前把参数送入寄存器，就可以提高运行效率，相反，将参数压入堆栈的执行速度就会慢一些。典型用于参数的寄存器包括EAX、EBX、ECX和EDX，少数情况下还会使用ESI和EDI。

子程序调用时，有两种常见类型的参数会入栈。
值参数(变量和常量的值)
引用参数（变量的地址）

* 值传递

当以一个参数通过数值传递时，该值的副本会被压入堆栈。
例：假设调用一个ADDTwo的子程序，向其中传递两个32位整数

> ```asm
> .data
> val1 DWROD 5
> val2 DWORD 6
> .code
> push val2
> push val1
> call ADDtwo
> ```

相当于使用伪代码`ADDTwo(val1, val2)`,参数入栈的顺序和子程序调用参数的顺序是相反的。

* 引用传递

通过引用来传递的参数包含的是对象的地址，在上例中：

> ```asm
> push OFFSET val2
> push OFFSET val1
> ```

相当于传递变量的引用。
也可以通过传递数组的偏移量提高数值传递效率，使用值来传递数组会显著降低操作速度，并且占用大量的堆栈空间。

* 访问堆栈参数

高级语言有多种方式来对函数调用的参数进行初始化和访问。在C/C++中，他们以保存EBP寄存器并使该寄存器指向栈顶的语句为开始。然后根据实际情况，他们可以把某些寄存器入栈，以便在函数返回时恢复这些寄存器的值，在函数结尾部分，恢复EBP寄存器，并用RET指令返回调用者。


