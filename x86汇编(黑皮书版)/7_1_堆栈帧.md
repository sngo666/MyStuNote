# 堆栈帧

大多数现代编程语言在调用子程序之前都会先把参数压入堆栈，反过来，子程序也常常会把它们的局部变量压入堆栈。

* 堆栈参数

在之前的章节中，子程序接受的是寄存器参数，比如在Irvine32链接库中就是如此。本章展示子程序如何使用堆栈接受参数。32位模式下，堆栈参数总是由Windows API函数使用，在64位模式下，Windows函数可以同时接收寄存器参数以及堆栈参数。
堆栈帧的定义是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器，下为堆栈帧的创建步骤。

> 1. 被传递的实际参数，如果有，则压入堆栈。
> 2. 当子程序被调用，使子程序的返回值压入堆栈。
> 3. 子程序开始执行时，EBP被压入堆栈。
> 4. 设置EBP等于ESP。从这时开始，EBP变成了该子程序所有参数的引用基址。
> 5. 如果有局部变量，修改ESP以便在堆栈中为这些变量预留空间。
> 6. 如果需要保存寄存器，就将它们压入堆栈。

多年以来，MicroSoft在32位程序中包含了一种参数传递规则，成为fastcall，只需要简单地在调用子程序之前把参数送入寄存器，就可以提高运行效率，相反，将参数压入堆栈的执行速度就会慢一些。典型用于参数的寄存器包括EAX、EBX、ECX和EDX，少数情况下还会使用ESI和EDI。

子程序调用时，有两种常见类型的参数会入栈。
值参数(变量和常量的值)
引用参数（变量的地址）

* 值传递

当以一个参数通过数值传递时，该值的副本会被压入堆栈。
例：假设调用一个ADDTwo的子程序，向其中传递两个32位整数

> ```asm
> .data
> val1 DWROD 5
> val2 DWORD 6
> .code
> push val2
> push val1
> call ADDtwo
> ```

相当于使用伪代码`ADDTwo(val1, val2)`,参数入栈的顺序和子程序调用参数的顺序是相反的。

* 引用传递

通过引用来传递的参数包含的是对象的地址，在上例中：

> ```asm
> push OFFSET val2
> push OFFSET val1
> ```

相当于传递变量的引用。
也可以通过传递数组的偏移量提高数值传递效率，使用值来传递数组会显著降低操作速度，并且占用大量的堆栈空间。

* 访问堆栈参数

高级语言有多种方式来对函数调用的参数进行初始化和访问。在C/C++中，他们以保存EBP寄存器并使该寄存器指向栈顶的语句为开始。然后根据实际情况，他们可以把某些寄存器入栈，以便在函数返回时恢复这些寄存器的值，在函数结尾部分，恢复EBP寄存器，并用RET指令返回调用者。

* 程序地址空间

对于每个函数来说，都有一个ESP(栈顶指针)和EBP(栈底指针)，这是抽象意义上的。即每个函数都有自己的栈顶和栈底。
程序在运行时从高地址向低地址的区块划分依次为：
栈区：普通变量存放地址空间
共享区：堆栈共享区。
堆区：动态开辟变量存储空间。
静态全局区：静态变量存放地址空间。
代码区：代码存放空间。
> _非常重要的概念！_  

在程序执行最开始应该是调用main函数，此时在栈区应该为main函数开辟一个存储空间，并且有一个ESP和EBP指向这篇存储空间，另外还有PC指向代码区中main函数中的下一条指令。
在执行调用的函数时，首先将EBP压入栈内，接着把ESP的值赋予EBP，这样调佣者的栈顶就成了被调用者的栈底。
在将栈顶和栈底归位之后，仅仅消除了局部变量参数的占用空间，对于传递进的参数空间并没有平衡，因此在函数主体结束后，根据STDCALL的调用约定，需要平衡栈内空间以免造成内存泄漏。

最后讨论关于返回地址的问题，当函数体结束所有命令，需要使用ret将栈顶的地址弹出到PC用以返回调用者的程序位置，书中给出的结构是返回地址位于最先前的地方，即在录入的参数变量之前，也就是说，当执行到ret或retn指令时，必须保证栈顶指针指向调用者的地址，栈顶指针必须指向一个有效的内存地址。另外，ret的本质是跳转指令。

关于调用约定请参考"加密与解密"目录下的"32位软件逆向技术"下相关目录。

* LEA指令

LEA指令返回间接操作数的地址。相较于OFFSET，OFFSET只适用于编译时已知的地址。以下指令是无效的`mov esi, OFFSET[ebp-30]`但是可以`lea esi, [ebp-30]`，如果允许的话。

* ENTER和LEAVE指令

ENTER指令为被调用过程自动创建堆栈帧，具体分为三个操作：

1. 把EBP入栈`push ebp`
2. 把EBP设置为堆栈帧的基址`mov ebp, esp`
3. 为局部变量保留空间`sub esp, numbytes`

ENTER有两个操作数，第一个是numbytes，第二个是nestinglevel。numbytes总是向上取整为4的倍数，以便于ESP对齐双字边界。nestinglevel确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。

如果想要使用ENTER指令，最好和LEAVE搭配使用。而LEAVE指令仅仅是反转了ENTER指令所执行的操作。

* LOCAL伪指令

LOCAL伪指令作为ENTER指令的高级替补，声明一个或多个变量，并定义其属性大小，使用逗号分割表项，可选为跨越多行，格式为`label:type`

在MASM中的呈现是，划分栈区空间存储局部变量，所以本质上还是ENTER的替补。

* x64调用规范

1. 由于地址长64位，因此CALL指令将RSP寄存器的值减去8
2. 长度不足64位的参数不进行零扩展，因此其高位的值不确定。
3. 如果返回值的大小小于等于64位，那么它必须放在RAX寄存器中。
4. 由调用者负责在栈区分配至少32字节的影子空间以供被调用者将寄存器值存放在内。
5. 调用子程序时，RSP必须对齐16字节边界，CALL指令将8字节的返回值地址压入栈，因此主调程序除了把堆栈指针减去32以存放寄存器参数之外，还要减去8。子程序执行结束后，主调程序负责从运行时堆栈移除所有的参数和影子空间。大于64位的返回值地址存放在运行时堆栈。
6. 寄存器RBX,RBP,RDI,RSI,R12,R13,R14,R15的值必须由子程序保管。

* 递归

基本结构没什么好说的。下面简要描述一下再递归过程中堆栈的情况：

```asm
Factorial PROC
            push ebp
            mov ebp, esp
            mov eax, [ebp+8]
            cmp eax, 0
            ja L1
            mov eax, 1
            jmp L2
L1:         dec eax
            push eax
            call Factorial
ReturnFact: mov ebx, [ebp+8]
            mul ebx
L2:         pop ebp
            ret 4
Factorial ENDP
END main
```

每次调用Factorial，必须先将eax压入栈内，在下一层调用中，首先根据call将调用者的返回地址压入栈内，然后将EBP压入栈内，当从栈中提取eax时，此时ebp和esp均指向调用者的函数栈底。
再经过本次递归调用，若乘数大于0，则继续将乘数减1，并压入栈内，然后进行下一轮的递归。
