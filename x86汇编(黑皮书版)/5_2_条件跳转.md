# 条件跳转

## 条件结构

在x86指令集中，我们使用比较和跳转的组合实现条件选择性的结构跳转。执行一个语句分为两个部分：使用CMP、AND和SUB操作来修改CPU状态标志位，再使用条件跳转指令来测试标志位，并产生一个新地址的分支。

* JZ指令

使用JZ指令时，判断零标志位中的值，若为0，则跳转到指令操作数中的指定程序段，使用格式如下：
>
> ```asm
> cmp eax. 0
> jz L1
> ...
> jz: ...
> ```

&emsp;

* jnz指令

使用格式与jz指令类似，不过判定条件为当零标志位为非零时，进行程序语句的跳转。

&emsp;

* Jcond指令

当状态标志位为真时，条件跳转指令就分支到目标标号，执行目标语句。cond是指一个或多个状态标志位的标志位条件，例如JC与JNC，分别用于判断进位标志位在为零或非零时是否进行跳转。

以下为基于特定标志位的跳转：
| 助记符 |    说明    | 标志位/寄存器 |
| :----: | :--------: | :-----------: |
|   JZ   |  为零跳转  |    ZF = 1     |
|  JNZ   |  非零跳转  |    ZF = 0     |
|   JC   |  进位跳转  |    CF = 1     |
|  JNC   | 无进位跳转 |    CF = 0     |
|   JO   |  溢出跳转  |    OF = 1     |
|  JNO   | 无溢出跳转 |    OF = 0     |
|   JS   | 有符号跳转 |    SF = 1     |
|  JNS   | 无符号跳转 |    SF = 0     |
|   JP   | 偶校验跳转 |    PF = 1     |
|  JNP   | 奇校验跳转 |    PF = 0     |

&emsp;

* 相等性比较

还有一些跳转指令是基于相等性评估的跳转指令，如下：

| 助记符 |           说明            |
| :----: | :-----------------------: |
|   JE   |   CMP指令两个操作数相等   |
|  JNE   | CMP指令中两个操作数不相等 |
|  JCXZ  |       CX = 0时跳转        |
| JECXZ  |       ECX = 0时跳转       |
| JRCXZ  | RCX = 0时跳转（64位模式） |

JE指令在多数情况下能被JZ代替，但是使用JE能够很好地说明意图，增加代码可读性。

&emsp;

* 无符号数的比较

部分意义不明的指令已省略。

| 助记符 |     说明     |
| :----: | :----------: |
|   JA   |   大于跳转   |
|   JB   |   小于跳转   |
|  JAE   | 大于等于跳转 |
|  JBE   | 小于等于跳转 |

&emsp;

* 有符号数比较

| 助记符 |     说明     |
| :----: | :----------: |
|   JG   |   大于跳转   |
|   JL   |   小于跳转   |
|  JGE   | 大于等于跳转 |
|  JLE   | 小于等于跳转 |

在上述两类比较中还有一种JNX指令，X分别对应A、B、G、L，意思为不（大于/小于）虽然实际逻辑上与小于等于/大于等于类似，但是能够显著增加代码可读性。

&emsp;

* 条件循环指令

LOOPZ（为零跳转）与LOOP的指令相同（依然使用循环计数器），只是有一个附加条件：为零控制转向目的标号（所以必须满足循环计数器有余额且零标志位为1），零标志位必须置1。使用格式如下：
> `loop destination`

LOOPE（相等跳转）指令相当于LOOPZ，他们有相同的格式。这两句语句不影响任何状态标志位，32位模式下ECX依然是循环计数器。

LOOPNZ（非零跳转指令）与LOOPZ相对应。当ECX中无符号数值大于零且零标志位等于零时继续循环。
LOOPNE（不等跳转指令），上同。

&emsp;

* 块结构的IF语句

在汇编语言中对于IF选择结构的实现是通过几个步骤来完成的，首先对布尔表达式求值，这样会影响到CPU某个状态标志位，然后根据相关CPU状态编制为的值，构建一系列跳转控制。


&emsp;

* 表驱动选择

表驱动选择使用表来代替多路选择结构的一种方法。此方法需要构建一片包含包含查询值和标号的连续空间，然后使用循环来检索这个表。格式如下：
>
> ```asm
> .data
> CaseTable BYTE 'A'
>           DWORD Process_A
>           BYTE 'B'
>           DWORD Process_B
> ...
> ```

在定义一个分块后使用`EntrySAize = ($ -CaseTable)`以获取每个分块的大小，并在定义结束时再一次计算偏移量能够获得总大小，从而求出分块的数量方便遍历。
