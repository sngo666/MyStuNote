# 加减法与数据相关指令

* INC与DEC指令
  
为一元指令，分别表示寄存器或内存操作数加1或者减1，根据目标操作数的值，溢出标志位、零标志位、辅助进位标志位和奇偶标志位会发生变化，但是进位标志位不会发生变化。

&emsp;

* ADD指令

二元指令，将长度相同的源操作数加入目的操作数。格式如下：
>`ADD dest,source`

状态标志位会根据存入的目标操作数改变而变化。

&emsp;

* SUB指令

SUB指令从目的操作数中减去源操作数，其对于操作数的要求与`MOV`和`ADD`的相同。格式如下：
>`SUB dest,source`

状态标志位会根据存入的目标操作数改变而变化。

&emsp;

* NEG（非）指令

一元指令，通过把操作数转换为其二进制编码，将操作数的符号取反加1。从十进制角度来说，其值相当于取负。
_我所使用的电子版书上仅写的是取反，我上网查证应该是取反并加1。_

状态标志位会根据存入的目标操作数改变而变化。

&emsp;

* 加减法影响到的标志位

通过使用CPU状态标志位的值，获取执行算术指令时的具体情况。同时，这些状态值也能够触发基本的程序逻辑工具。

1. 进位标志位`CY`意味着无符号整数的溢出，例：若算术结果大于1111 1111，则将进位标志位置1.
2. 溢出标志位`OV`意味着有符号整数的溢出，例：若目的操作数为一个字长，结果小于`-32768`时，溢出标志位置1.
3. 零标志位`ZR`意味着算术结果为0。
4. 符号标志位`PL`用于显示操作产生的结果符号，若算术结果为复述，则将该符号标志位置1.
5. 奇偶标志位`PE`，在一条算术指令或布尔运算指令执行后，立即判断操作数最低有效字节中的1是否为偶数。(有几个1。)
6. 辅助进位标志位`AC`置1时，意味着目的操作数最低有效字节中位3有进位。

&emsp;

* 有效性测试

当两个正数相加，结果为负时，或两个负数相加结果为正数时，说明发生了溢出情况。

如果NEG指令的目的操作数不能正确存储，则该结果是无效的，如：当`AL`中存放的是`-128`时，取反的对象无效，则这个值无法存入`AL`。

&emsp;

## 与数据相关的运算符和伪指令

本次介绍如下几个运算符和伪指令：

1. OFFSET运算符。
2. PTR运算符。
3. TYPE运算符。
4. LENGTHOF运算符。
5. SIZEOF运算符。
6. LABEL伪指令。

&emsp;

* OFFSET运算符

该运算符为一元运算符，用于返回数据标号的偏移量。偏移量以字节计算，表示该数据标号距离数据段的起始距离。例：

>```asm
>.data
>bVal BYTE ?
>cVAL DWORD ?
>```
>
>定义如上变量时，假设`bVal`在偏移量为0000 0400h的位置上，则有如下结果：  
>
>```asm
>mov esi, OFFSET bVal       ;ESI = 0000 0400h
>mov esi, OFFSET cVAL       ;ESI = 0000 0401h
>```

OFFSET指令也可以直接用于直接-偏移量操作数，如：
>
>```asm
>.data 
>Val  BYTE 10, 20, 30
>.code
>mov esi, OFFSET Val + 2 
>```

此时esi存储的是常数`30`的偏移量。

&emsp;

* ALIGN伪指令

用于将一个变量对齐边界，用法如下:
>`ALIGN bound`
bound可选的值有1、2、4、8、16。当段的偏移地址为0040 0400h时，例:
>
>```asm
>Val2 BYTE ?          ;0040 0400h
>ALIGN 2
>Val1 WORD ？         ;0040 0402h
>```
>
为什么要对齐数据，因为对于存储于偶地址和奇地址的数据来说，CPU处理偶地址的速度要快很多。

&emsp;

* PTR运算符

PTR运算符用于重写一个已经被声明过的操作数的大小类型，当使用不同于汇编器设定的大小属性来访问操作数，那么必须要使用这个运算符。

例：
>
>```asm
>.data
>VAL DWORD 12345678h
>.code
>mov ax,VAL

由于操作数大小不同，上述指令的使用是非法的，但可以使用如下方式，将`VAL`的末四位`5678h`存入`ax`。
>`mov ax, WORD PTR VAL`

_为什么送入AX的不是1234h？_
因为x86处理器采用的是小端顺序，即低位字节存放于变量的起始地址。所以`VAL`的偏移地址中存放的是`78h`，若取一个字节，得到的结果为`5678h`,而`VAL + 1`的偏移地址中存放的是`56h`,取字节时为`3456h`。

如何将两个较小的值送入较大的目的操作数：
>
>```asm
>.data
>wordList WORD 5678h,1234h
>.code
>mov eax, DWORD PTR wordList     ;eax = 12345678h
>```

先将`5678h`送入eax的低字节部分，再将`1234h`复制进高字节位。

* TYPE运算符

用于返回变量单个元素的大小，结果以字节为单位进行计算。
对应结果如下：
|类型|结果|
|:----:|:----:|
|BYTE|1|
|WORD|2|
|DWORD|4|
|QWORD|8|

&emsp;

* LENGTHOF运算符

LENGTHOF运算符用于计算数组中元素的个数，例：

>```asm
>.data
>val1 BYTE 10,20,30          ;3
>val2 WORD 30 DUP(?),0,0     ;32
>val3 BYTE "1234",0          ;5
>val4 DWORD 1,2,3,4          ;4
>```

如果定义占据了多个程序行，那么LENGTHOF运算符只针对第一行定义的数据。这里的解决方法是在第一行结尾加入逗号，在第二行继续声明。

&emsp;

* SIZEOF运算符
  
SIZEOF运算符是一元运算符，返回值相当于LENGTHOF与TYPE返回值的乘积，单位是字节。

&emsp;

* LABEL伪指令

LABEL伪指令可以插入一个符号，并定义其大小属性，但是部位这个标号分配存储空间，该伪指令可以使用所有标准大小属性，例：

>```asm
>.data
>val16 LABEL WORD
>val32 DWORD 12345678h     ;val = 5678h
>```
>
也可以将两个较小的整数组成一个较大的整数：

>```asm
>.data
>long32 LABEL DWORD
>val1 WORD 1234h
>val2 WORD 5678h          ;long32 = 1234 5678h
>```
