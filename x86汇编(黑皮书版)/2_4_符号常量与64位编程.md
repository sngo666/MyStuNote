## 符号常量与64位编程

##### 符号常量

定义：通过为整数表达式或文本指定标识符来创建符号常量。一方面，符号常量并不占用预留存储空间，另一方面，在程序运行时其内容也不会改变。

> 使用等号伪指令`=`将一个符号名称与一个整数表达式连接起来。
> `name = expression`
> 意义：用于增加代码可读性。

&emsp;

* 重定义

使用`=`定义的符号常量，在同一程序内可以被重新定义，在汇编器预处理阶段，符号常量会根据汇编器对于源代码的处理顺序来改变数值。

&emsp;

* 当前地址计数器($)

使用`$`运算符返回当前程序语句的偏移量。
> 例:
>
> ```asm
> list BYTE 10,20,30,40
> listSize = ($ - list)
> ```
>
> 在上述使用情况中，对于`$`调用必须紧跟标识符`list`的定义之后，原因是`$`在程序执行过程中是动态变化的。

当要计算的数组元素单位不是单个字节时，需要将偏移量除以单个元素的字节倍数以获取正确的元素数量。

&emsp;

* EQU伪指令

EQU伪指令将一个符号名称和一个整数表达式或者任意文本连接起来，格式为：
>
> ```asm
> name EQU expression
> name EQU symbol
> name EQU <text>
> ```
>
> 上述语句中，`expression`必须是一个有效的整数表达式，`symbol`必须是一个已经使用`=`或`EQU`定义过的符号常量，而`text`可以是任意文本，被调用时会完全替代。

&emsp;

* TEXTEQU伪指令

类似于EQU，目的是创建一个文本宏，格式为：
>
> ```asm
> name TEXTEQU <text>
> name TEXTEQU textmacro
> name TEXTEQU &constExpr
> ```
>
> 上述语句中`text`为指定任意文本，`textmacro`为已有文本宏的内容，而最后一种是分配的整数表达式。

&emsp;

##### 64位编程

* 代码差别

1. 在64位汇编编程中，无需写如下代码：
>
> ```asm
> .386
> .model flat,stdcall
> .stack 4096

2. 在64位程序中，使用`PROTO`关键词的语句不带参数，如下：

>`ExitProcess PROTO`

3. 64位的程序不支持`INVOKE`伪指令，使用如下指令结束程序：
>
> ```asm
> mov ecx,0
> call ExitProcess
> ```

4. `END`无需指定程序入口点，而32位则需要指定。
