## 定义数据类型

* 内部数据类型

> 根据数据的类型，大小、是否有符号以及实数还是整数判断如何描述其类型。
> 数据定义语法：
> `[name] directive initializer [,initializer]...`

|类型|用法|
|:----:|:----:|
|BYTE|8位无符号|
|SBYTE|8位有符号，S表示有符号，下同|
|WORD|16位无符号|
|DWORD|32位无符号|
|FWORD|48位整数(保护模式中远指针)|
|QWORD|64位整数(Q代表4)|
|TBYTE|80位整数，T代表10个字节|
|REAL4|32位IEEE短实数|
|REAL8|64位IEEE短实数|
|REAL10|80位IEEE短实数|

>如果希望不对变量进行初始化，可以用符号`?`作为变量的初始值。

&emsp;

* 多初始值
当在一个数据定义中使用了多个初始值，其标号只能指出第一个初始值的偏移量。

> 例：
>
> ```asm
> list BYTE 10,20,30,40
> ```
>
> 此时标号`list`仅指出`10`的地址，后续数字在地址上依次排列。
> 或者如：
>
> ```asm
> list BYTE 10,20,30,40
>   BYTE 50,60,70,80
>   BYTE 81,82,83,84
>```
>
> 在单个数据定义中，初始值可以有不同的的基数，也表达相同的意思，字符和字符串常量可以自由组合。

&emsp;

* 定义字符串
最常见的定义字符串方式是用一个空字节（值为0）作为结束标记，成为 _以空字节结束_ 的字符串。

> 例：
>
> ```asm
> greetings BYTE "Hello World!",0
> ```
>
> 在这种情况下，每个字符占一个字节的空间

此外，在十六进制中`0Dh`与`0Ah`也被称为CR/LF _回车换行符_ 或 _行结束符_。

&emsp;

* 行连续字符
使用`/`把两行的源码连接成一条语句。

&emsp;

* DUP操作符
DUP操作符使用一个整数表达式作为计数器实现批量化处理。

> 例:
>
> ```asm
> BYTE 20 DUP(20)
> BYTE 20 DUP(?)
> BYTE 4 DUP("STACK")
> ```
>
> 以上均为对于20字节空间的初始化。

&emsp;

* 定义DWORD与SDWORD数据

> 正常定义方式：
>
> ```asm
> val1 DWORD 1234567
> ```
>
> 也可以使用传统的数据类型进行定义：
>
> ```asm
> val1 DD 1234567
> ```
>
> 此外DWORD还可用于声明一种变量，这种变量包含的是另一种变量的32位偏移：
>
> ```asm
> pVAl DWORD val1
> ```

&emsp;

* 定义QWORD数据

> 传统的DQ伪指令也可用于四字数据：
>
> ```asm
> val2 DQ 12356783456789
> ```

_注：上文所提到的`字`指的是`WORD`即一个双字节单位，并非术语中的字节。_

&emsp;

* 定义TBYTE数据
Intel把一个压缩的二进制编码的十进制整数（BCD码）存放在一个10字节的包中，每个字节包含两个十进制数字，在最高位的字节中，用于存储数据的符号，最高位为1时，即80h，即为负数，反之00h则表示整数，那么该10字节编码的存储范围是正负的十八位十进制整数。

> 请注意，在定义TBYTE变量时，汇编器无法自动转换十进制为BCD码，所以请使用十六进制常量。另一个原因则是MASM将常数编码转换为二进制编码，而不是BCD码。

将实数编码转换为BCD码无法直接转换，需要经由浮点寄存器处理：
>
> ```asm
> .data 
> val REAL8  1.5
> BCDval TBYTE ?
> .code 
> fld val
> fbstp BCDval
> ```
>
> 如上，`fld`用于将变量加载进浮点寄存器，而`fbstp`负责将寄存器内容向上取整并载入`BCDval`中。

&emsp;

* 定义浮点类型

|REAL4|REAL8|REAL10|
|:----:|:----:|:----:|
|单精度实数|双精度实数|扩展精度实数|

&emsp;

* 小端顺序和大端顺序

使用一个例子理解小端和大端顺序：

> 考虑一个双字`12345678h`如果将其存放在偏移量为0000的位置，则产生的效果分别为：

|地址|小端表示|
|:-----:|:----:|
|0000|78|
|0001|56|
|0002|34|
|0003|12|
_数据靠后往小了放_

|地址|大端表示|
|:-----:|:----:|
|0000|12|
|0001|34|
|0002|56|
|0003|78|
_数据靠后往大了放_

&emsp;

* 使用伪指令批量化初始化

当定义大量未初始化数据时，使用`.data?`下的数据段减少了编译程序的的大小。
此外，汇编器允许程序中在代码和数据段之间来回切换，当想要一个只能在代码段中局部使用的数据，可如下编写：
>
>```asm
>.code 
>mov eax,ebx
>.data
>temp DWORD ?
>.code 
>mov temp,eax
>...
>```
>
在上述程序的汇编过程中，MASM会将temp放在数据段中，并与代码段分隔开。
