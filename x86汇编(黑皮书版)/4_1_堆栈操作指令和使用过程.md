## 堆栈操作指令和使用过程

过程，也叫作子程序或者函数。本章会提供两个代码库，分别为Irvine32和Irvine64，包含了有用的工具用以简化输入和输出。

##### 堆栈操作

堆栈结构(LIFO)不多赘述，32位模式中，运行时堆栈是内存数组，CPU使用ESP(扩展堆栈指针),其存放的是栈中某个位置的32位偏移量，ESP主要通过CALL、RET、PUSH和POP控制,ESP指向以下的区域在逻辑上都是空白的。
>_ESP总是指向添加(压入)到栈顶的最后一个数值，且运行时堆栈在内存中是向下生长的。_

&emsp;

* PUSH和POP指令

均为一元指令。
PUSH指令首先减少ESP的值(向下生长)，再将源操作数复制到堆栈。根据操作数的大小，ESP减去对应的字节数。

> ```asm
> PUSH reg/mem16
> PUSH reg/mem32
> PUSH imm32
>```

POP指令先把ESP指向的堆栈顶部元素复制到一个16位或32位目的操作数中，再增加ESP的值(向下生长)，根据元素的大小，加上对应的字节数。

&emsp;

* PUSHFD和POPFD指令

PUSHFD指令将32位EFLAGS寄存器内容压入堆栈，而POPFD指令将栈顶单元内容弹出到EFLAGS寄存器。
> 为什么需要这样的指令？  
> 不能用MOV指令把一个32位寄存器内容复制给一个变量，因此PUSHFD可能就是保存标志位的最佳途径，有时候保存标志位的副本是非常有用的。  
> 一种不容易出错的保存和恢复标识寄存器的方法是，在压入栈后，立即保存给变量。

&emsp;

* PUSHAD、PUSHA、POPAD和POPA

不需要操作数。
PUSHAD指令按照EAX、ECX、EDX、EBX、ESP(执行本次压栈之前的值)、EBP、ESI和EDI的顺序，将所有32位通用寄存器压入堆栈。POPAD指令则按照相反的指令顺序将同样的寄存器。
与之相似，PUSHA按照顺序AX、CX、DX、BX、SP、BP、SI、DI将16位通用寄存器压入堆栈。POPA则将其以相反的顺序弹出栈，在16位模式，只能使用这两个指令。

&emsp;

##### 定义并使用过程

* PROC伪指令

过程可以非正式地定义为 _由返回语句结束的已命名的语句块_ 过程使用PROC和ENDP伪指令来定义，且必须为其分配一个名字(标识符)。
>
> ```asm
> main PROC
> ...
> main ENDP
> ```
>
> 上述过程定义了名为main的过程(主过程)。

当在程序启动之外创建一个过程，就需要使用RET命令来结束它。RET强制CPU返回到该过程被调用的位置。
>
> ```asm
> main PROC
> ...
>   ret
> main ENDP
> ```

默认情况下，标号只在其被定义的过程中可见。这个规则经常会影响到跳转和循环，故名为destination的标号必须与JMP指令位于同一过程中：
>`jmp destination`
解决这一限制的方法是定义全局标号，即在名字后面加双冒号(::)。
>`destination::`

通常使用EAX返回32位值，AX返回16位值，AL返回8位的值。

* CALL和RET指令
