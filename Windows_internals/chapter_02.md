# chapter_02 System architecture

## 要求和设计目标

1989年提出的windowsNT设计目标：

* 提供一个真正的32位、抢占式、可重入式虚拟内存操作系统。
* 在多个硬件体系结构和平台上运行。
* 在对称多处理系统上运行和扩展良好。
* 成为一个出色的分布式计算平台，既可以作为网络客户端，也可以作为服务器。
* 运行大多数现有的16位MS-DOS和Microsoft Windows 3.1应用程序。
* 满足政府对POSIX 1003.1合规性的要求。
* 满足政府和行业对操作系统安全性的要求。
* 通过支持Unicode，可以轻松适应全球市场。
(感觉大部分都是废话)

## 操作系统型号

在大多数多用户操作系统中，应用程序与操作系统本身是分开的。操作系统内核代码以特权处理器模式（在本书中称为内核模式）运行，可以访问系统数据和硬件。应用程序代码以非特权处理器模式（称为用户模式）运行，具有有限的可用接口集，对系统数据的访问权限有限，并且不能直接访问硬件。当用户模式程序调用系统服务时，处理器执行一条特殊指令，将调用线程切换到内核模式。当系统服务完成时，操作系统将线程上下文切换回用户模式，并允许调用方继续。

Windows与大多数UNIX系统类似，因为它是一个单片操作系统，因为大部分操作系统和设备驱动程序代码共享相同的内核模式保护内存空间。这意味着任何操作系统组件或设备驱动程序都可能损坏其他操作系统组件正在使用的数据。然而，正如您在第1章“概念和工具”中看到的那样，Windows通过WHQL等程序和KMCS强制执行来加强第三方驱动程序的质量和限制其来源，同时还结合了其他内核保护技术，如基于虚拟化的安全性、设备保护和超级保护功能，从而解决了这一问题。

WHQL: Microsoft Windows Hardware Quality ,微软的Windows 硬件设备质量实验室，是创建并管理用于测试系统和外围设备与微软Windows操作系统的硬件兼容性测试（HCK&HLK)工具。
KMCS: Kernal Mode Code Signing,仅允许加载由开发人员发布和经过数字签名的设备驱动程序，这些开发人员已经过为数不多的证书颁发机构 (CA) 之一的审查。

尽管Windows普遍使用对象来表示共享系统资源，但它并不是严格意义上的面向对象系统。为了便于移植，大多数内核模式的操作系统代码都是用C编写的。C编程语言不直接支持面向对象的构造，如多态函数或类继承。因此，Windows中基于C的对象实现借鉴了特定面向对象语言的特性，但并不依赖于这些特性。

## 体系结构概述

体系结构的简化版本如图所示。但这并非包含全部内容，比如网络组件和各种类型的设备驱动程序分层。

 ![Alt](./res/pic02_01.png#pic_center)

用户模式线程在专用进程地址空间中执行，系统进程、服务进程、用户进程和环境子系统每个都有自己的私有进程地址空间。
严格来说，系统管理程序仍然以与内核相同的CPU特权级别（0）运行，但由于它使用专门的CPU指令（英特尔上的VT-x，AMD上的SVM），它既可以将自己与内核隔离，也可以监视内核（和应用程序）。由于这些原因，你可能经常听到“R1”这个词(并不严谨)。

在Windows下，用户应用程序不会直接调用本机Windows操作系统服务。相反，它们通过一个或多个子系统动态链接库（DLL）。子系统dll的作用是将记录的函数转换为适当的内部（通常是未记录的）本机系统服务调用，这些调用主要在Ntdll.dll中实现。这种转换可能涉及也可能不涉及向为用户进程提供服务的环境子系统进程发送消息。

Windows的内核模式组件包括以下内容：

* Executive
  Windows executive包含基本操作系统服务，如内存管理、进程和线程管理、安全、I/O、网络和进程间通信。
* The Windows kernel
  这包括低级操作系统功能，如线程调度、中断和异常调度以及多处理器同步。它还提供了一组例程和基本对象，其余的执行人员使用这些例程和对象来实现更高级别的构造。
* Device drivers
  这既包括将用户I/O功能调用转换为特定硬件设备I/O请求的硬件设备驱动程序，也包括非硬件设备驱动，如文件系统和网络驱动程序。
* The Hardware Abstraction Layer (HAL)
  这是一层代码，将内核、设备驱动程序和Windows执行程序的其余部分与特定于平台的硬件差异（如主板之间的差异）隔离开来。
* The windowing and graphics system
  这实现了图形用户界面（GUI）功能（更广为人知的是Windows user和GDI功能），例如处理窗口、用户界面控件和绘图。
* The hypervisor layer
  这是由一个单独的组件组成的：系统管理程序本身。此环境中没有驱动程序或其他模块。也就是说，系统管理程序本身由多个内部层和服务组成，例如它自己的内存管理器、虚拟处理器调度器、中断和定时器管理、同步例程、分区（虚拟机实例）管理和分区间通信（IPC）等等。

 ![Alt](./res/pic02_02.png#pic_center)

### 可移植性

Windows通过两种主要方式实现了跨硬件体系结构和平台的可移植性：

* 采用分层设计
  Windows采用分层设计，系统的底层部分是处理器体系结构特定的或平台特定的，它们被隔离到单独的模块中，这样系统的上层就可以免受体系结构之间和硬件平台之间的差异的影响。提供操作系统可移植性的两个关键组件是内核（包含在Ntoskrnl.exe中）和HAL（包含在HAL.dll中）。
* 通过C语言
  绝大多数Windows都是用C编写的，有些部分是用C++编写的。汇编语言仅用于操作系统中需要与系统硬件直接通信的部分（如中断陷阱处理程序）或对性能极为敏感的部分（例如上下文切换）。汇编语言代码不仅存在于内核和HAL中，还存在于核心操作系统中的其他一些地方（例如实现互锁的例程。

### 对称多处理

多任务处理是一种操作系统技术，用于在多个执行线程之间共享一个处理器。然而，当一台计算机有多个处理器时，它可以同时执行多个线程。因此，尽管多任务操作系统似乎只同时执行多个线程，但多处理操作系统实际上做到了这一点，在其每个处理器上执行一个线程。

Windows的关键设计目标之一是它必须在多处理器计算机系统上运行良好。Windows是一个对称多处理（SMP）操作系统。没有主处理器——操作系统和用户线程可以安排在任何处理器上运行。
此模型与非对称多处理(ASMP)形成对比，在ASMP中，操作系统通常选择一个处理器来执行操作系统内核代码，而其他处理器只运行用户代码。

Windows还支持四种现代类型的多处理器系统：多核、同时多线程(SMT)、异类和非一致内存访问(NUMA)。

每个逻辑处理器都有自己的CPU状态，但执行引擎和板载缓存是共享的。这允许一个逻辑CPU在另一个逻辑CPU停止时取得进展。如“四核八线程”。这表明最多可以调度8个线程，因此存在8个逻辑处理器。增强调度算法以优化启用SMT的机器，例如通过在空闲的物理处理器上调度线程而不是在其他逻辑处理器繁忙的物理处理器上选择空闲的逻辑处理器。
Windows本身也支持多核系统。因为这些系统有真正的物理核心(只是在相同的封装上)，Windows中的原始SMP代码将它们视为独立的处理器，除了某些记帐和识别任务(如许可，简要描述)，这些任务区分相同处理器上的核心和不同插槽上的核心。
Windows的ARM版本还支持一种称为异质多处理的技术，其在此类处理器上的实现称为Big.LITTLE。这种基于SMP的设计与传统设计的不同之处在于，并非所有处理器核心的能力都相同，但与纯粹的异质多处理不同，它们仍然能够执行相同的指令。因此，不同之处在于时钟速度和各自的满载/空闲功耗，允许一组较慢的内核与较快的内核配对。

Windows最初的设计并没有考虑到特定的处理器数量限制，为了方便和效率，Windows确实会在位掩码(有时称为亲和性掩码)中跟踪处理器(总数、空闲、繁忙和其他此类详细信息)，位掩码的位数与计算机的本机数据类型(32位或64位)相同。这允许处理器直接操作寄存器内的位。
由于这一事实，Windows系统最初受到本地CPU数量的限制，因为亲和力掩码不能任意增加。为了保持兼容性以及支持更大的处理器系统，Windows实现了一种称为处理器组的高阶结构。处理器组是一组处理器，它们都可以由单个亲和位掩码定义，内核和应用程序可以选择它们在亲和性更新期间引用的组。

### 可伸缩性

多处理器系统的关键问题之一是可伸缩性。要在SMP系统上正确运行，操作系统代码必须遵守严格的指导方针和规则。与单处理器系统相比，多处理系统中的资源争用和其他性能问题更为复杂，必须在系统设计中加以考虑。
Windows整合了几个对其作为多处理器操作系统的成功至关重要的功能：

* 能够在任何可用的处理器上以及同时在多个处理器上运行操作系统代码。
* 单个进程内的多个执行线程，每个线程可以在不同的处理器上同时执行。
* 内核以及设备驱动程序和服务器进程内的细粒度同步，这允许更多组件在多个处理器上并发运行
* 编程机制，例如I/O完成端口，有助于高效实施可扩展Wellon多处理器系统的多线程服务器进程

### 客户端和服务器版本之间的差异

* Server 2016数据中心和标准版基于核心（而非基于套接字）的定价。
* 支持的逻辑处理器总数。
* 对于服务器系统，允许运行的Hyper-V容器的数量（客户端系统仅支持基于命名空间的Windows容器）
* 支持的物理内存量。
* 支持的并发网络连接数。
* 支持多点触控和桌面合成。
* 支持BitLocker、VHD引导、AppLocker、Hyper-V等功能，以及100多个其他可配置的许可策略值。
* indows Server版本附带的分层服务，而客户端版本不附带（例如，目录服务、Host Guardian、Storage Spaces Direct、屏蔽虚拟机和群集）。

 ![Alt](./res/pic02_03.png#pic_center)

有这么多不同版本的Windows，每个版本都有相同的内核映像，系统如何知道启动的是哪个版本？通过查询HKLM\SYSTEM\CurrentControlSet\Control\ProductOptions项下的注册表值ProductType和ProductSuiteu。ProductType用于区分系统是客户端系统还是服务器系统（任何类型）。这些值是根据前面描述的许可策略文件加载到注册表中的。
这可以从用户模式VerifyVersionInfo函数或使用内核模式支持函数RtlGetVersion和RtlVerifyVersionInformation的设备驱动程序中查询，这两个函数都记录在Windows驱动程序工具包（WDK）中。

那么，如果客户端和服务器版本的核心文件基本相同，那么systemsdiffer是如何运行的呢？简言之，默认情况下，服务器系统作为高性能应用程序服务器进行系统吞吐量优化，而客户端版本（尽管它具有服务器功能）则针对交互式桌面使用的响应时间进行优化。例如，根据产品类型，在系统启动时会做出不同的资源分配决策，例如操作系统堆（或池）的大小和数量、内部系统工作线程的数量以及系统数据缓存的大小。此外，运行时策略决策，如内存管理器权衡系统和进程内存需求的方式，在服务器版本和客户端版本之间也有所不同。

除非另有说明，否则本书中的所有内容都适用于客户端和服务器版本。

### 内部调试版本

Windows有一个特殊的内部调试版本，称为Checked Build(外部版本仅适用于订阅了MSDN操作系统的Windows 8.1及更早版本)。它是对Windows源代码的重新编译，其中定义了一个名为DBG的编译时标志，这会导致包括编译时、条件调试和跟踪代码。此外，为了使机器代码更容易理解，不执行Windows二进制文件的后处理，以优化代码布局以加快执行速度。
提供检查版本主要是为了帮助设备驱动程序开发人员，因为它对设备驱动程序或其他系统代码调用的内核模式函数执行更严格的错误检查。例如，如果驱动程序(或其他一些内核模式代码)对正在检查参数的系统函数进行无效调用(例如在错误的中断请求级别获取自旋锁)，则系统将在检测到问题时停止执行，而不是允许某些数据结构被破坏，系统可能在以后崩溃。因为完全检查的版本通常是不稳定的，不可能在大多数环境中运行，所以微软只为Windows 10和更高版本提供了检查的内核和HAL。这使开发人员能够从他们交互的内核和HAL代码中获得相同级别的有用性，而无需处理完全检查的构建会导致的问题。

检查构建二进制文件中的大部分附加代码是使用`ASSERT`和`NT_ASSERT`宏的结果，这两个宏在WDK头文件Wdm.h中定义，并在WDK文档中记录。
这些宏测试条件，例如数据结构或参数的有效性。如果表达式的计算结果为FALSE，则宏要么调用内核模式函数RtlAssert，后者调用DbgPrintEx将调试消息的文本发送到调试消息缓冲区，要么发出断言中断，这在x64和x86系统上是中断`0x2B`。如果附加了内核调试器并加载了适当的符号，则会自动显示此消息，并在其后自动显示一个提示，询问用户如何处理断言失败.

## 基于虚拟化的安全体系结构概述

用户模式和内核模式之间的分离为操作系统提供了保护，使其免受用户模式代码的攻击，无论是否恶意。然而，如果一段不需要的内核模式代码进入系统（因为一些尚未修补的内核或驱动程序漏洞，或者因为用户被诱骗安装了恶意或易受攻击的驱动程序），则系统基本上会受到损害，因为所有内核模式代码都可以完全访问整个系统。

用虚拟机监控程序提供额外的攻击保证，构成了一组基于虚拟化的安全（VBS）功能，通过引入虚拟信任级别（VTL）扩展了处理器基于自然特权的分离。除了简单地引入一种新的正交方式来隔离对内存、硬件和处理器资源的访问之外，VTL还需要新的代码和组件来管理更高级别的信任。不能允许在VTL 0中运行的常规内核和驱动程序控制和定义VTL 1资源；这将违背目的。

 ![Alt](./res/pic02_04.png#pic_center)

在启用VBS的情况下，现在存在一个VTL1，它包含自己的以特权处理器模式运行的安全内核（即x86/x64上的环0）。类似地，现在存在一种运行时用户环境模式，称为独立用户模式（IUM），它以非特权模式运行（即环3）。
在这个体系结构中，安全内核是它自己的独立二进制文件，可以在磁盘上以securekernel.exe的名称找到。它既是一个限制常规用户模式DLL可以进行的允许系统调用的环境（从而限制可以加载这些DLL中的哪些），也是一个添加只能在VTL 1下执行的特殊安全系统调用的框架。这些额外的系统调用以与常规系统调用类似的方式公开：通过名为Iumdll.dll（Ntdll.dll的VTL 1版本）的内部系统库和名为Iumbase.dll（Kernelbase.dll的VTL2版本）的面向Windows子系统的库，允许减少VTL 1用户模式应用程序的内存开销，因为本质上存在与其VTL 0对应程序相同的用户模式代码。
换言之，在VTL0上运行的内核模式代码不能触及在VTL 1上运行的用户模式，因为VTL 1更有特权。然而，在VTL1上运行的用户模式代码也不能接触在VTL 0上运行的内核模式，因为用户（R3）不能接触内核（R0）。

为了防止普通设备驱动程序利用硬件设备直接访问内存，系统使用了另一种称为I/O内存管理单元（MMU）的硬件，它可以有效地虚拟化设备的内存访问。这可以用来防止设备驱动程序使用直接内存访问（DMA）来直接访问系统管理程序或安全内核的物理内存区域。

关于truelist：
由于VTL 1中运行的用户模式进程是孤立的，因此潜在的恶意代码可能会偷偷运行，试图进行安全的系统调用（这将允许它密封/签署自己的机密），并可能导致与其他VTL 1进程或智能内核的不良交互。因此，只有一类特殊的经过特殊签名的二进制文件，称为Trustlets，才允许在VTL 1中执行。每个Trustlet都有一个唯一的标识符和签名，安全内核有关于到目前为止创建了哪些Trustlet的硬编码知识。因此，如果不能访问安全内核（只有Microsoft才能访问），就不可能创建新的Trustlet，而且现有的Trustlet也无法以任何方式进行修补（这将使Microsoft的特殊签名无效）。

## 关键系统组件

 ![Alt](./res/pic02_05.png#pic_center)

### 环境子系统和子系统DLL

环境子系统的作用是向应用程序公开基本Windows执行系统服务的一些子集。每个子系统都可以提供对Windows中本机服务的不同子集的访问。这意味着一些事情可以从一个子系统上构建的应用程序中完成，而另一个子系统中构建的应用无法完成。Windows 2000/XP支持三种环境子系统：Win32、POSIX和OS/2，其中最重要的环境子系统是Win32子系统，其他子系统都要通过Win32子系统接收用户的输入和显示输出。
Windows的环境子系统的服务器进程是CSRSS.EXE, 全称是Client/Server Runtime Server Subsystem. 它包括三个DLL.

* WINSRV.DLL：最基本的dll, 提供包括管理控制台窗口, hard error(内核的驱动程序发起, 有csrss.exe报告的错误)。
* CSRSRV.DLL：进程,线程维护, 调试。
* BASESRV.DLL：负责安全和登录.

每个可执行映像（.exe）都绑定到一个且仅绑定到一个子系统。运行映像时，进程创建代码检查映像标头中的子系统类型代码，以便将新进程通知操作子系统。此类型代码是使用Microsoft Visual Studio链接器的/SUBSYSTEM链接器选项指定的。
用户应用程序不会直接调用Windows系统服务。相反，它们通过一个或多个子系统DLL。这些库导出文档化的接口，链接到该子系统的程序可以调用该接口。例如，Windows子系统dll（如Kernel32.dll、Advapi32.dll、User32.dll和Gdi32.dll）实现Windows API函数。SUA子系统DLL（Psxdll.DLL）用于实现SUA API函数（在支持POSIX的Windows版本上）。

当应用程序调用子系统DLL中的函数时，可能会发生以下三种情况之一：

* 该函数完全以用户模式在子系统DLL中实现。换句话说，不会向环境子系统进程发送消息，也不会调用Windows执行系统服务。该函数在用户模式下执行，并将结果返回给调用者。
* 该函数需要对Windows执行程序进行一次或多次调用。例如，WindowsReadFile和WriteFile函数分别涉及调用底层的内部
* 该功能需要在环境子系统过程中完成一些工作，在这种情况下，通过发送给子系统的ALPC（第2部分第8章中描述）消息向环境子系统发出客户端/服务器请求，以执行一些操作。然后，子系统DLL在返回到调用者之前等待答复。

有些函数可以是刚刚列出的第二项和第三项的组合。

### 子系统启动

子系统由会话管理器（Smss.exe）进程启动。子系统启动信息存储在注册表项HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems下。
打开该注册表后，内容如下：

* Required：列出了系统引导时加载的子系统。该值有两个字符串：Windows和Debug。Windows值包含Windows子系统的文件规范Csrs.exe，它代表客户端/服务器运行时子系统。Debug为空。
* Optional：表示可选子系统，在本例中也为空，因为SUA在Windows 10上不再可用。如果是，Posix的数据值将指向指向Psxss.exe（Posix子系统进程）的另一个值。
* Kmode：包含Windows子系统的内核模式部分Win32k.sys的文件名。

### Windows子系统

尽管Windows被设计为支持多个独立的环境子系统，但从实际角度来看，让每个子系统实现所有代码来处理窗口和显示I/O将导致系统功能的大量重复，最终会对系统大小和性能产生负面影响。因为Windows是主要的子系统，所以Windows设计者决定将这些基本功能定位在那里，并让其他子系统调用Windows子系统来执行显示I/O。因此，SUA子系统调用Windows子系统中的服务来执行显示I/O。
Windows子系统是任何Windows系统的必备组件，即使在没有交互式用户登录的服务器系统上也是如此。因此，该进程被标记为关键进程（这意味着，如果它因任何原因退出，系统将崩溃）。
Windows子系统由以下主要组件组成：

* 对于每个会话，环境子系统进程（Csrss.exe）的一个实例加载四个dll（Basesrv.dll、Winsrv.dll、Sxssrv.dll和Csrsrv.dll），这些dll包含对以下内容的支持：
  * 与创建和删除进程和线程相关的各种内务管理任务。
  * 关闭Windows应用程序（通过ExitWindowsEx API）。
  * 包含.ini文件到注册表的位置映射以实现向后兼容性。
  * 将某些内核通知消息（如来自即插即用管理器的消息）作为窗口消息（WM_DEVICECHANGE）发送到Windows应用程序。
  * 部分支持16位虚拟DOS机（VDM）进程（仅限32位Windows）。
  * 并排（SxS）/Fusion和清单缓存支持。
  * 几个自然语言支持功能，以提供缓存。
* 内核模式设备驱动程序（Win32k.sys），包含以下内容：
  * 窗口管理器，用于控制窗口显示；管理屏幕输出；收集来自键盘、鼠标和其他设备的输入；并将用户消息传递给应用程序。
  * 图形设备接口（GDI），它是图形输出设备的函数库，包括线条、文本和图形绘制以及图形操作的函数。
  * 在另一个内核驱动程序（Dxgkrnl.sys）中实现的DirectX支持包装器。
* 控制台主机进程（Conhost.exe），它为控制台（字符单元）应用程序提供支持。
* 桌面窗口管理器（Dwm.exe），它允许通过CDD和DirectX将可见窗口渲染合成为单个面。
* 子系统dll（如Kernel32.dll、Advapi32.dll、User32.dll和Gdi32.dll），用于将记录在案的Windows API函数转换为Ntoskrnl.exe和Win32k.sys中适当且未记录的（针对用户模式）内核模式系统服务调用。
* 用于硬件相关图形显示驱动程序、打印机驱动程序和视频微型端口驱动程序的图形设备驱动程序。

