# chapter_01 concept and tools

可以在命令行中使用`ver`命令查询windows版本信息。

## 基础概念和术语

### Windows API风格

一些较新的API使用了不同的API机制：组件对象模型(COM),设计初衷在于使Microsoft office应用能够在文档之间通信和交换数据而创建的，这种功能被称为对象链接和嵌入(OLE)，最初是使用一种称为动态数据交换(DDE)的旧Windows消息传递机制实现的。

因为DDE是有限的，所以开发了一种新的通信方式COM。它不是面向对象的语言，而是一种标准。用于创建在运行时进行交互的可重用的软件库。 无需将其编译到应用程序中，即可使用 COM 库。

COM基于两个基本原则:

* 首先，客户端通过定义良好的接口与对象（有时称为COM服务器对象）进行通信，这些接口具有一组逻辑相关的方法，这些方法分组在虚拟表调度机制(the virtual table dispatch mechanism)下，这也是C++编译器实现虚拟函数调度的常见方式。这导致了二进制兼容性，并消除了编译器名称篡改问题。
* 第二个原则是组件实现是动态加载的，而不是静态链接到客户端。

术语COM服务器通常指的是实现COM类的动态链接库（DLL）或可执行文件（EXE）

通过COM访问的API示例包括DirectShow、Windows Media Foundation、DirectX、DirectComposition、Windows映像组件（WIC）和后台智能传输服务（BITS）。

### Windows运行时

Windows 8引入了一种新的API和支持运行时(runtime)，称为Windows runtime（有时缩写为WinRT，不要与Windows RT混淆，后者是已停产的基于ARM的Windows操作系统版本）

简要介绍runtime library：

> 运行时库是一种被编译器用来实现编程语言内置函数，以提供该语言程序运行时支持的一种特殊的计算机程序库。运行时库由编译器决定，以面向编程语言，一般由编译器生产商提供。
通常运行时库是以LIB或DLL形式提供的，运行时库除了提供必要的库函数调用（如memcpy、printf、malloc等）之外，它提供的另一个最重要的功能是为应用程序添加启动函数。C运行时库启动函数的主要功能为进行程序的初始化，对全局变量进行赋初值，加载用户程序的入口函数。

 ![Alt](./res/pic01_01.png#pic_center)

注意运行时库并不只是标准库，就算不显式 include 任何标准库，也有一些额外的代码会被编译器插入到最后的可执行文件里。比如上面提到的 main 函数，它在真正执行前就需要大量来自运行时库的辅助。
除了加载和退出这些程序必备的地方以外，运行时库还可以在程序执行过程中被隐式而按需调用。例如 gcc 的 libgcc，这些库都是特定于编译器的。

从 API 的角度来看，WinRT 建立在 COM 之上，向基础 COM基础设施添加了各种扩展。例如，WinRT 中提供了完整的类型元数据（存储在 WIMD 文件中并基于。NET 元数据格式），它在 COM 中扩展了一个类似的概念，称为类型库。

各种 API 和应用程序之间的关系并不简单。桌面应用程序可以使用WinRT API的一个子集。相反，Windows Apps 可以使用 Win32 和 COM API 的子集。对于C++，微软创建了一个称为C++/CX的非标准扩展，使使用WinRT类型变得更简单。

### .NET框架

.NET框架由两个主要组件组成：

* 公共语言运行时(CLR)
  这是.NET的运行时引擎，包括一个实时（JIT）编译器，用于将公共中间语言（CIL）指令转换为底层硬件CPU机器语言、垃圾收集器、类型验证、代码访问安全性等。它被实现为COM进程内服务器（DLL），并使用Windows API提供的各种功能。
* .NET Framework类库(FCL)
  这是一个大型类型集合，用于实现客户端和服务器应用程序通常需要的功能，例如用户界面服务、网络、数据库访问等等。

 ![Alt](./res/pic01_02.png#pic_center)

### 服务、功能和例程

Windows用户和编程文档中的几个术语在不同的上下文中具有不同的含义。例如，单词service可以指操作系统中的可调用例程、设备驱动程序或服务器进程。

* Windows API函数
  这些是Windows API中有文档记录的可调用子程序。示例包括CreateProcess、CreateFile和GetMessage。
* 本机系统服务（或系统调用）
  这些是操作系统中未记录的、可从用户模式调用的底层服务。例如，NtCreateUserProcess是Windows CreateProcess函数调用以创建新进程的内部系统服务。
* 内核支持函数（或例程）
  这些是WindowsOS中的子例程，只能从内核模式（本章稍后定义）调用。例如，ExAllocatePoolWithTag是设备驱动程序调用的例程，用于从Windows系统堆（称为池）中分配内存。
* Windows服务
  这些是由Windows服务控制管理器启动的进程。例如，任务调度器服务在用户模式进程中运行，该进程支持schtasks command.
* 动态链接库（DLL）
  这些是作为二进制文件链接在一起的可调用子例程，可以由使用这些子例程的应用程序动态加载。DLL相对于静态库的优势在于，应用程序可以共享DLL，并且Windows确保引用DLL的应用程序中只有一个DLL代码的内存副本。请注意，库.NET程序集编译为DLL，但没有任何非托管导出的子例程。相反，CLR解析编译后的元数据以访问相应的类型和成员。

### 进程

尽管程序和过程表面上看起来很相似，但它们本质上是不同的。程序是一个静态的指令序列，而进程是执行程序实例时使用的一组资源的容器。在最高抽象级别上，Windows进程包括以下内容：

* 专用虚拟地址空间
  这是进程可以使用的一组虚拟内存地址。
* 一种可执行程序
  它定义初始代码和数据，并映射到进程的虚拟地址空间。
* 打开句柄的列表
  这些句柄映射到各种系统资源，如信号量、同步对象和进程中所有线程都可以访问的文件。
* 安全上下文
  这是一个访问令牌，用于标识用户、安全组、权限、属性、声明、功能、用户帐户控制（UAC）虚拟化状态、会话和与进程相关的受限用户帐户状态，以及AppContainer标识符及其相关的沙盒信息。
* 进程ID
  这是唯一的标识符，在内部是称为客户端ID的标识符的一部分。
* 至少一个执行线程
* 虽然“空”进程是可能的，但它(主要)是没有用的。

每个进程还指向其父进程或创建者进程(可能是但不总是它的创建者进程)。如果父项不再存在，则不会更新此信息。因此，进程可以引用不存在的父进程。

### 线程

线程是Windows计划执行的进程中的实体。没有它，进程的程序就无法运行。线程包括以下基本组件：

* 代表处理器状态的一组CPU寄存器的内容。
* 两个堆栈：一个用于线程在内核模式下执行时使用，另一个用于在用户模式下执行。
* 称为线程本地存储(TLS)的私有存储区域，供子系统、运行时库和DLL使用。
* 称为线程ID的唯一标识符(称为客户端ID的内部结构的一部分；进程ID和线程ID是从相同的命名空间生成的，因此它们永远不会重叠)

此外，线程有时有自己的安全上下文或令牌，这通常由模拟它们所服务的客户端的安全上下文的多线程服务器应用程序使用。易失性寄存器、堆栈和私有存储区域称为线程的上下文。由于此信息对于运行Windows的每个计算机体系结构是不同的，因此此结构必然是特定于体系结构的。

因为将执行从一个线程切换到另一个线程涉及到内核调度程序，所以这可能是一项开销很大的操作，尤其是在两个线程经常相互切换的情况下。Windows实现了两种机制来降低此成本：光纤(fibers)和用户模式调度(UMS)。
在64位版本的Windows上运行的32位应用程序的线程将同时包含32位和64位上下文，WOW64(Windows上的Windows)将在需要时使用这些上下文将应用程序从32位模式切换到64位模式。这些线程将有两个用户堆栈和两个上下文块，通常的Windows API函数将返回64位上下文。然而，Wow64GetThreadContext函数将返回32位上下文。

关于fibers：
> fibers允许应用程序调度自己的执行线程，而不是依赖于Windows中内置的基于优先级的调度机制。fibers通常被称为lightweight threads。
> 在调度方面，它们对于内核是不可见的，因为它们是在Kernel32.dll中以用户模式实现的。要使用fibers，首先需要调用Windows ConvertThreadToFiber函数。此函数将线程转换为运行的fibers。然后，新转换的fibers可以通过CreateFiber功能创建额外的光纤。(每根光纤可以有自己的一组光纤。)然而，与线程不同的是，fibers直到通过调用SwitchToFiber函数手动选择它时才开始执行。新fibers一直运行，直到它退出或调用SwitchToFiber，再次选择另一个fibers运行。

然而，使用fibers通常不是一个好主意。这是因为它们对于内核是不可见的。它们还存在共享线程本地存储(TLS)等问题，因为多个纤程可以在同一线程上运行。尽管存在光纤本地存储(FLS)，但这并不能解决所有共享问题，而且I/O绑定光纤的性能无论如何都会很差。此外，fiberscan不能在多个处理器上同时运行，并且仅限于协作多任务处理。在大多数情况下，最好让Windows内核通过为手头的任务使用适当的线程来处理调度。

### 用户模式调度(UMS)线程

用户模式调度(UMS)线程只在64位版本的Windows上可用，它提供了与filber相同的基本优点,但只有少数缺点。UMS线程有自己的内核线程状态，因此对内核可见，这允许多个UMS线程发出阻塞系统调用并共享和争用资源。或者，当两个或多个UMS线程需要在用户模式下执行工作时，它们可以在用户模式下定期切换执行上下文(通过从一个线程切换到另一个线程)，而不涉及调度器。从内核的角度来看，相同的内核线程仍在运行，没有任何变化。
当UMS线程执行需要进入内核的操作(如系统调用)时，它会切换到其专用的内核模式线程(称为定向上下文切换)。

尽管线程有自己的执行上下文，但进程中的每个线程都共享该进程的虚拟地址空间(以及属于该进程的其余资源)，这意味着进程中的所有线程都具有对该进程虚拟地址空间的完全读写访问权限。然而，线程不可能意外地引用另一个进程的地址空间，除非另一个进程将其私有地址空间的一部分用作共享内存节(在Windows API中称为文件映射对象)，或者除非一个进程有权打开另一个进程以使用跨进程内存函数，如ReadProcessMemory和WriteProcessMemory(默认情况下，使用相同用户帐户运行的进程可以获得这些函数，而不是在AppContainer或其他类型的沙箱中，除非目标进程具有某些保护措施)。

除了私有地址空间和一个或多个线程外，每个进程都有一个安全上下文和一个打开的内核对象句柄列表，如文件、共享内存节或某个同步对象如互斥锁、事件或信号量。

 ![Alt](./res/pic01_03.png#pic_center)

每个进程的安全上下文存储在一个称为访问令牌的对象中。进程访问令牌包含进程的安全标识和凭据。
默认情况下，线程没有自己的访问令牌，但它们可以获得一个令牌，从而允许单个线程模拟另一个进程的安全上下文，包括远程Windows系统上的进程，而不会影响该进程中的其他线程。虚拟地址描述符(VAD)是内存管理器用来跟踪进程正在使用的虚拟地址的数据结构。

### 作业(job)

Windows为进程模型提供了一个称为作业的扩展。作业对象的主要功能是允许将进程组作为一个单元进行管理和操作。
作业对象允许控制某些属性，并为与作业关联的一个或多个进程提供限制。它还记录与作业相关联的所有进程以及与作业相关联但后来已终止的所有进程的基本记帐信息。在某些方面，作业对象弥补了Windows中缺乏结构化进程树的缺陷--但在许多方面，它比Unix风格的进程树更强大。

在Process Explorer中作业管理的进程默认是棕色的，但默认情况下未启用它。

### 虚拟内存

Windows实现了一个基于平面(线性)地址空间的虚拟内存系统，它为每个进程提供了拥有自己的大型私有地址空间的假象。虚拟内存提供了可能与其物理布局不对应的内存的逻辑视图。在运行时，内存管理器在硬件的帮助下将虚拟地址转换或映射为实际存储数据的物理地址。通过控制保护和映射，操作系统可以确保各个进程不会相互碰撞或覆盖操作系统数据。

因为大多数系统的物理内存比正在运行的进程使用的总虚拟内存少得多，所以内存管理器会将一些内存内容转移或分页到磁盘。将数据分页到磁盘可以释放物理内存，以便它可以用于其他进程或操作系统本身。当线程访问已分页到磁盘的虚拟地址时，虚拟内存管理器会将信息从磁盘加载回内存中。

> 虚拟地址空间的大小因硬件平台而异。在32位x86系统上，总虚拟地址空间理论上最大为4 GB。默认情况下，Windows将此地址空间的下半部分(地址0x00000000至0x7FFFFFFF)分配给进程用于其唯一的私有存储，而将上半部分(地址0x80000000至0xFFFFFFFF)分配给自己的受保护操作系统内存使用。
下半部分的映射会发生变化，以反映当前执行的进程的虚拟地址空间，但(大多数)上半部分的映射始终由操作系统的虚拟内存组成。
Windows提供了一种称为地址窗口化扩展(AWE)的机制，它允许32位应用程序分配多达64 GB的物理内存，然后将视图或窗口映射到其2 GB的虚拟地址空间。64位Windows为进程提供了更大的地址空间：在Windows 8.1、Server2012 R2和更高版本系统上为128TB。

### 内核模式与用户模式

用户应用程序代码在用户模式下运行。
而操作系统代码(如系统服务和设备驱动程序)在内核模式下运行。内核模式是指处理器中允许访问所有系统内存和所有CPU指令的一种执行模式。

Windows只使用两个级别(R3 & R0)的原因是，一些硬件体系结构，如今天的ARM和过去的MIPS/Alpha，只实现了两个权限级别。稳定在最低的最小门限上可以实现更高效、更便携的架构。

尽管每个Windows进程都有自己的私有内存空间，但内核模式操作系统和设备驱动程序代码共享一个虚拟地址空间。对虚拟存储器中的每一页进行标记，以指示处理器必须处于何种访问模式才能读取和/或写入该页。系统空间中的页面只能从内核模式访问，而用户地址空间中的所有页面都可以从用户模式和内核模式访问。只读页(如包含静态数据的页)在任何模式下都不可写。此外，在支持非执行内存保护的处理器上，Windows会将包含数据的页面标记为不可执行，从而防止在数据区域中意外或恶意执行代码。

Windows不为内核模式下运行的组件使用的私有读/写系统内存提供任何保护。换句话说，一旦进入内核模式，操作系统和设备驱动程序代码就可以完全访问系统空间内存，并可以绕过Windows安全来访问对象。

签名机制的引入：
> 这种保护的缺乏也强调了在加载第三方设备驱动程序时保持警惕的必要性，特别是如果它是未签名的，因为一旦进入内核模式，驱动程序就可以完全访问所有操作系统数据。这一风险是Windows 2000中引入的驱动程序签名机制背后的原因之一，如果试图添加未签名的即插即用驱动程序，该机制会警告用户。在64位和ARM版本的Windows 8.1上，内核模式代码签名(KMCS)策略规定，所有设备驱动程序(不仅仅是即插即用)都必须使用由主要代码证书颁发机构之一分配的密钥进行签名。即使作为管理员，用户也不能显式强制安装未签名的驱动程序。
此外，一种名为驱动程序验证器的机制可以帮助设备驱动程序编写者找到可能导致安全或可靠性问题的错误，如缓冲区溢出或内存泄漏。

认证：
> 如今，所有新的Windows 10驱动程序必须只由两个接受的证书颁发机构签署，并使用SHA-2扩展验证(EV)硬件证书，而不是常规的基于文件的SHA-1证书及其20个颁发机构。一旦EV签名，硬件驱动程序必须通过系统设备(SysDev)门户提交给Microsoft以进行证明签名，这将使驱动程序收到Microsoft签名。仅仅签署认证是不够的。要在服务器系统上加载Windows 10驱动程序，它必须通过严格的Windows硬件质量实验室(WHQL)认证，作为硬件兼容性工具包(HCK)的一部分，并提交进行正式评估。

请注意：从用户模式到内核模式(以及从用户模式到内核模式)的转换本身不会影响线程调度本身。模式转换不是上下文切换。

事实上，由于大部分图形和窗口系统也在内核模式下运行，图形密集型应用程序在内核模式下花费的时间比在用户模式下花费的时间更多。更高级的应用程序可以使用更新的技术，如Direct2D和DirectComposation，它们在用户模式下执行批量计算，并仅将原始曲面数据发送到内核。这减少了在用户模式和内核模式之间转换所花费的时间。

### 虚拟机管理程序

为了提供此类虚拟化服务，几乎所有现代解决方案都使用管理程序，这是一种专门的高特权组件，允许对机器上的所有资源进行虚拟化和隔离，从虚拟内存到物理内存，到设备中断，甚至到PCI和USB设备。Hyper-V就是此类管理程序的一个示例，它支持Windows 8.1及更高版本中提供的Hyper-V客户端功能。

由于其高度特权的性质，并且由于它拥有比内核本身更大的访问权限，因此管理程序具有一个明显的优势，它不仅仅是运行其他操作系统的多个来宾实例：它可以保护和监控单个主机实例，以提供内核所提供的以外的保证和保证。在Windows 10中，Microsoft现在利用Hyper-V管理程序来提供一组新的服务，称为基于虚拟化的安全(VBS).

Hyper-V管理程序支持针对利用漏洞和其他攻击者的某些关键内核缓解。所有这些技术的关键优势是，与以前基于内核的安全改进不同，它们不容易受到恶意或编写不当的驱动程序的攻击，无论它们是否经过签名。这使他们对当今先进的对手具有很强的韧性。这是由于管理程序实施了虚拟信任级别(VTL)。由于正常操作系统及其组件处于较低特权模式(VTL 0)，但这些VBS技术在VTL 1(较高特权)下运行，因此它们甚至不会受到内核模式代码的影响。因此，代码保留在VTL 0特权空间的范围内。通过这种方式，您可以将VTL视为与处理器的特权级别垂直：每个VTL中都存在内核和用户模式，并且管理程序管理跨VTL的特权。

### 固件

在现代的Windows 8和更高版本的系统中，这属于系统固件的权限，系统固件必须是基于UEFI认证的系统。作为WINDOWS规定的UEFI标准的一部分(UEFI2.3.1b)
通过这个验证过程，Windows组件从引导过程的一开始就被保证安全地加载。此外，可信平台模块(TPM)等技术可以测量该过程以提供证明(本地和远程)。通过与业界的合作，微软管理UEFI安全引导组件的白名单和黑名单，以防引导软件错误或受损，Windows更新现在也包括固件更新。

### 终端服务和多个会话

终端服务指的是Windows中对单个系统上的多个交互式用户会话的支持。使用Windows终端服务，远程用户可以在另一台计算机上建立会话、登录并在服务器上运行应用程序。
第一个会话被视为服务会话或会话0，它包含系统服务宿主进程，机器的物理控制台上的第一个登录会话是会话一，可以通过使用远程桌面连接程序(Mstsc.exe)或通过使用快速用户切换来创建其他会话。
Windows服务器系统支持 _两个_ 同步远程连接。这是为了便于远程管理.

### 对象和句柄

在Windows操作系统中，内核对象是静态定义的对象类型的单个运行时实例。对象类型包括系统定义的数据类型、对数据类型的实例进行操作的函数和一组对象属性。
进程、线程、文件和事件对象基于Windows创建和管理的较低级别的对象，进程是进程对象类型的实例，文件是文件对象类型的实例，依此类推。

对象属性是对象中的数据字段，它部分定义了对象的状态。例如，Process类型的对象将具有包括进程ID、基本调度优先级和指向访问令牌对象的指针的属性。对象方法是操作对象的方法，通常读取或更改对象属性。例如，进程的OPEN方法将接受进程id标识符作为输入，并返回指向该对象的指针作为输出。

> 在使用内核对象管理器API创建对象时，调用者提供了一个名为ObjectAttributes的参数。

### 安全

当用户登录时，将向他们提供一组安全凭据或安全上下文。当他们尝试访问对象时，会将他们的安全上下文与他们试图访问的对象上的访问控制列表进行比较，以确定他们是否有权执行所请求的操作。
授予资源访问权限的属性或声明，例如“许可级别：绝密”或“资历：10年”。借助通过Active Directory解析但是，资源的访问控制列表不一定标识单个用户和组。相反，它确定了所需的SQL数据库和架构来自动填充此类属性的能力，这一更加优雅和灵活的安全模型可帮助组织避免繁琐的手动组管理和组层次结构。

从Windows 8开始，一个名为AppContainer的沙箱被用来托管Windows应用程序，这提供了与其他AppContainer和非Windows应用程序进程的隔离。AppContainers中的代码可以与代理(使用用户凭据运行的非隔离进程)通信，有时还可以通过Windows Runtime提供的定义良好的约定与其他AppContainer或进程通信。一个典型的例子是在AppContainer内部运行的Microsoft Edge浏览器，因此可以提供更好的保护，防止恶意代码在其边界内运行。

### 注册表

注册表是系统数据库，包含启动和配置系统所需的信息、控制Windows操作的系统范围软件设置、安全数据库和每个用户配置设置，此外，注册表提供了一个窗口，可以查看内存中的易失性数据，例如系统的当前硬件状态（加载了哪些设备驱动程序，它们正在使用的资源等）以及Windows性能计数器。性能计数器实际上不在注册表中，可以通过注册表函数访问。

尽管许多Windows用户和管理员永远不需要直接查看注册表（因为您可以使用标准管理实用程序查看或更改大多数配置设置），但它仍然是Windows内部信息的有用来源，因为它包含许多影响系统性能和行为的设置。

书中提到的大多数注册表项都位于系统范围的配置配置单元HKEY_LOCAL_MACHINE下，我们将其缩写为HKLM。

### Unicode

Windows与大多数其他操作系统的不同之处在于，大多数内部文本字符串都是以16位宽的Unicode字符存储和处理的,从技术上讲是UTF-16LE。如果调用Windows函数的窄版本，则会对性能产生轻微影响，因为输入字符串参数在系统处理之前会转换为Unicode，输出参数在返回应用程序之前会从Unicode转换为ANSI。因此，如果您有一个旧的服务或代码需要在Windows上运行，但此代码是使用ANSI字符文本字符串编写的，Windows将把ANSI字符转换为Unicode供自己使用。然而，Windows从不转换文件中的数据，而是由应用程序决定是将数据存储为Unicode还是ANSI。

旧的Windows9x操作系统本机不支持Unicode。这是为ANSI和Unicode创建两个函数的另一个原因。例如，Windows API函数CreateFile根本不是一个函数；相反，它是一个扩展到两个函数之一的宏：CreateFileA（ANSI）或CreateFileW（Unicode，其中W代表宽）。扩展基于一个名为UNICODE的编译常量。

Windows中基于COM的API通常使用Unicode字符串，有时键入为BSTR。这本质上是一个以null结尾的Unicode字符数组，字符串的长度以字节为单位，存储在内存中字符数组开始前4个字节。Windows运行时API仅使用Unicode字符串，类型为HSTRING，这是一个不可变的Unicode字符数组。

## 深入研究Windows内部

### 内核调试

符号文件包含函数和变量的名称以及数据结构的布局和格式。它们由链接器生成，调试器在调试会话期间使用它们来引用和显示这些名称。
要使用任何内核调试工具来检查内部Windows内核数据结构，如进程列表、线程块、加载的驱动程序列表、内存使用信息等，您必须至少拥有内核映像的正确符号文件，Ntoskrnl.exe。

### windows调试

用winDbg，其包含：

1. cdb和ntsd是基于控制台用户界面的用户模式调试器。它们之间唯一的区别是，如果从现有控制台窗口激活，ntsd会打开一个新的控制台窗口，而cdb则不会。
2. kd是一个基于控制台用户界面的内核模式调试器。
3. WinDbg可以用作用户模式或内核模式调试器，但不能同时用作两者。它为用户提供了一个GUI。
4. 用户模式调试器（cdb、ntsd和WinDbg，当这样使用时）本质上是等效的。使用其中一个或另一个是一个偏好问题。
5. 内核模式调试器（kd和WinDbg，当这样使用时）也是等效的。

KD用于调试内核模式是使用于命令行模式中，而windbg使用于GUI环境下。

用户模式调试：

* 具有侵入性的
  除非另有规定，否则当连接到正在运行的进程时，可以使用DebugActiveProcessWindows函数在调试器和被调试对象之间建立连接。这允许您检查和/或更改进程内存、设置断点以及执行其他调试功能。Windows允许您在不终止目标进程的情况下停止调试，只要调试器是分离的，而不是终止的。
* 具有非侵入性的
  调试器只需使用OpenProcess函数打开进程。它不会作为调试器附加到进程。这允许您检查和/或更改目标进程中的内存，但不能设置断点。这也意味着即使另一个调试器是以入侵方式连接的，也可以以非入侵方式连接。

内核模式调试：

* 打开因Windows系统崩溃而创建的崩溃转储文件。
* 连接到一个正在运行的实时系统并检查系统状态（如果正在调试设备驱动程序代码，则设置断点）。此操作需要两台计算机：一台目标计算机（正在调试的系统）和一台主机计算机（运行调试器的系统）。目标系统可以通过零调制解调器电缆、IEEE 1394电缆、USB 2.0/3.0调试电缆或本地网络连接到主机。目标系统必须在调试模式下启动。还可以通过命名管道进行连接，这在通过虚拟机产品（如Hyper-V、virtual Box或VMWare Workstation）调试Windows 7或更早版本时很有用，方法是将来宾操作系统的串行端口公开为命名管道设备.
* Windows系统还允许您连接到本地系统并检查系统状态。这称为本地内核调试。要使用WinDbg启动本地内核调试，首先确保系统设置为调试模式（例如，通过运行msconfig.exe，单击Boottab，选择Advanced Options，选择debug，然后重新启动Windows）。以管理员权限启动WinDbg并打开“文件”菜单，选择“内核调试”，单击“本地”选项卡，然后单击“确定”（或使用bcdedit.exe）

### LiveKd

LiveKd是Sysinternals提供的一个免费工具，使您能够使用刚才描述的标准Microsoft内核调试器来检查正在运行的系统，而无需在调试模式下启动系统。当需要对未在调试模式下启动的计算机进行内核级故障排除时，这种方法可能很有用。某些问题可能很难可靠地再现，因此在启用缺陷选项的情况下重新启动可能不容易显示错误。你运行LiveKd就像运行WinDbg或kd一样。LiveKd将您指定的任何命令行选项传递给您选择的调试器。默认情况下，LiveKd运行命令行内核调试器（kd）。要让它运行WinDbg，请使用-w开关。要查看LiveKd开关的帮助文件，请使用-？转换

## 最后

本书中的许多实验都使用了可以从Sysinternals下载的免费软件工具。这本书的合著者Mark Russinovich写了大部分这些工具。最流行的工具包括Process Explorer和Process Monitor。
其中许多实用程序涉及内核模式设备驱动程序的安装和执行，因此需要管理员或提升的权限，尽管其中一些实用程序可以在标准或非提升的用户帐户上以有限的功能和输出运行。由于Sysinternals工具经常更新，请确保您有最新版本。
