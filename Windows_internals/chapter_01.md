# chapter_01 concept and tools

可以在命令行中使用`ver`命令查询windows版本信息。

## 基础概念和术语

### Windows API风格

一些较新的API使用了不同的API机制：组件对象模型(COM),设计初衷在于使Microsoft office应用能够在文档之间通信和交换数据而创建的，这种功能被称为对象链接和嵌入(OLE)，最初是使用一种称为动态数据交换(DDE)的旧Windows消息传递机制实现的。

因为DDE是有限的，所以开发了一种新的通信方式COM。它不是面向对象的语言，而是一种标准。用于创建在运行时进行交互的可重用的软件库。 无需将其编译到应用程序中，即可使用 COM 库。 

COM基于两个基本原则:

* 首先，客户端通过定义良好的接口与对象（有时称为COM服务器对象）进行通信，这些接口具有一组逻辑相关的方法，这些方法分组在虚拟表调度机制(the virtual table dispatch mechanism)下，这也是C++编译器实现虚拟函数调度的常见方式。这导致了二进制兼容性，并消除了编译器名称篡改问题。
* 第二个原则是组件实现是动态加载的，而不是静态链接到客户端。

术语COM服务器通常指的是实现COM类的动态链接库（DLL）或可执行文件（EXE）

通过COM访问的API示例包括DirectShow、Windows Media Foundation、DirectX、DirectComposition、Windows映像组件（WIC）和后台智能传输服务（BITS）。

### Windows运行时

Windows 8引入了一种新的API和支持运行时(runtime)，称为Windows runtime（有时缩写为WinRT，不要与Windows RT混淆，后者是已停产的基于ARM的Windows操作系统版本）

简要介绍runtime library：

> 运行时库是一种被编译器用来实现编程语言内置函数，以提供该语言程序运行时支持的一种特殊的计算机程序库。运行时库由编译器决定，以面向编程语言，一般由编译器生产商提供。
通常运行时库是以LIB或DLL形式提供的，运行时库除了提供必要的库函数调用（如memcpy、printf、malloc等）之外，它提供的另一个最重要的功能是为应用程序添加启动函数。C运行时库启动函数的主要功能为进行程序的初始化，对全局变量进行赋初值，加载用户程序的入口函数。

 ![Alt](./res/pic01_01.png#pic_center)

注意运行时库并不只是标准库，就算不显式 include 任何标准库，也有一些额外的代码会被编译器插入到最后的可执行文件里。比如上面提到的 main 函数，它在真正执行前就需要大量来自运行时库的辅助。
除了加载和退出这些程序必备的地方以外，运行时库还可以在程序执行过程中被隐式而按需调用。例如 gcc 的 libgcc，这些库都是特定于编译器的。

从 API 的角度来看，WinRT 建立在 COM 之上，向基础 COM基础设施添加了各种扩展。例如，WinRT 中提供了完整的类型元数据（存储在 WIMD 文件中并基于。NET 元数据格式），它在 COM 中扩展了一个类似的概念，称为类型库。

各种 API 和应用程序之间的关系并不简单。桌面应用程序可以使用WinRT API的一个子集。相反，Windows Apps 可以使用 Win32 和 COM API 的子集。对于C++，微软创建了一个称为C++/CX的非标准扩展，使使用WinRT类型变得更简单。

### .NET框架

.NET框架由两个主要组件组成：

* 公共语言运行时(CLR)
  这是.NET的运行时引擎，包括一个实时（JIT）编译器，用于将公共中间语言（CIL）指令转换为底层硬件CPU机器语言、垃圾收集器、类型验证、代码访问安全性等。它被实现为COM进程内服务器（DLL），并使用Windows API提供的各种功能。
* .NET Framework类库(FCL)
  这是一个大型类型集合，用于实现客户端和服务器应用程序通常需要的功能，例如用户界面服务、网络、数据库访问等等。

 ![Alt](./res/pic01_02.png#pic_center)

### 服务、功能和例程

Windows用户和编程文档中的几个术语在不同的上下文中具有不同的含义。例如，单词service可以指操作系统中的可调用例程、设备驱动程序或服务器进程。

* Windows API函数
  这些是Windows API中有文档记录的可调用子程序。示例包括CreateProcess、CreateFile和GetMessage。
* 本机系统服务（或系统调用）
  这些是操作系统中未记录的、可从用户模式调用的底层服务。例如，NtCreateUserProcess是Windows CreateProcess函数调用以创建新进程的内部系统服务。
* 内核支持函数（或例程）
  这些是WindowsOS中的子例程，只能从内核模式（本章稍后定义）调用。例如，ExAllocatePoolWithTag是设备驱动程序调用的例程，用于从Windows系统堆（称为池）中分配内存。
* Windows服务
  这些是由Windows服务控制管理器启动的进程。例如，任务调度器服务在用户模式进程中运行，该进程支持schtasks command.
* 动态链接库（DLL）
  这些是作为二进制文件链接在一起的可调用子例程，可以由使用这些子例程的应用程序动态加载。DLL相对于静态库的优势在于，应用程序可以共享DLL，并且Windows确保引用DLL的应用程序中只有一个DLL代码的内存副本。请注意，库.NET程序集编译为DLL，但没有任何非托管导出的子例程。相反，CLR解析编译后的元数据以访问相应的类型和成员。

### 进程

尽管程序和过程表面上看起来很相似，但它们本质上是不同的。程序是一个静态的指令序列，而进程是执行程序实例时使用的一组资源的容器。在最高抽象级别上，Windows进程包括以下内容：

* 专用虚拟地址空间
  这是进程可以使用的一组虚拟内存地址。
* 一种可执行程序
  它定义初始代码和数据，并映射到进程的虚拟地址空间。
* 打开句柄的列表
  这些句柄映射到各种系统资源，如信号量、同步对象和进程中所有线程都可以访问的文件。
* 安全上下文
  这是一个访问令牌，用于标识用户、安全组、权限、属性、声明、功能、用户帐户控制（UAC）虚拟化状态、会话和与进程相关的受限用户帐户状态，以及AppContainer标识符及其相关的沙盒信息。
* 进程ID
  这是唯一的标识符，在内部是称为客户端ID的标识符的一部分。
* 至少一个执行线程
* 虽然“空”进程是可能的，但它(主要)是没有用的。

每个进程还指向其父进程或创建者进程(可能是但不总是它的创建者进程)。如果父项不再存在，则不会更新此信息。因此，进程可以引用不存在的父进程。

### 线程

线程是Windows计划执行的进程中的实体。没有它，进程的程序就无法运行。线程包括以下基本组件：

* 代表处理器状态的一组CPU寄存器的内容。
* 两个堆栈：一个用于线程在内核模式下执行时使用，另一个用于在用户模式下执行。
* 称为线程本地存储(TLS)的私有存储区域，供子系统、运行时库和DLL使用。
* 称为线程ID的唯一标识符(称为客户端ID的内部结构的一部分；进程ID和线程ID是从相同的命名空间生成的，因此它们永远不会重叠)

此外，线程有时有自己的安全上下文或令牌，这通常由模拟它们所服务的客户端的安全上下文的多线程服务器应用程序使用。易失性寄存器、堆栈和私有存储区域称为线程的上下文。由于此信息对于运行Windows的每个计算机体系结构是不同的，因此此结构必然是特定于体系结构的。

因为将执行从一个线程切换到另一个线程涉及到内核调度程序，所以这可能是一项开销很大的操作，尤其是在两个线程经常相互切换的情况下。Windows实现了两种机制来降低此成本：光纤(fibers)和用户模式调度(UMS)。
在64位版本的Windows上运行的32位应用程序的线程将同时包含32位和64位上下文，WOW64(Windows上的Windows)将在需要时使用这些上下文将应用程序从32位模式切换到64位模式。这些线程将有两个用户堆栈和两个上下文块，通常的Windows API函数将返回64位上下文。然而，Wow64GetThreadContext函数将返回32位上下文。

关于fibers：
> fibers允许应用程序调度自己的执行线程，而不是依赖于Windows中内置的基于优先级的调度机制。fibers通常被称为lightweight threads。
> 在调度方面，它们对于内核是不可见的，因为它们是在Kernel32.dll中以用户模式实现的。要使用fibers，首先需要调用Windows ConvertThreadToFiber函数。此函数将线程转换为运行的fibers。然后，新转换的fibers可以通过CreateFiber功能创建额外的光纤。(每根光纤可以有自己的一组光纤。)然而，与线程不同的是，fibers直到通过调用SwitchToFiber函数手动选择它时才开始执行。新fibers一直运行，直到它退出或调用SwitchToFiber，再次选择另一个fibers运行。

然而，使用fibers通常不是一个好主意。这是因为它们对于内核是不可见的。它们还存在共享线程本地存储(TLS)等问题，因为多个纤程可以在同一线程上运行。尽管存在光纤本地存储(FLS)，但这并不能解决所有共享问题，而且I/O绑定光纤的性能无论如何都会很差。此外，fiberscan不能在多个处理器上同时运行，并且仅限于协作多任务处理。在大多数情况下，最好让Windows内核通过为手头的任务使用适当的线程来处理调度。

### 用户模式调度(UMS)线程

用户模式调度(UMS)线程只在64位版本的Windows上可用，它提供了与filber相同的基本优点,但只有少数缺点。UMS线程有自己的内核线程状态，因此对内核可见，这允许多个UMS线程发出阻塞系统调用并共享和争用资源。或者，当两个或多个UMS线程需要在用户模式下执行工作时，它们可以在用户模式下定期切换执行上下文(通过从一个线程切换到另一个线程)，而不涉及调度器。从内核的角度来看，相同的内核线程仍在运行，没有任何变化。
当UMS线程执行需要进入内核的操作(如系统调用)时，它会切换到其专用的内核模式线程(称为定向上下文切换)。

尽管线程有自己的执行上下文，但进程中的每个线程都共享该进程的虚拟地址空间(以及属于该进程的其余资源)，这意味着进程中的所有线程都具有对该进程虚拟地址空间的完全读写访问权限。然而，线程不可能意外地引用另一个进程的地址空间，除非另一个进程将其私有地址空间的一部分用作共享内存节(在Windows API中称为文件映射对象)，或者除非一个进程有权打开另一个进程以使用跨进程内存函数，如ReadProcessMemory和WriteProcessMemory(默认情况下，使用相同用户帐户运行的进程可以获得这些函数，而不是在AppContainer或其他类型的沙箱中，除非目标进程具有某些保护措施)。

除了私有地址空间和一个或多个线程外，每个进程都有一个安全上下文和一个打开的内核对象句柄列表，如文件、共享内存节或某个同步对象如互斥锁、事件或信号量。

 ![Alt](./res/pic01_03.png#pic_center)

每个进程的安全上下文存储在一个称为访问令牌的对象中。进程访问令牌包含进程的安全标识和凭据。
默认情况下，线程没有自己的访问令牌，但它们可以获得一个令牌，从而允许单个线程模拟另一个进程的安全上下文，包括远程Windows系统上的进程，而不会影响该进程中的其他线程。虚拟地址描述符(VAD)是内存管理器用来跟踪进程正在使用的虚拟地址的数据结构。

### 作业(job)

Windows为进程模型提供了一个称为作业的扩展。作业对象的主要功能是允许将进程组作为一个单元进行管理和操作。
作业对象允许控制某些属性，并为与作业关联的一个或多个进程提供限制。它还记录与作业相关联的所有进程以及与作业相关联但后来已终止的所有进程的基本记帐信息。在某些方面，作业对象弥补了Windows中缺乏结构化进程树的缺陷--但在许多方面，它比Unix风格的进程树更强大。

在Process Explorer中作业管理的进程默认是棕色的，但默认情况下未启用它。

### 虚拟内存

Windows实现了一个基于平面(线性)地址空间的虚拟内存系统，它为每个进程提供了拥有自己的大型私有地址空间的假象。虚拟内存提供了可能与其物理布局不对应的内存的逻辑视图。在运行时，内存管理器在硬件的帮助下将虚拟地址转换或映射为实际存储数据的物理地址。通过控制保护和映射，操作系统可以确保各个进程不会相互碰撞或覆盖操作系统数据。

因为大多数系统的物理内存比正在运行的进程使用的总虚拟内存少得多，所以内存管理器会将一些内存内容转移或分页到磁盘。将数据分页到磁盘可以释放物理内存，以便它可以用于其他进程或操作系统本身。当线程访问已分页到磁盘的虚拟地址时，虚拟内存管理器会将信息从磁盘加载回内存中。

> 虚拟地址空间的大小因硬件平台而异。在32位x86系统上，总虚拟地址空间理论上最大为4 GB。默认情况下，Windows将此地址空间的下半部分(地址0x00000000至0x7FFFFFFF)分配给进程用于其唯一的私有存储，而将上半部分(地址0x80000000至0xFFFFFFFF)分配给自己的受保护操作系统内存使用。
下半部分的映射会发生变化，以反映当前执行的进程的虚拟地址空间，但(大多数)上半部分的映射始终由操作系统的虚拟内存组成。
Windows提供了一种称为地址窗口化扩展(AWE)的机制，它允许32位应用程序分配多达64 GB的物理内存，然后将视图或窗口映射到其2 GB的虚拟地址空间。64位Windows为进程提供了更大的地址空间：在Windows 8.1、Server2012 R2和更高版本系统上为128TB。

### 内核模式与用户模式

用户应用程序代码在用户模式下运行。
而操作系统代码(如系统服务和设备驱动程序)在内核模式下运行。内核模式是指处理器中允许访问所有系统内存和所有CPU指令的一种执行模式。

Windows只使用两个级别(R3 & R0)的原因是，一些硬件体系结构，如今天的ARM和过去的MIPS/Alpha，只实现了两个权限级别。稳定在最低的最小门限上可以实现更高效、更便携的架构。


