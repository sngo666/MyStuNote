# Message Franking via Committing Authenticated Encryption

文章提出的message franking，目标是消息的安全保障不受损害的基础上，向服务方报告滥用消息，是一种AEAD(authenticated encryption with associated data)方案,即使用相关数据提交经过身份验证的加密，在该方案中，有一小部分的密文可以用作对于消息内容的加密承诺，此外在解密时提供一个值，用于打开加密承诺。
文章提出分析了几种将漏洞暴露给对手后仍然能够保持安全性的方案。一种是facebook的message franking协议的方案推广，并对其提供一种高性能的新结构。

首先是研究背景
加密消息系统已经被超过十亿人使用，其使用专门的密钥交互协议并结合身份验证以保护消息。系统的主要的设计目标是端到端的安全性，提供消息传递的服务者或者是能够访问到整个系统的中介不应该能够侵犯用户消息的隐私性或者完整性。

表中给出了论文所给出的方案概要，通过从multiple-opening(MO)多开安全，发送方绑定和接收方绑定三个方面评估。最后三列表示对于三个主要操作中的每一个来说，比在长度等于消息的位串上的加密传递次数加上处理相关数据所需的传递次数。

端到端安全与其他安全目标有些许的差异，当一个用户发送骚扰信息，广告邮件等违规信息时，服务提供方有义务阻止这些恶意行为的再发生，因此当接受者接受到违规信息时，应该可以报告这些恶意行为，以便于服务端能够惩罚恶意行为者，但是我们如何证明接收者提交的报告反映的是真实情况呢，如报告的消息是真实发送的消息，报告中的发送者确实参与了恶意行为吗，以上这些情况都会导致报告的滥用。

Facebook Messenger为可核实的滥用报告推出了一个看似解决方案，即message franking，通过在报告中包含密码证据，证明消息发送的报告是由特定发送者发送的。文中表示，目前还不清楚邮资印刷提供了什么信息，他们的方法是否安全，以及是否存在更好的结构。

Facebook的协议工作协议原理如下，发送方首先为HMAC生成一个新的密钥。HMAC是基于加密哈希函数的消息认证方案，
HMAC：为了避免使用同样的hash函数对相同数据进行操作总是得出同样的摘要，额外加入一个密钥，这样使用不同密钥就可以得出不同的MAC，当然，这个密钥是两个对端都知道的。这样，就得到了基于加密hash的消息完整性认证的算法。
并将HMAC应用于消息，然后使用传统的AEAD方案加密HMAC密钥和消息，并仅与接收方共享密钥，将生成的密文和哈希值发送到服务器，服务器对哈希值进行签名，将整个包(签名，哈希值和密文)转告给收件人，收件人使用恢复的HMAC密钥解密并检查HMAC输出的有效性。当接受者进行举报滥用行为，使用软件客户端将签名，哈希值，消息和HMAC密钥发送给服务器，并让后者验证签名和哈希。HMAC在这段协议中扮演承诺的角色。

下一部分中，提出一种AEAD方案，紧凑型承诺AEAD(compactly committing AEAD),其中的一小部分密文可以用作对于消息的承诺，并配备额外的算法用以检查承诺。这一部分需要保证对于保密性、密文完整性，并使得密文对于其基础明文有约束力。但是这不能够提供足够的安全性。接下来引入两个概念：
针对安全性分析，提出一组概念，单开口安全(single-opening):SO安全，即密钥本身用作开口。与之相对应的是多开口MO(multiple-opening)。系统会因为开口泄漏密码材料，除此之外，它还会在oracle挑战以及在拥有常规密钥的情况下获得其常规加密和解密。文章在此基础上进行保密性和完整性的博弈，并将其正式化。
接收方绑定和发送方绑定，实现接收方绑定意味着没有计算受限的对手能够找到两个打开的消息对来验证密文的相同提交部分。
然而文章也展示了接收者绑定的方案如何仍然允许以下攻击：发送者仔细选择密文，以便接收者正确地解密滥用消息，但与由此产生的消息打开的验证失败。因而正规化并以满足发送者绑定属性为目标，以排除此类攻击。

提出这些概念后，对于现有的已存在的AEAD计划是否使用紧凑承诺，文章对此分析了具体的结构，列举了三个重要的方案。分别是Encode-then-Encipher，Encrypt-then-MAC，MAC-then-Encrypt。

接下的一部分，文章将转向将承诺与现有的AE方案，相结合的一个通用结构，并提供了一种替代组合，它消除了对不可延展承诺的需要，并且还可以在关联数据相对较长的情况下提高性能。这两种构造都是多重开放安全的，因为承诺开放独立于底层的AE密钥。

** 准备工作

先简要叙述几个数学符号
(简要介绍)

接下来使用基于代码的博弈形式化安全，变量被隐式初始化为其默认的适当值，整数为0或者是集合初始为空集等。使用Pr表示博弈中输出为y的时间，使用big-O表示隐藏对结果没有实质性影响的小常数。
ROM：随机预言机模型，在ROM中，算法和UI手都配备了一个预言机，将每个输入关联到一个随机长度的输出。随机预言机，也可以理解为一个理想化的Hash，理论上来说，它是一个将所有可能输入和输出进行随机映射的函数，在ROM的预言机中，输出随上下文变化而变化。
ICM：理想密码模型，在ICM中，算法和对手都配备了一个预言机，前者接受输入一个键key、一个调整值tweak和一段消息message，对应长度分别为k、t、n，key和tweak在一段长度为n的二进制序列上，后者的预言机将密钥、调整和n位值作为输入，并返回应用于该值的密钥和调整所选择的排列的逆序。

首先介绍第一个算法：基于随机数的认证加密,其包含三个模块（Kg，Enc，Dec），与之相关联的是密钥空间K，随机数空间N，首部空间H，消息空间M和密文空间C，首先是K个，随机密钥生成算法首先输出密钥，K <- $K 这个式子代表从密钥空间选择密钥K，一般情况是这样的，在执行加密算法Enc时，以四元组输入(K,N,H,M)作为输入，如果四个输入分别被包含在各自的空间内，输出密文C，反之输出错误符号⊥。解密同样是确定性的，通过处理输入组(K,N,H,C)返回消息M或⊥。

当所有输入是合法的时，一个Enc必定输出一段密文，且能够通过Dec获取相对应的明文。当我们从一个硬币空间(coin space)R抽取一个数R，使用R以代替随机数N，现在对于任何(K,H,M,R)，同样满足这条规则，保证最后密文明确包含R。由此我们定义对手的伪随机函数优势如下所示

其中Func为输出n位的所有函数的空间。如果上式对于所有有效的对手来说都很小，那么我们可以说函数F是PRF，也可以将减号左边的式子理解为现实世界，相对应的右式为理想世界。直观地说，如果有限函数族F的随机成员的输入输出行为与相同域和范围的随机函数的行为不可区分，则该函数族F是伪随机的。
接着是多用户(MU)PRF安全性，文中将对手的MU-PRF伪随机优势定义为下式，
在这里函数F上一杠的输入位密钥标识符S和消息M，S为固定长度的序列，检查是否存在与S相关联的密钥，如果没有，选择新的密钥K[S] <- ${0, 1}^k ,然后返回F(K[S], M).
oracle R与之类似，只不过生成密钥的函数为来自于硬币空间。多用户安全性是隐含在PRF安全性中的，其优势判定准则等同于PRF优势。

第二部分是CR(collision-resistance)抗碰撞，将抗碰撞优势定义为图中所示，函数F对于固定长度的两段序列，生成结果长度为N的序列，对于任意两个二元组(x1, x2)与(x1', x2')，存在其函数F输出结果相匹配的可能性，当对于所有有效的对手来说都是足够小，那么可以说就是抗冲突的。

接下来是第二个算法：带有验证的承诺方案，一个验证算法CS = (Com, VerC)是有Com和VerC两个函数组成的，与之相关联的是 一个开放空间Kf，一个消息空间M和一个承诺空间C。定义上函数Com是随机化的，输入为M，输出一个二元组(K, C)当且仅当M在消息空间范围内时，否则返回错误符号⊥。
VerC函数接收一个三元组(K, C, M)作为输入，如果每一项都属于其对应的空间，那么输出一个bit值为1，反之则为0。
简述完两个部分后，文章定义了一个新的博弈vBind，这是将承诺方案的绑定安全概念化为一个博弈，在博弈中，对手输出一个组(Kc, M, Kc', M', C)然后运行b ← VerC(Kc, C, M)和b' ← VerC(Kc', C, M')，如果M' = M = 1且b = b' = 1,则博弈输出true。因此我们得到该博弈的优势关联为。

承诺本身也应具有隐蔽性，文章提出一种特性叫做ROR(real-or-random)实或随机特性，要求承诺和随机位串不可分，且开头保密，提出博弈ROR1CS，使对手可以访问查询消息的oracle Com以便查询消息，oracle计算(Kc, C) ← Com(M) 并返回C。对手输出一个bit吗，如果为1则博弈结果为true，ROR0CS与之类似，区别在于oracle返回一个长度为|C|的随机字符串，如果对手输出为0则结果为true，定义博弈优势如下式。

对于任意带有碰撞抵抗的PRF函数F，构建CS[F] = (Com, VerC)，通过VerC检验并输出相应的结果比特，下面的定理揭示了这个承诺方案依赖于PRF安全性和抗碰撞。

这篇文章中的所有证明都在另一篇中。
对于定理1：
对于函数F，CS[F]是如上所述从它建立的承诺方案。则对于在博弈RoR中进行最多查询的有效对手A和在博弈vBIND中进行查询的有效对手A‘，分别存在一对对手B，B’，有：
并且对手B和A运行时间相同，并进行相同的预言机查询。

之后的过程中，需要一个合理的抗碰撞的伪随机函数，合适的候选者为HMAC，或者是其他多属性散列函数，这里假设PRF为HMAC。

** message franking 与 端到端加密

在端到端加密消息传递服务中，消息隐私和向服务提供商报告滥用消息内容之间存在矛盾。刚刚简要说明了这一点，在这一部分文章更加深入讨论了这个问题，向服务商提供滥用消息行为对于标记存在不正当行为的账户有非常重要的作用。
从整体上看，服务商不仅要保证对于消息内容的举报是真实存在的，同时还要保证参与消息传递的双方在这之中是正确的，否则，任何一个环节的疏漏都会导致举报机制被恶意再次利用
，如可以通过伪造账户攻击自己并嫁祸他人，这是发送者绑定出错导致的问题，如恶意篡改消息内容并上传服务器进行举报，这是针对消息的完整性作出的攻击。甚至于当接收方选择一个密钥并以合法地方式将消息解密为一个假消息，这同样是不被允许的。
归根结底，要做到这一点，需要进行加密，且保证在计算效率上高效的对手无法找到将密文解密为原始加密消息以外的任何内容的密钥。

Facebook的message franking如图所示，该协议是针对滥用报告现象，使用端到端的加密。基本思想是迫使发送者对明文消息提供明文发送的承诺。
结构比较简单，不逐行细说，这里说两个点，一个是a是一个标签，用于在分析报告时的关键值。使用AEAD方案对消息和Kf进行加密，使用与接收方共享的密钥Kr生成密文C1。

虽然facebook本身的技术规格并不这么称呼，但实际上facebook使用HMAC生成标签a，因而能够放弃了存储承诺，而是对它们进行签名并外包给接受者进行存储。

** AEAD

形式上，AEAD方案CE = (Kg, Enc, Dec, Ver)， 与方案有关的是密钥空间K，首部空间H，消息空间M，密文空间C，开口空间Kf和标签空间T。

key generation：K ← $Kg
随机密钥生成算法Kg输出一个密钥.

Encryption: (C1, C2) ← $ Enc(K, H, M)
随机化加密Enc，加密的输入是一个三元组(K, H, M)，输出是一对(C1, C2)，C1是密文，C2是加印标签，也就是承诺。同时也可以输出错误符号⊥。

Decryption：(M, Kf ) ← Dec(K, H, C1, C2)
解密的过程是确定性的，以一个四元组(K, H, C1, C2)作为输入，输出(M, Kf)或⊥。

Verification： b ← Ver(H, M, Kf, C2)
输入四元组(H, M, Kf, C2)，输出一个比特，验证如VerC。

CE方案输出的密文长度完全由首部H和消息的长度决定，这意味着必然会存在一个函数clen，对于所有在所在空间范围内的(K, H, M)，有Pr[(|C1|, |C2|) = clen(|H|, |M|)] = 1，其中C1,C2来源于上述加密过程。因而CE方案具有解密正确性。

紧凑承诺AEAD：
传统的关于AEAD的方案是C1 = ε 而C2等于整个密文，即将整段密文视为承诺。在紧凑承诺AEAD中，其含义为尽量保证|C2|为很小的值，并希望|C2|的安全性参数是线性的，而不是基于长度线性化的。方法在于通过抗碰撞(CR)哈希函数对密文进行哈希，使内容变得紧凑。

第二个考虑，关于单开口与(single-opening)多开口(multiple-opening)：
在某些协议中，希望能够尽量使用CE方案，在不威胁到其他密文的保密性的情况下，使用相同的密钥加密多个密文。在其他的情况下，密钥在开放后不会再被使用。因此在方案中对于单开放和多开放的选择是需要明确反应在定义里的。

第三个考虑，消息机密性ROR：
CE应当有超越于传统AE方案更强的消息机密性，在较高的级别上，其要求任何对手都不能区分合法的CE加密和(对)随机比特串。通过向攻击者提供额外的一对oracle来处理这个问题，一个用于加密，一个用于解密。这一切在图中所给出的博弈方案中正式化。于是我们得到如下所示的方案CE的多开口实或随机(MO-ROR)优势。
同时单开口方案也能得到类似的优势。

第四个考虑，密文完整性CTXT：
与机密性的考量一样，首先将AEAD方案提升到对于单开口和多开口，这里给出其具体的博弈方案。对手可以在密钥下获得加密和解密，其目标是向挑战解密预言机查询有效密文。加密预言机必须不会返回该密文。优势为如下。
并通过删除解密预言机以指定单开方安全性，并得到优势。

CE方案也包含标准或随机AE方案，最后引入两个安全概念，发送方绑定和接收方绑定。
伪代码博弈sBind过程如图所示，并根据其建立优势：

CE方案一般可以通过在DEC期间运行Ver并在Ver返回0的情况下使DEC返回⊥来满足发送方绑定。过程中省略了这一点的证明，传统的AEAD并不包含这个过程，对于新方案，会有更有效果的方式实现发送方绑定。

在之前的过程中已经交代过当系统缺失接收方绑定时造成的恶意行为，恶意的接收者可以通过打开发送者的密文之一来攻击辱骂消息，而不是发送者想要的密文。伪代码博弈rBind，攻击者输出一个三元组包含相关数据，一条消息和一个opening，文章里虽然没有说，但是根据我的合理猜测应该是公钥Kf，并同时输出标签C2，如果在其之间对不上的两个三元组上，那么就认为对手成功，即攻击生效。博弈优势如图。
需要注意的是，r-BIND安全并不意味着s-BIND安全。事实上，这些概念是正交的。进一步说ROR和CTXT也不意味着任何意思上的绑定。
现代的AEAD方案通常被形式化成基于随机数的，这意味着不允许存在任何形式的内部随机性，而随机数则成为了显示输入，加密是确定的。与滥用投诉相关的现有系统使用随机AEAD，不符合非基于AEAD的安全性。所以会继续进一步讨论非基于随机数的AEAD方案。

** AEAD是否满足现有CE方案安全性要求

如果现有的AEAD方案也提供承诺，它将对隐含依赖对称加密的绑定(或非绑定)属性的已部署协议(如OTR或Facebook的franking方案)产生重要的积极和消极影响。经过测试，结果良好的AEAD方案可以直接用作CE方案。
上一部分的工作已经说明了AEAD符合对于保密性和完整性的定义，接下来会分别证明先编码后加密(encode-then-encipher)和先加密后MAC(encrypt-then-MAC)，其中的MAC使用的是具有碰撞抵抗的PRF，文章尝试证明MtE在ROM和ICM中是符合绑定概念的。

先编码后加密(EtE)
给定一个密钥空间内的密钥K，带有首部为H的待加密消息M，其长度为2^l，生成一个长度为r的随机序列R，计算C = E(M || R || 0^s), 结果是一个可变输入长度的密码，以首部作为调整参数。
解密过程中运行M' = D(C), 并检查M'最后的s个比特是否都为0，如果是，消息则是可用的并输出M，否则返回⊥。并为了紧凑的需求，只承诺密文的最后t位。这里给出了详细的方案。
于是得出第二个定理：设q为至多查询的次数，对于对手的博弈为结果。
该方案同时实现了完美的s-Bind安全性：任何对手的优势都是零，因为解密的输出只需在Ver中重新计算。

先加密后MAC(EtM)
该方案由对称加密方案和消息验证码组成，首先加密消息，然后计算密文和任何相关数据的MAC。
EtM是一种带有承诺的AEAD方案，KDF(密钥派生函数 key derivation function)是抗冲突的伪随机函数，承诺AEAD方案EtM(KDF, F, SE), 其中使用来自于R的随机数来源于随机数空间的加密方案SE = (Kg, Enc, Dec)， 并经由函数KDF来导出密钥。该算法不使用关联数据，并且其密钥生成是对某个固定长度的比特串的随机选择。重要的是，该方案是公开的随机数，因为我们需要其在解密期间中可恢复并使其包含在公开部分中。

定理3：
令EtM = [KDF, F, SE]， 令A为该方案的rBIND攻击者，可以得到优势：
EtM[KDF, F, SE]的s-BIND安全性是完美的，因为验证会重新加密明文以检查标签。

双密钥EtM并不绑定：
使用KDF导出上述加密和MAC密钥是实现sBind安全的必要条件，考虑省略KDF步骤，让密钥是一对(Ke, Km)，每个部分都是随机选择的。加密和验证使用的公开输出为(R, (Ke, Km))，其余部分不变，但是这会轻而易举破坏接收者绑定，当攻击者选择任意H, M, (Ke, Km), R。
并计算R || C ← Enc (Ke, M, R), T ← F(Km, H || R || C)。并选择不同于原来密钥的另一对密钥Ke'，M ← Dec(Ke', R || C)。最后并输出(H, (R, (Ke, Km))), (H, (R, (Ke' , Km))), T)。假设在不同密钥下解密相同的密文产生具有压倒性概率的不同明文，则很容易检查该对手将以接近于1的概率赢得r-Bind博弈。

先MAC后加密(MtE):
首先计算首部H和消息M的MAC， 将MAC附加到消息并对其进行加密，这种承诺AEAD方案成为MtE，在MtE模式下使用HMAC的CBC是现代TLS连接的常见密码套件,其它的RoR安全性直接继承于加密模式。下面文章假设密码基础CBC模式的块大小为n比特，并且MAC具有2n比特的输出长度。图中给出了是使用了具体的CBC模式进行加密。
与EtM不同，MtE的双密钥版本在rBind的意义上是安全的，在通过KDF派生密钥的情况下，MTE的绑定安全性是必然的。文章在这一部分给出了证明，使用CBC背后的密码建模为理想密码。

定理4：
设MtE是上面定义的方案，在CBC模式中使用随机预言机和理想密码。对于任何rBind MtE攻击者A最多对其密码进行qi次查询，对预言机进行qr次查询，并得出这样的式子。

与紧凑承诺MtE相比，s-BIND的优势为零，因为承诺与成功调用Dec后的输出唯一地决定了Ver的输入。因此，除了先前在Dec解密的密文之外，无法在Ver中计算任何其他密文，因为Ver的输入在Dec之前是固定的。

** 构成承诺和AEAD

现有的AEAD方案已经在某些情况下已经实现了紧凑承诺AEAD，然而这些方案只实现了单开口安全，因为开口中包含密钥，这一部分针对多开口AEAD方案，并关注通常由AEAD和承诺组成的方案。

首先从一个简单的一般结构，称之为Commit-then-Encrypt，其结合了CS = (Com, VerC)与AEAD方案SE = (Kg, Enc, Dec),形式上，CtE1[CS, SE] = (Kg, CtE1-Enc, CtE1-Dec, CtE1-Ver)
CtE1方案对于消息和相关数据H生成一个承诺值，并在加密过程中使用承诺值，而并非H。这还是将基础AEAD密文绑定到H和C2，对任一项的篡改都将在解密期间被检测到并被拒绝。
还可以在Enc的相关数据中包含H，但这效率较低。如果协议希望H不在承诺范围内，则可以改为仅将H包含在承诺中作为关联数据，并将其从承诺中省略。
