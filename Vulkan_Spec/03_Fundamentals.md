# Chapter 3. Fundamentals

本章介绍了基本概念，包括 Vulkan 架构和执行模型、API 语法、队列、管道配置、数字表示、状态和状态查询，以及不同类型的对象和着色器。它为解释规范其余部分中命令和行为更具体的描述提供了一个框架。

Vulkan(下称vk)要求主机的运行环境具备以下属性：

* 主机必须支持8至64位的有符号和无符号双补整数，并保证其支持按字节大小的粒度进行寻址。
* 主机必须在运行时支持32位和64位浮点类型，以满足浮点计算部分中的范围和精度约束。
* 这些类型在主机上的表示和字节序必须与所有支持的物理设备上的相同类型的表示和字节序匹配。

## 执行模型

Vulkan公开一个或多个设备(**devices**)，每个设备都公开一个或者多个队列(**queues**)，这些队列可以彼此异步处理工作。设备支持的队列集被划分为多个族(**families**)。

本规范定义了队列可能支持的以下类型的功能：图形(graphics)、计算(compute)、视频解码(video decode)、视频编码(video encode)、受保护内存管理(protected memory management)、稀疏内存管理(sparse memory management)和传输(transfer)。
队列家族的成员具有相似的能力，但是并不直接兼容。

设备内存(device memory)被应用程序显式管理，每个设备可以展现(advertise)多个堆(heap)，表示存储器的不同区域。
内存堆的更多细节是通过该堆上可用的内存类型公开，实现中可能包括：

* **device-local** 是物理连接到设备的存储器。
* **device-local,host visible** 是主机可见的设备本地内存。
* **host-local, host visible** 是主机本地的、设备和主机可见的内存。

在其他体系结构上，可能只允许一个堆可用于任何目的。

### 队列操作

队列为设备的执行引擎提供了一个接口，为执行引擎提交的命令通过被记录到一个命令缓冲区(command buffers)，然后被接着提交到队列中执行。执行的顺序取决于许多隐式和显式的排序约束。

使用队列提交命令将工作提交到队列，并且可以采用在工作开始前等待的信号量列表和在工作完成后发出信号的信号量列表。工作本身，以及信号量上的信令和等待都是队列操作。一旦提交了队列操作，队列提交命令就会将控制权返回给应用程序——它们不等待完成。

单个队列的Cmdbuffer可能会尊重提交的顺序或一些隐性约定，但是其他方面可能会不保证有序进行，例如批处理和针对单个队列的提交相较于任何其他队列提交或批处理的没有隐式排序约束。队列提交和单个批次之间的其他显式排序通过信号量(semaphores)和栅栏(fences)进行约束。

在发送栅栏或信号量之前，可以保证之前提交的任何队列操作都已完成执行，并且这些队列操作的内存写入对未来的队列操作可用。等待一个有信号的信号量或栅栏可以保证之前可用的写操作对后续命令也是可见的。

无论是在相同批次或不同批次或提交的主命令缓冲区之间，还是在主命令缓冲区(primary command buffer)和辅助命令缓冲区(secondary command buffers)之间，都不会引入任何额外的排序约束。
在任何信号量或栅栏操作之间提交一组命令缓冲区(可以包括执行辅助命令缓冲区)，执行记录的命令，就好像它们都被记录到单个主命令缓冲区中一样，只是当前状态在每个边界上被重置。显式排序约束可以用显式同步原语表示。

命令主要分为Action, State, Synchronization和Indirection以控制和调用命令之间的状态和关系。

### 对象模型

Vulkan中的设备、队列和其他实体由Vulkan对象表示。在API级别，所有对象都由句柄引用。
有两种类型的句柄：可调度(Dispatchable)和非调度(Nondispatchable)。可调度的句柄类型是指向不透明类型的指针。该指针可以被层用作拦截 API 命令的一部分，因此每个 API 命令都将可调度类型作为其第一个参数。可调度类型的每个对象在其生命周期内都必须具有唯一的handle。

不可调度句柄类型是一个64位整数类型，其含义取决于实现。如果为VkDevice启用了privateData功能，则在该设备上创建的每个不可调度类型的对象都必须具有一个句柄值，该句柄值在对象的生命周期内在该设备中创建的对象中是唯一的。不唯一将会导致重复的析构和内存释放，这无疑是危险的行为。
使用，也就是以VkDevice作为第一个参数创建或分配的所有对象都是该设备的私有对象，不得在其他设备上使用。

### 对象生命周期

对象分别由`vkCreate*`和`vkAllocate*`命令创建或分配。
一旦创建或分配了对象，其“结构”就被认为是不可变的，尽管某些对象类型的内容仍然可以自由更改。对象分别由`vkDestroy*`和`vkFree*`命令销毁或释放。

被Alloc的对象从其对应的pool或者说heap中获取资源，被Free后重新释放回去。pool的设计是为了降低反复的分配和释放所带来的性能负荷。
设计所有对象完整的生命周期是开发者的义务。

以下对象类型在传递到Vulkan命令中时会被使用，而用于创建的对象不会进一步访问这些对象类型:
• `VkShaderModule`
• `VkPipelineCache`
• `VkValidationCacheEXT`
说人话就是，`VkShaderModule`对象只会在创建对应的Pipeline时被使用，创建完成后不会有进一步的需求。

对于大部分对象而言，在设备执行对于其的使用之前，例如对象参与的命令缓冲区处于挂起状态时，应用程序执行销毁可能会导致严重的后果。

一般来说，对象可以以任何顺序被销毁或释放，即使被释放的对象涉及到另一个对象的使用，只要使用释放对象的任何对象不以任何方式被进一步使用。
当对象之间存在父/子关系时，这是一个例外。在这种情况下，应用程序不得在其子对象之前销毁父对象，除非明确定义父对象以在销毁时释放其子对象。(例如，pool对象，`VkCommandPool`对象是`VkCommandBuffer`对象的父对象)

以下Vulkan对象对何时可以销毁有特定限制：

* `VkQueue`对象无法显式销毁。相反，当从中检索它们的`VkDevice`对象被销毁时，它们会被隐式销毁。
* 销毁pool会导致隐性释放从中分配的所有对象。
* 当从`VkDevice`对象中检索到的所有VkQueue对象都是空闲的，并且从它们创建的所有对象都被销毁时，`VkDevice`对象可以被销毁。
* `VkPhysicalDevice`对象不能被显式销毁。相反，当从中获取它们的VkInstance对象被销毁时，它们将被隐式地销毁。
* 一旦从任何`VkPhysicalDevice`对象创建的所有VkDevice对象被销毁，VkInstance对象就可以被销毁。

### 外部对象句柄

从`VkDevice`创建或分配的对象句柄的范围仅限于该逻辑设备。不在作用域中的对象称为外部对象(External Object)。

## 应用二进制接口

共享库实现必须使用平台的标准C编译器的默认应用程序二进制接口(Application Binary Interface, ABI)，或者提供自定义API头，使应用程序代码使用实现的非默认ABI。
ABI在这里指的是大小、对齐方式、C数据类型的布局;过程调用约定;以及与C函数对应的共享库符号的命名约定。定制平台的调用约定通常是通过在`vk_platform.h`中适当地定义调用约定宏来完成的。

在Vulkan作为共享库提供的平台上，以“vk”开头，后跟数字或大写字母的库符号被保留供实现使用。使用Vulkan的应用程序不能提供这些符号的定义。这允许Vulkan共享库为新的API版本或扩展使用额外的符号进行更新，而不会与现有应用程序产生符号冲突。
共享库实现应该为它们支持的最高版本规范中的命令提供库符号，以及与平台相关的窗口系统集成扩展。它们还可以为由其他扩展定义的命令提供库符号。

## 命令格式及持续时间

Spec将Vulkan命令描述为使用C99语法的函数或过程。其他语言(如c++和JavaScript)的语言绑定可能允许更严格的参数传递或面向对象接口。

通过调用形式为`vkCmd*`的API命令，将命令记录到命令缓冲区中。每个这样的命令可能对其使用位置有不同的限制：在主和/或辅助命令缓冲区中，在渲染过程内部和/或外部，以及在一个或多个受支持的队列类型中。这些限制与每个此类命令的定义一起记录在案。
创建或破坏Vulkan对象的每个命令的最后一个参数是`pAllocator`。`pAllocator`参数可以设置为非空值，以便给定对象的分配被委托给提供的回调的应用程序；有关详细信息，请参阅内存分配章节。

Vulkan命令的持续时间(duration)是指调用命令与其返回到调用者之间的间隔。

### 检索结果的生命周期

使用`vkGet*`和`vkEnumerate*`形式的命令从实现中检索信息。
除非对单个命令另有规定，否则结果是不变的；也就是说，当通过使用相同的参数调用相同的命令再次检索时，只要这些参数本身都保持有效，它们将保持不变。

## 线程行为

Vulkan旨在在多个主机线程上使用时提供可扩展的性能。所有命令都支持从多个线程并发调用，但某些参数或参数的组件被定义为外部同步(externally synchronized)。这意味着被调用者必须保证在给定时间内使用此类参数的线程不超过一个。
更准确地说，Vulkan命令使用简单的存储来更新Vulkan对象的状态。在主机执行命令期间，被声明为外部同步的参数可以随时更新其内容。如果两个命令在同一个对象上操作，并且其中至少有一个命令声明该对象是外部同步的，那么调用者不仅必须保证这些命令不会同时执行，而且还必须保证这两个命令被适当的内存屏障分隔开（如果需要的话）。

同样，应用程序必须避免应用程序拥有的内存的任何潜在数据危险，这些内存的所有权暂时由Vulkan命令获得。虽然应用程序拥有的内存的所有权仍然是由命令获得的，但实现可以在任何时候读取内存，也可以在任何时候写入非const限定的内存。在规范中，引用非构造的应用程序拥有的内存的参数没有显式地标记为外部同步。
如果应用程序在命令中使用**延迟的主机操作**(deferred host operations)，并且该操作被成功延迟，则传递给该命令的对象参数和应用程序拥有的内存可以在任何时候访问，直到延迟的操作完成。
许多对象在构造完成后就是不可变的，抛开不可变对象不谈，可变对象的参数往往是内部同步的，因而不需要外部同步。
任何未标记为外部同步的命令参数要么不被命令更改，要么是内部同步的。此外，与命令参数相关的某些对象(例如命令池和描述符池)可能会受到命令的影响，并且也必须进行外部同步。

此外，还有一些隐式参数需要进行外部同步。例如，当`commandBuffer`参数需要外部同步时，这意味着分配该命令缓冲区的`commandpool`也需要外部同步。

## 有效的使用

有效的使用(Valid Usage)定义了一组必须满足的条件，以便在应用程序中实现良好定义的运行时行为。这些条件仅依赖于Vulkan状态，以及使用受条件约束的参数或对象。

核心层假定应用程序正确地使用了API。除了在规范的其他地方记录之外，核心层对错误使用API的应用程序的行为是未定义的，并且可能包括程序终止。但是，实现必须确保应用程序的错误使用不会影响操作系统、Vulkan实现或系统中其他Vulkan客户端应用程序的完整性。特别是，对于任何内存分配，Vulkan实现都不能违反操作系统对一个进程的内存是否可以对另一个进程可见的任何保证。Vulkan实现不需要在操作系统提供的安全或完整性保证之外做出额外的安全或完整性保证，除非应用程序明确指示使用特定的功能或扩展。

例如，如果一个操作系统保证其所有内存分配中的数据在新分配时被设置为零，Vulkan实现必须对其控制的任何分配(例如`VkDeviceMemory`)做出相同的保证。类似地，如果操作系统保证主机分配的use-after-free不会导致另一个进程写入的值变得可见，那么Vulkan实现必须对设备内存做出同样的保证。

### 使用验证

Vulkan是一个分层API。最低层是核心Vulkan层，由Spec定义。应用程序可以使用核心之上的附加层进行调试、验证和其他目的。
Vulkan的核心原则之一是构建和提交命令缓冲区应该是高效的。因此，核心层中的错误检查和状态验证是最小的，尽管可以通过使用一些层来实现更严格的验证。
正确使用API的验证留给**验证层**(validation layers)。开发应用程序时应该启用验证层，以帮助捕获和消除错误。一旦验证，发布的应用程序默认情况下不应该启用验证层。

### 隐性合法使用

**对象句柄**，作为对象句柄的命令的任何输入参数必须是有效的对象句柄，除非另有指定。对象句柄在以下情况下是有效的：

•它已被先前成功调用API创建或分配。这些调用在规范中有说明。
•它没有被先前对API的调用删除或释放。这些调用在规范中有说明。
•该对象使用的任何对象，无论是作为创建或执行的一部分，也必须是有效的。

当在规范中显式调用时，保留值`VK_NULL_HANDLE`和`NULL`(`nullptr`)可以分别用于代替有效的不可调度句柄和可调度句柄。任何成功创建对象的命令都不能返回这些值。将这些值传递给`vkDestroy*`或`vkFree*`命令是有效的，它们将静默地忽略这些值。

**指针**，任何作为指针的参数只有在由valid Usage语句显式调用时才必须是有效指针。如果指针指向包含命令所期望的数字和类型值的内存，并且通过指针访问的所有基本类型（例如，作为数组的元素或结构的成员）都满足主机处理器的对齐要求，则指针是“有效的”。

**字符串**，任何指向char的指针参数都必须是以`NULL`字符结尾的有限值序列，或者如果在规范中明确调用，则可以是`NULL`。

**枚举类型**，枚举类型的任何参数都必须是该类型的有效枚举项。如果以下条件成立，则枚举数的使用是有效的：

• 枚举器被定义为枚举类型的一部分。
• 枚举符不是以`_MAX_ENUM`作为后缀的值。该值的存在只是为了确保C枚举类型的大小为32位，应用程序不得使用。
• 如果枚举器用于以VkInstance作为其第一个参数的函数，并且：它是由支持的核心版本添加的（如`a`所报告的），并且`VkApplicationInfo::apiVersion`的值大于或等于添加它的版本；或者是由为实例启用的实例扩展添加的。
• 如果枚举器用于将`VkPhysicalDevice`对象作为其第一个参数的函数，并且其中一个参数为：该枚举器是由该设备支持的核心版本添加的（如`VkPhysicalDeviceProperties::apiVersion`所报告的）；它是由为实例启用的实例扩展添加的；或由该设备支持的设备扩展添加。

此外，如果支持`maintenance5`，则在以`VkPhysicalDevice`对象作为其第一个参数的函数中使用时，在对定义的类型有效的范围内表示的任何整数值都是有效的。物理设备查询将返回指示缺乏支持的结果，或者在用作`Vk*Flags*`参数中的位标志时忽略不支持的值。
鼓励应用程序开发人员在Vulkan API枚举中使用开关语句时要小心。这是因为新的扩展可以向现有枚举添加新的值。在开关中使用`default:`语句可以避免将来的编译问题。

