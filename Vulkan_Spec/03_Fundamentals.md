# Chapter 3. Fundamentals

本章介绍了基本概念，包括 Vulkan 架构和执行模型、API 语法、队列、管道配置、数字表示、状态和状态查询，以及不同类型的对象和着色器。它为解释规范其余部分中命令和行为更具体的描述提供了一个框架。

Vulkan(下称vk)要求主机的运行环境具备以下属性：

* 主机必须支持8至64位的有符号和无符号双补整数，并保证其支持按字节大小的粒度进行寻址。
* 主机必须在运行时支持32位和64位浮点类型，以满足浮点计算部分中的范围和精度约束。
* 这些类型在主机上的表示和字节序必须与所有支持的物理设备上的相同类型的表示和字节序匹配。

## 执行模型

Vulkan公开一个或多个设备(**devices**)，每个设备都公开一个或者多个队列(**queues**)，这些队列可以彼此异步处理工作。设备支持的队列集被划分为多个族(**families**)。

本规范定义了队列可能支持的以下类型的功能：图形(graphics)、计算(compute)、视频解码(video decode)、视频编码(video encode)、受保护内存管理(protected memory management)、稀疏内存管理(sparse memory management)和传输(transfer)。
队列家族的成员具有相似的能力，但是并不直接兼容。

设备内存(device memory)被应用程序显式管理，每个设备可以展现(advertise)多个堆(heap)，表示存储器的不同区域。
内存堆的更多细节是通过该堆上可用的内存类型公开，实现中可能包括：

* **device-local** 是物理连接到设备的存储器。
* **device-local,host visible** 是主机可见的设备本地内存。
* **host-local, host visible** 是主机本地的、设备和主机可见的内存。

在其他体系结构上，可能只允许一个堆可用于任何目的。

### 队列操作

队列为设备的执行引擎提供了一个接口，为执行引擎提交的命令通过被记录到一个命令缓冲区(command buffers)，然后被接着提交到队列中执行。执行的顺序取决于许多隐式和显式的排序约束。

使用队列提交命令将工作提交到队列，并且可以采用在工作开始前等待的信号量列表和在工作完成后发出信号的信号量列表。工作本身，以及信号量上的信令和等待都是队列操作。一旦提交了队列操作，队列提交命令就会将控制权返回给应用程序——它们不等待完成。

单个队列的Cmdbuffer可能会尊重提交的顺序或一些隐性约定，但是其他方面可能会不保证有序进行，例如批处理和针对单个队列的提交相较于任何其他队列提交或批处理的没有隐式排序约束。队列提交和单个批次之间的其他显式排序通过信号量(semaphores)和栅栏(fences)进行约束。

在发送栅栏或信号量之前，可以保证之前提交的任何队列操作都已完成执行，并且这些队列操作的内存写入对未来的队列操作可用。等待一个有信号的信号量或栅栏可以保证之前可用的写操作对后续命令也是可见的。

无论是在相同批次或不同批次或提交的主命令缓冲区之间，还是在主命令缓冲区(primary command buffer)和辅助命令缓冲区(secondary command buffers)之间，都不会引入任何额外的排序约束。
在任何信号量或栅栏操作之间提交一组命令缓冲区(可以包括执行辅助命令缓冲区)，执行记录的命令，就好像它们都被记录到单个主命令缓冲区中一样，只是当前状态在每个边界上被重置。显式排序约束可以用显式同步原语表示。

