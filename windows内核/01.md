# windows内核基础

## 内核理论基础

* 关于权限级别

核心态:即系统内核层，位于零环(R0),拥有最高权限。
用户态：R3级，拥有最低权限。
在设计操作系统时，只保留了R0和R3两个级别。HAL是一个可加载的核心模块HAL.DLL，为运行在WindowsXP上的硬件平台提供低级接口。WindowsXP的执行体是NTOSKRNL.EXE的上层(内核是其下层)，用户层导出并且可以调用的函数接口在NTDLL.DLL中，通过Win32API或其他子系统对其进行调用。要想控制系统，就必须获取R0级别的权限。

 ![Alt](./res/pic01_01.png#pic_center)

* 内存空间布局

对于32位x86的寻址，可以通过使用PAE技术增加到2^36位寻址，以扩大到64GB。
对于一个4GB的虚拟空间，Windows系统的内存主要分为内核空间和应用层两部分，各占约2GB，其中还包括64KB的非法区域和NULL空间。Windows内存的逻辑地址分为两部分：段选择和偏移地址。CPU进行地址翻译的时候，先通过分段机制计算出一个线性地址，再通过页表机制将线性地址映射到物理地址，从而存取物理内存中的数据和指令。

 ![Alt](./res/pic01_02.png#pic_center)

* windows启动过程

1. 启动自检:硬件初始化检查，从BIOS载入必要的命令并在屏幕上显示信息。
2. 初始化启动阶段：完成自检后，根据CMOS的设置加载引导启动盘，将主引导记录(MBR)中的引导代码载入内存，启动过程由MBR执行，搜索MBR中的分区表找到活动分区，将第一个扇区中的引导代码载入内存，引导代码检测当前使用的文件系统，查找ntldr文件并启动。BIOS将控制权交给ntldr，完成操作系统的启动(win7使用的是Bootmgr)
3. Boot加载阶段分为几步进行，首先从启动分区启动ntldr后，进行内存模式的设置，同时检查处理器的位数和操作系统的版本，设置对应的内存模式是32位还是64位。启动一个简单的文件系统定位boot.ini、ntoskrnl、Hal等启动文件。最后读取boot.ini文件
4. 在这一阶段会检查和配置一些硬件设备，如系统固件总线适配器和一些输入输出设备等。
5. 在内核加载阶段，ntldr首先加载Windows内核ntoskrnl.exe和硬件抽象层(HAL)。HAL会对硬件底层的特性进行隔离，为操作系统提供统一的调用接口。接下来ntldr从注册表的HKEY/System/CurrentControlSet键下读取这台机器安装的驱动程序，然后依次加载程序。初始化底层设备驱动，在注册表的HKEY_LOCAL_MACHINE/System/CurrentControlSet/Services键下查找“Start”键的值为0和1的驱动。
关于start键的值：总共有0~4五个级别，数值越小，级别越高，启动就越早。0级表示内核刚刚初始化，加载的是与系统核心有关的重要驱动程序。2级是从登录界面出现的时候开始。3表示手动加载。4表示禁止加载。

CMOS:是一块用来保存计算机基本启动信息的芯片，是主板上一块可以读写的RAM，用来保存BIOS的硬件配置和用户某些参数的设定。
BIOS:其中保存着系统CPU、软硬盘驱动器、显示器和键盘等部件信息，有一块后备电池向其中供电。

* windows的会话管理启动

驱动程序加载后，内核启动会话管理器(smss.exe)，是windows系统中第一个创建的用户模式进程。作用如下：
创建系统环境变量。
加载win32k.sys，它是Windows子系统的内核模式部分。
启动csrss.exe，它是Windows子系统的用户模式部分。
启动winlogon.exe
创建虚拟内存页面文件。
执行上次系统重启前未完成的重命名工作(PendingFileRename)

* 登录阶段

windows子系统启动的winlogon系统服务提供对Windows用户的登录和注销的支持，完成如下工作：
启动服务子系统services.exe,也称为服务控制器SCM。
启动本地安全授权LAS过程lsass.exe，LSA在登录验证时判断用户提供的信息是否正确，并反馈结果。
显示登录界面。

和win7的区别是，首先BIOS从MBR中找到Bootmgr，由Bootmgr完成操作系统的启动工作。且选择win7系统后，Bootmgr读取系统文件windows/system32/winload.exe，并将控制权交给winload。

* 新的系统引导方式UEFI和GPT

通过BIOS和MBR完成系统引导和启动是传统的系统启动方式。局限性在于磁盘逻辑块地址(LBA)是32位，最多表示2^32个扇区，一个扇区的大小一般为512字节，最多支持2TB。之前的方式中，启动操作系统之前必须要从硬盘上的指定扇区中读取系统启动代码，然后从活动分区中引导并启动操作系统。

UEFI(统一可扩展固件接口)的出现主要用于替换BIOS，在UEFI中，表示LBA的地址是64位的，突破了容量限制。其本身已经相当于是一个微型操作系统，具备文件系统的支持能力，能够直接读取FAT分区中的文件。可以开发出直接在UEFI下运行的程序，通常以"efi"结尾。

## Windows R3和R0通信

1. 当程序调用一个有关I/O的API，实际上这个API被封装在应用层的某个DLL库(Kernel32.dll和user32.dll)文件中，而这DLL中还会调用更底层的函数包含在ntdll.dll文件中。
2. 调用在ntdll.dll中的Native API函数是成对出现的，分别以"Nt"和"Zw"开头，本质上是一样的。
3. kernerl32.dll中的API通过ntdll.dll执行时，会完成一个参数的检查工作，再调用一个中断(int 2Eh或SysEnter)从R3进入R0，在内核ntoskrnl.exe中有一个SSDT，里面存放了与ntdll.dll中对应的SSDT系统服务处理函数，即内核态的Nt*系列函数。

SSDT:系统服务描述符表，负责把R3的WIN32 API和R0的内核API联系起来，不仅仅包含庞大的地址索引表，包含一些其他信息诸如地址索引的基地址、服务函数个数等。通过修改此表对于Windows常用函数及API进行Hook。第一个参数指向的地址存储是全部的内核函数。后面跟着是ssdt表中内核函数的数量，

* 从用户模式调用Nt* 和Zw*API连接ntdll.lib

本质上没有区别，都是通过设置系统服务表中的索引和在栈中设置参数，经由SYSENTER(或syscall)指令进入内核态，并最终由LiSystemService跳转到KiServiceTable对应的系统服务例程中，从用户模式进入内核模式传入的参数，会被严格检查。

* 从内核模式调用Nt* 和Zw* API连接ntoskrnl.lib

Nt系列API将直接调用对应的函数代码，而Zw系列API通过KiSystemService最终跳转到对应的函数代码处。这两种对于内核中Previous Mode的改变不同，如果用户调用Native API，Previous Mode是用户态；如果从内核模式调用Native API则Previous Mode是内核态。

## 谈谈从R3进入R0

API会通过两种方式进入零环，通过调用SystemCall和int 0x2E，首先介绍关于_KUSER_SHARD_DATA结构区域。在用户层和内核层分别定义了一个_KUSER_SHARD_DATA区域，用于在用户层和内核层共享数据，都使用固定的地址值映射，为：
User层：0x7FFE 0000
Kernel层：0xFFDF 0000
User层和Kernel层映射同一个物理页，虽然指向同一个物理页，但是在User层是只读，在Kernel层是可读写的。
操作系统在启动的时候，需要初始化_KUSER_SHARD_DATA这个结构体，最重要的是初始化0x300这个位置，操作系统往里面写一个函数，决定了所有从三环进入零环的方式。在写入之前会通过cpuid这个指令检查当前的CPU是否支持快速调用，如果支持就写入KiFastSystemCall，不支持则写入KiIntSystemCall，KiIntSystemCall只有三行代码:

```asm
lea edx, [esp+arg_4]
int 2Eh
retn
```

利用int 0x2E这条指令通过中断门的方式进入零环。

 ![Alt](./res/pic01_03.png#pic_center)
